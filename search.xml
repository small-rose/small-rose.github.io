<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos相关配置</title>
    <url>/posts/42e4f857.html</url>
    <content><![CDATA[<h2 id="Centos各种配置"><a href="#Centos各种配置" class="headerlink" title="Centos各种配置"></a>Centos各种配置</h2><h2 id="1-Centos网络配置"><a href="#1-Centos网络配置" class="headerlink" title="1.Centos网络配置"></a>1.Centos网络配置</h2><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p>有图形界面可以直接界面操作，没有界面可以参考一下：<br>（1）修改配置</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> /etc/sysconfig/network-scripts/</code></pre>
<p>修改对应网卡的配置，可以ifconfig看看用的网卡名。<br>修改相关配置：</p>
<pre><code>TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=none
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens192
UUID=64e7784d-8183-4db5-af4c-120203391708
DEVICE=ens192
ONBOOT=yes
IPADDR=192.168.66.80
PREFIX=24
GATEWAY=192.168.66.254
IPV6_PRIVACY=no</code></pre><p>（2）重启网络服务</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">service</span> network restart</code></pre>
<h2 id="2-Centos时间配置"><a href="#2-Centos时间配置" class="headerlink" title="2.Centos时间配置"></a>2.Centos时间配置</h2><p>设置时区同样,在 CentOS 7 中, 引入了一个叫 timedatectl 的设置设置程序.<br>用法很简单:<code>timedatectl # 查看系统时间方面的各种状态</code></p>
<pre><code>      Local time: 四 2014-12-25 10:52:10 CST
  Universal time: 四 2014-12-25 02:52:10 UTC
        RTC time: 四 2014-12-25 02:52:10
        Timezone: Asia/Shanghai (CST, +0800)
     NTP enabled: yes
NTP synchronized: yes
 RTC in local TZ: no
      DST active: n/a</code></pre><h4 id="列出所有时区"><a href="#列出所有时区" class="headerlink" title="列出所有时区"></a>列出所有时区</h4><pre class=" language-bash"><code class="language-bash">$ timedatectl list-timezones </code></pre>
<h4 id="将硬件时钟调整为与本地时钟一致-0-为设置为-UTC-时间"><a href="#将硬件时钟调整为与本地时钟一致-0-为设置为-UTC-时间" class="headerlink" title="将硬件时钟调整为与本地时钟一致, 0 为设置为 UTC 时间"></a>将硬件时钟调整为与本地时钟一致, 0 为设置为 UTC 时间</h4><pre class=" language-bash"><code class="language-bash">$ timedatectl set-local-rtc 1 </code></pre>
<h4 id="设置系统时区为上海"><a href="#设置系统时区为上海" class="headerlink" title="设置系统时区为上海"></a>设置系统时区为上海</h4><pre class=" language-bash"><code class="language-bash">$ timedatectl set-timezone Asia/Shanghai </code></pre>
<h4 id="直接修改时间时区"><a href="#直接修改时间时区" class="headerlink" title="直接修改时间时区"></a>直接修改时间时区</h4><p>其实不考虑各个发行版的差异化, 从更底层出发的话, 直接修改时间时区:</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></pre>
<h2 id="3-DNS解析问题"><a href="#3-DNS解析问题" class="headerlink" title="3.DNS解析问题"></a>3.DNS解析问题</h2><p>ping IP可以 ping 域名不通的时候</p>
<pre class=" language-bash"><code class="language-bash">$ vim /etc/resolve.conf</code></pre>
<p>增加：</p>
<pre><code>nameserver 8.8.8.8
nameserver 8.8.4.4</code></pre>]]></content>
      <categories>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos-jdk安装配置环境变量</title>
    <url>/posts/9064540a.html</url>
    <content><![CDATA[<h2 id="Centos上jdk配置"><a href="#Centos上jdk配置" class="headerlink" title="Centos上jdk配置"></a>Centos上jdk配置</h2><h2 id="1-检查环境"><a href="#1-检查环境" class="headerlink" title="1.检查环境"></a>1.检查环境</h2><p>查看java版本</p>
<pre class=" language-bash"><code class="language-bash">java -version</code></pre>
<p> 检查是否已经安装jdk，通常默认自认openjdk</p>
<pre class=" language-bash"><code class="language-bash">java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64
java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64
java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64
java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64</code></pre>
<p> 如果要卸载,需要root用户权限才可以执行：</p>
<pre class=" language-bash"><code class="language-bash">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64
rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64
rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64
rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64</code></pre>
<p>再次查看java版本，如提示未找到命令则删除成功。</p>
<h2 id="2-上传jdk安装文件"><a href="#2-上传jdk安装文件" class="headerlink" title="2.上传jdk安装文件"></a>2.上传jdk安装文件</h2><h4 id="上传方法"><a href="#上传方法" class="headerlink" title="上传方法"></a>上传方法</h4><p>（1）可以联网直接下载即可<br>（2）ssh可以安装用rz/sz上传下载<br>（3）ftp自行安装ftp服务，关于安装教程可到：</p>
<p>上传jdk-7u80-linux-x64.tar.gz到你的目录后，<br>解压后移动到 <code>/usr/jdk1.7.0_80</code></p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">tar</span> -zxvf jdk-7u80-linux-x64.tar.gz
<span class="token function">cp</span>  jdk-7u80 /usr/jdk1.7.0_80</code></pre>
<p>【关于解压命令大全可以移步：】</p>
<h2 id="2-配置关变量"><a href="#2-配置关变量" class="headerlink" title="2.配置关变量"></a>2.配置关变量</h2><p>/etc/profile全局变量配置</p>
<pre class=" language-bash"><code class="language-bash">vim /etc/profile</code></pre>
<p>.bash_profile为root用户的环境变量。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /root/
<span class="token function">ls</span> -a
<span class="token function">vi</span> .bash_profile</code></pre>
<p>二者均可，建议修改用户环境变量。<br>在文件末尾增加java环境变量即可,听说CentOS6上面的是JAVAHOME，CentOS7是{JAVA_HOME}</p>
<pre><code># .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

export JAVA_HOME=/usr/jdk1.7.0_80
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
PATH=$PATH:$HOME/bin:$JAVA_HOME/bin

export PATH</code></pre><h2 id="3-让刚刚设置的环境变量生效"><a href="#3-让刚刚设置的环境变量生效" class="headerlink" title="3.让刚刚设置的环境变量生效"></a>3.让刚刚设置的环境变量生效</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">source</span> /etc/profile</code></pre>
<p>或者</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">source</span> .bash_profile</code></pre>
<h2 id="4-再次验证是否配置成功"><a href="#4-再次验证是否配置成功" class="headerlink" title="4.再次验证是否配置成功"></a>4.再次验证是否配置成功</h2><pre class=" language-bash"><code class="language-bash">java -version</code></pre>
<p>出现java版本号代表安装成功。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>各厂商数据库字段的Java类型和JDBC类型对应关系</title>
    <url>/posts/dc390855.html</url>
    <content><![CDATA[<p>常见数据库字段的Java类型和JDBC类型对应关系</p>
<a id="more"></a>

<p><img src="/medias/loading-animated.gif" data-original="/images/db_jdbcType.jpg" alt="Image text"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DB</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>js让页面自动刷新</title>
    <url>/posts/7413f2ca.html</url>
    <content><![CDATA[<p>js让页面自动刷新</p>
<a id="more"></a>

<h6 id="想让页面自动刷新"><a href="#想让页面自动刷新" class="headerlink" title="想让页面自动刷新?"></a>想让页面自动刷新?</h6><p>F12 —– 控制台 —– 使用下面代码，OK。</p>
<pre class=" language-javascript"><code class="language-javascript">timeout<span class="token operator">=</span><span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">"Set timeout (Second):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
count<span class="token operator">=</span><span class="token number">0</span>
current<span class="token operator">=</span>location<span class="token punctuation">.</span>href<span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>timeout<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">'reload()'</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
location<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">'reload()'</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
count<span class="token operator">++</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'每（'</span><span class="token operator">+</span>timeout<span class="token operator">+</span><span class="token string">'）秒自动刷新,刷新次数：'</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
fr4me<span class="token operator">=</span><span class="token string">'&lt;frameset cols=\'*\'>\n&lt;frame src=\''</span><span class="token operator">+</span>current<span class="token operator">+</span><span class="token string">'\'/>'</span><span class="token punctuation">;</span>
fr4me<span class="token operator">+</span><span class="token operator">=</span><span class="token string">'&lt;/frameset>'</span><span class="token punctuation">;</span>
<span class="token keyword">with</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">write</span><span class="token punctuation">(</span>fr4me<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的SSH免密使用</title>
    <url>/posts/6ac07d1a.html</url>
    <content><![CDATA[<pre><code>本文记录关于Git的免密使用，连接Github免密和 云服务器或私有服务器免密。</code></pre><h3 id="一-Github的Git免密使用"><a href="#一-Github的Git免密使用" class="headerlink" title="一  Github的Git免密使用"></a>一  <code>Github</code>的Git免密使用</h3><h4 id="1-客户端生成密钥"><a href="#1-客户端生成密钥" class="headerlink" title="1 客户端生成密钥"></a>1 客户端生成密钥</h4><pre><code>ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</code></pre><p>然后会出现询问，大概意思如下：</p>
<pre><code>1. 确认秘钥的保存路径（如果不需要改路径则直接回车）；
2. 如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；
3. 创建密码（如果不需要密码则直接回车）；
4. 确认密码；</code></pre><p>要免密登录请输密码的时候回车即可。根据提示找到密钥所在文件：</p>
<pre><code>id_rsa  #私钥
id_rsa.pub  #公钥</code></pre><h4 id="2-Github配置SSH公钥"><a href="#2-Github配置SSH公钥" class="headerlink" title="2  Github配置SSH公钥"></a>2  <code>Github</code>配置SSH公钥</h4><p> 登录git账户，<code>Setting</code>，<code>SSH and GPG keys</code>, <code>New ssh key</code></p>
<p>把<code>id_rsa.pub</code>的内容粘贴到key的文本域，点击<code>Add SSH key</code>完成。</p>
<p>后续的客户端git操作就不要密码了。</p>
<h3 id="二-Git服务器配置SSH免密"><a href="#二-Git服务器配置SSH免密" class="headerlink" title="二 Git服务器配置SSH免密"></a>二 <code>Git</code>服务器配置SSH免密</h3><p>注意：这里的Git服务器可以是云服务器或者自己的私服务器。本次操作环境是<code>Centos 7</code>。</p>
<h4 id="1-客户端生成密钥-1"><a href="#1-客户端生成密钥-1" class="headerlink" title="1 客户端生成密钥"></a>1 客户端生成密钥</h4><p>注意：同上，如果已经配置过<code>Github</code>的ssh免密上面已经有了可以不用重复生成，可以直接跳到第二步。</p>
<pre><code>ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</code></pre><p>然后会出现询问，大概意思如下：</p>
<pre><code>1. 确认秘钥的保存路径（如果不需要改路径则直接回车）；
2. 如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；
3. 创建密码（如果不需要密码则直接回车）；
4. 确认密码；</code></pre><p>要免密登录请输密码的时候回车即可。根据提示找到密钥所在文件：</p>
<pre><code>id_rsa  #私钥
id_rsa.pub  #公钥</code></pre><h4 id="2-服务端导入客户端公钥"><a href="#2-服务端导入客户端公钥" class="headerlink" title="2  服务端导入客户端公钥"></a>2  服务端导入客户端公钥</h4><p>在/home/git下已经创建.ssh目录，然后创建authorized_keys文件，并将客户端生成的公钥导入进去。</p>
<pre><code>cd /home/git/
mkdir .ssh
chmod 755 .ssh
touch .ssh/authorized_keys
chmod 644 .ssh/authorized_keys</code></pre><p>将 <code>id_rsa.pub</code> 文件的内容写入<code>authorized_keys</code></p>
<h4 id="3-服务端SSH开启RSA认证"><a href="#3-服务端SSH开启RSA认证" class="headerlink" title="3  服务端SSH开启RSA认证"></a>3  服务端<code>SSH</code>开启<code>RSA</code>认证</h4><p>如果没有安装SSH服务，请先安装SSH服务。</p>
<pre class=" language-bash"><code class="language-bash">vim /etc/ssh/sshd_config</code></pre>
<p>其中三个地方的设置要确认如下：</p>
<pre><code>RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys</code></pre><p>git用户不允许登录shell</p>
<pre class=" language-bash"><code class="language-bash">vim /etc/passwd</code></pre>
<p>将</p>
<pre><code>git:x:502:502::/home/git:/bin/bash</code></pre><p> 改为</p>
<pre><code>git:x:502:502::/home/git:/usr/local/git/bin/git-shell</code></pre>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>SSH免密</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>开发常用的网站收藏列表</title>
    <url>/posts/2d1a17c5.html</url>
    <content><![CDATA[<h4 id="API在线"><a href="#API在线" class="headerlink" title="API在线"></a>API在线</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>常用API文档索引</td>
<td><a href="https://tool.oschina.net/apidocs" target="_blank" rel="noopener">https://tool.oschina.net/apidocs</a></td>
</tr>
<tr>
<td>java8 API</td>
<td><a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">https://www.matools.com/api/java8</a></td>
</tr>
<tr>
<td>Mybatis java API</td>
<td>h<a href="https://mybatis.org/mybatis-3/zh/java-api.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/java-api.html</a></td>
</tr>
<tr>
<td>dubbo API</td>
<td><a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/api.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/configuration/api.html</a></td>
</tr>
</tbody></table>
<h4 id="开源网站"><a href="#开源网站" class="headerlink" title="开源网站"></a>开源网站</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>github网站</td>
<td><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></td>
</tr>
<tr>
<td>码云</td>
<td><a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></td>
</tr>
<tr>
<td>一起开源官网</td>
<td><a href="http://www.17ky.net/" target="_blank" rel="noopener">http://www.17ky.net/</a></td>
</tr>
<tr>
<td>Open JDK</td>
<td><a href="http://openjdk.java.net/" target="_blank" rel="noopener">http://openjdk.java.net/</a></td>
</tr>
<tr>
<td>Open JDK  HotSpot</td>
<td><a href="https://wiki.openjdk.java.net/display/HotSpot/Main" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/Main</a></td>
</tr>
</tbody></table>
<h4 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>ORICLE官网</td>
<td><a href="https://www.oracle.com/downloads/" target="_blank" rel="noopener">https://www.oracle.com/downloads/</a></td>
</tr>
<tr>
<td>JAVA官网</td>
<td><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></td>
</tr>
<tr>
<td>ECLIPSE官网</td>
<td><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/</a></td>
</tr>
<tr>
<td>IntelliJ IDEA</td>
<td><a href="http://www.jetbrains.com/" target="_blank" rel="noopener">http://www.jetbrains.com/</a></td>
</tr>
<tr>
<td>springtoolsuite</td>
<td><a href="https://spring.io/tools" target="_blank" rel="noopener">https://spring.io/tools</a></td>
</tr>
<tr>
<td>Python官网</td>
<td><a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a></td>
</tr>
<tr>
<td>Maven官网</td>
<td><a href="https://maven.apache.org/" target="_blank" rel="noopener">https://maven.apache.org/</a></td>
</tr>
<tr>
<td>Maven仓库</td>
<td><a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a></td>
</tr>
<tr>
<td>Nexus官网</td>
<td><a href="https://www.nexusmods.com/" target="_blank" rel="noopener">https://www.nexusmods.com/</a></td>
</tr>
<tr>
<td>Ant官网</td>
<td><a href="https://ant.apache.org/" target="_blank" rel="noopener">https://ant.apache.org/</a></td>
</tr>
<tr>
<td>SVN官网</td>
<td><a href="https://tortoisesvn.net/" target="_blank" rel="noopener">https://tortoisesvn.net/</a></td>
</tr>
<tr>
<td>Git官网</td>
<td><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></td>
</tr>
<tr>
<td>Spring官网</td>
<td><a href="https://spring.io/" target="_blank" rel="noopener">https://spring.io/</a></td>
</tr>
<tr>
<td>mybatis</td>
<td><a href="https://mybatis.org/mybatis-3/" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/</a></td>
</tr>
<tr>
<td>#### 服务相关</td>
<td></td>
</tr>
<tr>
<td>网站</td>
<td>地址</td>
</tr>
<tr>
<td>—————</td>
<td>——————————————–</td>
</tr>
<tr>
<td>APACHE官网</td>
<td><a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></td>
</tr>
<tr>
<td>Tomcat官网</td>
<td><a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></td>
</tr>
<tr>
<td>Nginx官网</td>
<td><a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a></td>
</tr>
<tr>
<td>Dubbo官网</td>
<td><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a></td>
</tr>
<tr>
<td>Zookeeper</td>
<td><a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">https://zookeeper.apache.org/</a></td>
</tr>
<tr>
<td>netty</td>
<td><a href="https://netty.io/" target="_blank" rel="noopener">https://netty.io/</a></td>
</tr>
<tr>
<td>jetty</td>
<td><a href="http://www.eclipse.org/jetty/" target="_blank" rel="noopener">http://www.eclipse.org/jetty/</a></td>
</tr>
</tbody></table>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td><a href="https://www.linux.org/" target="_blank" rel="noopener">https://www.linux.org/</a></td>
</tr>
<tr>
<td>Linux开源社区</td>
<td><a href="https://linux.cn/" target="_blank" rel="noopener">https://linux.cn/</a></td>
</tr>
<tr>
<td>Linux公社</td>
<td><a href="https://www.linuxidc.com/" target="_blank" rel="noopener">https://www.linuxidc.com/</a></td>
</tr>
</tbody></table>
<h4 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>Mysql官网</td>
<td><a href="https://www.mysql.com/" target="_blank" rel="noopener">https://www.mysql.com/</a></td>
</tr>
<tr>
<td>SQL SERVER官网</td>
<td><a href="https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads" target="_blank" rel="noopener">https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads</a></td>
</tr>
<tr>
<td>ORICLE官网</td>
<td><a href="https://www.oracle.com/downloads/" target="_blank" rel="noopener">https://www.oracle.com/downloads/</a></td>
</tr>
<tr>
<td>DB2官网</td>
<td><a href="https://www.ibm.com/analytics/cn/zh/technology/db2/" target="_blank" rel="noopener">https://www.ibm.com/analytics/cn/zh/technology/db2/</a></td>
</tr>
<tr>
<td>TOAD官网</td>
<td><a href="https://www.toadworld.com/" target="_blank" rel="noopener">https://www.toadworld.com/</a></td>
</tr>
<tr>
<td>Navicat官网</td>
<td><a href="https://www.navicat.com.cn/" target="_blank" rel="noopener">https://www.navicat.com.cn/</a></td>
</tr>
<tr>
<td>DataGrip官网</td>
<td><a href="https://www.jetbrains.com/zh/datagrip/specials/datagrip/datagrip.html" target="_blank" rel="noopener">https://www.jetbrains.com/zh/datagrip/specials/datagrip/datagrip.html</a></td>
</tr>
<tr>
<td>Redis官网</td>
<td><a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></td>
</tr>
<tr>
<td>Redis中文网</td>
<td><a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a></td>
</tr>
<tr>
<td>MongoDB官网</td>
<td><a href="https://www.mongodb.com/Nginx" target="_blank" rel="noopener">https://www.mongodb.com/Nginx</a>  <a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a></td>
</tr>
<tr>
<td>UML工具列表</td>
<td><a href="http://www.umlchina.com/Tools/Newindex1.htm" target="_blank" rel="noopener">http://www.umlchina.com/Tools/Newindex1.htm</a></td>
</tr>
</tbody></table>
<h4 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>w3school官网</td>
<td><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a></td>
</tr>
<tr>
<td>jQuery官网</td>
<td><a href="https://jquery.com/" target="_blank" rel="noopener">https://jquery.com/</a></td>
</tr>
<tr>
<td>jQuery api   非官网:</td>
<td><a href="http://jquery.cuishifeng.cn/" target="_blank" rel="noopener">http://jquery.cuishifeng.cn/</a></td>
</tr>
<tr>
<td>easyui官网</td>
<td><a href="http://www.jeasyui.net/" target="_blank" rel="noopener">http://www.jeasyui.net/</a></td>
</tr>
<tr>
<td>Bootstrap官网</td>
<td><a href="https://www.bootcss.com/" target="_blank" rel="noopener">https://www.bootcss.com/</a></td>
</tr>
<tr>
<td>Amaze ~ 妹子 UI官网:</td>
<td><a href="http://amazeui.org/" target="_blank" rel="noopener">http://amazeui.org/</a></td>
</tr>
<tr>
<td>React</td>
<td><a href="https://react.docschina.org/" target="_blank" rel="noopener">https://react.docschina.org/</a></td>
</tr>
<tr>
<td>NOWA</td>
<td><a href="https://nowa-webpack.github.io/" target="_blank" rel="noopener">https://nowa-webpack.github.io/</a></td>
</tr>
<tr>
<td>Vue官网:</td>
<td><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></td>
</tr>
<tr>
<td>AngularJS中文网</td>
<td><a href="https://www.angularjs.net.cn/" target="_blank" rel="noopener">https://www.angularjs.net.cn/</a></td>
</tr>
<tr>
<td>开源图标库</td>
<td><a href="https://remixicon.com/" target="_blank" rel="noopener">https://remixicon.com/</a></td>
</tr>
<tr>
<td>开源图标库预览</td>
<td><a href="https://lvyueyang.gitee.io/remixicon/" target="_blank" rel="noopener">https://lvyueyang.gitee.io/remixicon/</a></td>
</tr>
</tbody></table>
<h4 id="远程或传输"><a href="#远程或传输" class="headerlink" title="远程或传输"></a>远程或传输</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>SecureCRT官网</td>
<td><a href="https://www.vandyke.com/products/securecrt/" target="_blank" rel="noopener">https://www.vandyke.com/products/securecrt/</a></td>
</tr>
<tr>
<td>XSHELL官网</td>
<td><a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">https://xshell.en.softonic.com/</a></td>
</tr>
<tr>
<td>WinSCP官网</td>
<td><a href="https://winscp.net/eng/docs/lang:chs" target="_blank" rel="noopener">https://winscp.net/eng/docs/lang:chs</a></td>
</tr>
<tr>
<td>File-Zilla官网</td>
<td><a href="https://filezilla-project.org/" target="_blank" rel="noopener">https://filezilla-project.org/</a></td>
</tr>
<tr>
<td>File-Zilla中文网</td>
<td><a href="https://www.filezilla.cn/" target="_blank" rel="noopener">https://www.filezilla.cn/</a></td>
</tr>
<tr>
<td>flashfxp官网</td>
<td><a href="https://www.flashfxp.com/" target="_blank" rel="noopener">https://www.flashfxp.com/</a></td>
</tr>
</tbody></table>
<h4 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>7z</td>
<td><a href="https://www.7-zip.org/" target="_blank" rel="noopener">https://www.7-zip.org/</a></td>
</tr>
<tr>
<td>WINRAR官网</td>
<td><a href="http://www.winrar.com.cn/" target="_blank" rel="noopener">http://www.winrar.com.cn/</a></td>
</tr>
<tr>
<td>在线工具箱</td>
<td><a href="https://tool.lu/" target="_blank" rel="noopener">https://tool.lu/</a></td>
</tr>
<tr>
<td>DeskTopShare</td>
<td><a href="http://www.yinrg.net/" target="_blank" rel="noopener">http://www.yinrg.net/</a></td>
</tr>
</tbody></table>
<h4 id="图片相关"><a href="#图片相关" class="headerlink" title="图片相关"></a>图片相关</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>图片压缩TinyPNG</td>
<td><a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></td>
</tr>
<tr>
<td>图片去背景</td>
<td><a href="http://www.aigei.com/bgremover/" target="_blank" rel="noopener">http://www.aigei.com/bgremover/</a></td>
</tr>
</tbody></table>
<h4 id="图床工具："><a href="#图床工具：" class="headerlink" title="图床工具："></a>图床工具：</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>PicGo</td>
<td><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></td>
</tr>
<tr>
<td>MPic-图床神器</td>
<td><a href="http://mpic.lzhaofu.cn" target="_blank" rel="noopener">http://mpic.lzhaofu.cn</a></td>
</tr>
<tr>
<td>PicPlus -手机图床</td>
<td><a href="https://www.coolapk.com/apk/name.gudong.pic" target="_blank" rel="noopener">https://www.coolapk.com/apk/name.gudong.pic</a></td>
</tr>
</tbody></table>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>open jdk相关</td>
<td><a href="https://www.iteye.com/blog/user/rednaxelafx" target="_blank" rel="noopener">https://www.iteye.com/blog/user/rednaxelafx</a></td>
</tr>
</tbody></table>
<h4 id="XML相关"><a href="#XML相关" class="headerlink" title="XML相关"></a>XML相关</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>Castor实现XML与Java的互转</td>
<td><a href="http://www.castor.org/" target="_blank" rel="noopener">http://www.castor.org/</a></td>
</tr>
</tbody></table>
<!--  JDK6JAXB2来实现对象与XML之间的映射  -->

<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>quartz</td>
<td><a href="https://www.w3cschool.cn/quartz_doc/" target="_blank" rel="noopener">https://www.w3cschool.cn/quartz_doc/</a></td>
</tr>
<tr>
<td>viewerjs，PDF/office在线预览</td>
<td><a href="https://fengyuanchen.github.io/viewerjs/" target="_blank" rel="noopener">https://fengyuanchen.github.io/viewerjs/</a></td>
</tr>
</tbody></table>
<h4 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h4><table>
<thead>
<tr>
<th>网站</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>mkdown在线编辑器</td>
<td><a href="http://www.mdeditor.com/" target="_blank" rel="noopener">http://www.mdeditor.com/</a></td>
</tr>
<tr>
<td>mkdown在线编辑器</td>
<td><a href="http://mahua.jser.me/" target="_blank" rel="noopener">http://mahua.jser.me/</a></td>
</tr>
<tr>
<td>mkdown在线编辑器</td>
<td><a href="https://tool.lu/markdown/" target="_blank" rel="noopener">https://tool.lu/markdown/</a></td>
</tr>
<tr>
<td>mkdown在线编辑器</td>
<td><a href="https://dillinger.io/" target="_blank" rel="noopener">https://dillinger.io/</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>收藏资源</category>
      </categories>
      <tags>
        <tag>开发常用</tag>
      </tags>
  </entry>
  <entry>
    <title>DB2-常见ERRORCODE</title>
    <url>/posts/9f154069.html</url>
    <content><![CDATA[<h2 id="DB2-常见ERRORCODE"><a href="#DB2-常见ERRORCODE" class="headerlink" title="DB2-常见ERRORCODE"></a>DB2-常见ERRORCODE</h2><p>对于常见的错误码，熟悉之后就可以快速定位问题，代码检查。</p>
<h4 id="1、sqlcode-407"><a href="#1、sqlcode-407" class="headerlink" title="1、sqlcode -407"></a>1、sqlcode -407</h4><p>不能把NULL值插入到定义为NOT NULL的列</p>
<pre class=" language-txt"><code class="language-txt">DB2 SQL Error: SQLCODE=-407, SQLSTATE=23502, SQLERRMC=TBSPACEID=2,
 TABLEID=19, COLNO=5, DRIVER=4.15.134</code></pre>
<p> 可以执行SQL，就可以快速定位哪个列出了问题。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>TABSCHEMA<span class="token punctuation">,</span> C<span class="token punctuation">.</span>TABNAME<span class="token punctuation">,</span> C<span class="token punctuation">.</span>COLNAME <span class="token keyword">FROM</span> SYSCAT<span class="token punctuation">.</span><span class="token keyword">TABLES</span> <span class="token keyword">AS</span> T<span class="token punctuation">,</span> SYSCAT<span class="token punctuation">.</span><span class="token keyword">COLUMNS</span> <span class="token keyword">AS</span> C <span class="token keyword">WHERE</span> T<span class="token punctuation">.</span>TBSPACEID <span class="token operator">=</span> <span class="token number">2</span>  <span class="token operator">AND</span> T<span class="token punctuation">.</span>TABLEID <span class="token operator">=</span><span class="token number">19</span> <span class="token operator">AND</span> C<span class="token punctuation">.</span>COLNO <span class="token operator">=</span> <span class="token number">5</span>  <span class="token operator">AND</span> C<span class="token punctuation">.</span>TABSCHEMA <span class="token operator">=</span> T<span class="token punctuation">.</span>TABSCHEMA <span class="token operator">AND</span> C<span class="token punctuation">.</span>TABNAME <span class="token operator">=</span> T<span class="token punctuation">.</span>TABNAME</code></pre>
<p>2、其他常见错误码</p>
<table>
<thead>
<tr>
<th>sqlcode</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-104</td>
<td>SQL中有非法字符，多半是标点符号问题</td>
</tr>
<tr>
<td>-205</td>
<td>指定表的列名无效</td>
</tr>
<tr>
<td>-206</td>
<td>查询的列不在FROM后的表里,即列和表里的列不对应</td>
</tr>
<tr>
<td>-208</td>
<td>不能order by 指定的列，列不在select列表中</td>
</tr>
<tr>
<td>-302 22003</td>
<td>输入变量值对列来说</td>
</tr>
<tr>
<td>-412</td>
<td>子查询的select列表遇到多个列</td>
</tr>
<tr>
<td>-415</td>
<td>使用UNION操作，指定的列类型不兼容</td>
</tr>
<tr>
<td>-918</td>
<td>连接丢失，SQL不能执行</td>
</tr>
</tbody></table>
<p>3、DB2错误码大全</p>
<p>可以下载<a href="https://github.com/small-rose/papers/blob/master/DB2%20SQLCODE%20%E5%A4%A7%E5%85%A8.pdf" target="_blank" rel="noopener">DB2 SQLCODE.pdf</a>查看更多错误码说明。</p>
]]></content>
      <categories>
        <category>DB2</category>
      </categories>
      <tags>
        <tag>DB2</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-模糊查询的N种玩法</title>
    <url>/posts/4c7816b.html</url>
    <content><![CDATA[<h2 id="Mybatis模糊查询的N种玩法"><a href="#Mybatis模糊查询的N种玩法" class="headerlink" title="Mybatis模糊查询的N种玩法"></a>Mybatis模糊查询的N种玩法</h2><blockquote>
<p>很多时候模糊查询在各个厂商数据库上基本可以通用。</p>
<p>原来通配符不止<code>like</code></p>
</blockquote>
<h3 id="一、模糊查询通配符"><a href="#一、模糊查询通配符" class="headerlink" title="一、模糊查询通配符"></a>一、模糊查询通配符</h3><p>模糊查询一般就是通过字面量和通配符对条件进行部分过滤。</p>
<p><strong>常见通配符：</strong></p>
<table>
<thead>
<tr>
<th align="center">通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td>百分号通配符，支持绝大部分数据库。<br/> % 的给定位置可以匹配0个字符、1个字符或多个字符。不能匹配null</td>
</tr>
<tr>
<td align="center">*</td>
<td>Access使用的通配符。</td>
</tr>
<tr>
<td align="center">_</td>
<td>下划线通配符，只能匹配单个字符。<br/>DB2不支持此用法。Access中则使用？代替_</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td>方括号通配符，指定一个字符集，必须匹配指定位置的一个字符。<br/>只有Access和SQL Server支持。如：<code>like &#39;[zx]%&#39;</code> 表示以z或者x开头的匹配条件。<br/>^可以作为通配符前缀脱字号进行否定。<br/><code>SQL Server</code>写法：<code>like &#39;[^zx]%&#39;</code>表示不以z或者x开头的匹配条件。<br/>Access的写法则是<code>like &#39;[!zx]%&#39;</code></td>
</tr>
</tbody></table>
<h3 id="二、Mybatis模糊查询N中玩法"><a href="#二、Mybatis模糊查询N中玩法" class="headerlink" title="二、Mybatis模糊查询N中玩法"></a>二、Mybatis模糊查询N中玩法</h3><blockquote>
<p>虽然是<code>SQL</code>模糊查询，使用<code>Mybatis</code>测试就暂归类到<code>Mybatis</code>下，但其实有不少查询基本上可以通用。</p>
<p>说明：下列写法是使用<code>DB2</code>数据库测试，其他数据库未一一验证，有条件可以自己尝试。</p>
</blockquote>
<p>比如，要查询日志表里<code>LOG_MSG</code>字段有<code>录入</code>字样的数据：</p>
<h4 id="1、手工拼接好“-”再传入参数"><a href="#1、手工拼接好“-”再传入参数" class="headerlink" title="1、手工拼接好“%”再传入参数"></a>1、手工拼接好“%”再传入参数</h4><pre class=" language-java"><code class="language-java">LogInfo log <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">setLogMsg</span><span class="token punctuation">(</span><span class="token string">"%录入%"</span><span class="token punctuation">)</span>；</code></pre>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectLogInfo<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logInfo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  SELECT * FROM DBCM.LOGINFO WHERE LOG_MSG LIKE #{logMsg}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>
<p>另外这里#{}和${}的是有区别的，我看有的博客里将模糊查询#{}和${}写法列为两种，此文并不分别列出：</p>
<p>（a）都支持基本类型和对象类型。</p>
<p>（b）#{}可以防止<code>sql</code>注入，可以自动给String类型加上<code>&#39; &#39;</code></p>
<p>（c）${} 原样输出，适合于 动态排序（动态字段）</p>
<h4 id="2、使用CONCAT连接函数"><a href="#2、使用CONCAT连接函数" class="headerlink" title="2、使用CONCAT连接函数"></a>2、使用<code>CONCAT</code>连接函数</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectLogInfo<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logInfo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  SELECT * FROM DBCM.LOGINFO WHERE LOG_MSG LIKE CONCAT('%', CONCAT(#{logMsg}),'%')
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>
<h4 id="3、使用Mybatis的bind标签"><a href="#3、使用Mybatis的bind标签" class="headerlink" title="3、使用Mybatis的bind标签"></a>3、使用Mybatis的<code>bind</code>标签</h4><p>在系统学习<code>Mybatis</code>的的动态<code>SQL</code>中，有个bind标签，支持参数绑定。</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectLogInfo<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logInfo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bind</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pattern<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>%<span class="token punctuation">'</span> + _parameter.getLogMsg() + <span class="token punctuation">'</span>%<span class="token punctuation">'</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
  SELECT * FROM DBCM.LOGINFO WHERE LOG_MSG LIKE #{pattern}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>
<h4 id="4、使用LOCATE函数"><a href="#4、使用LOCATE函数" class="headerlink" title="4、使用LOCATE函数"></a>4、使用<code>LOCATE</code>函数</h4><blockquote>
<p>LOCATE是字符串查询函数。这个其实和<code>Mybatis</code>没什么关系了，只要数据库支持该函数，则可以使用，下同。</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> DBCM<span class="token punctuation">.</span>LOGINFO <span class="token keyword">WHERE</span>  LOCATE<span class="token punctuation">(</span><span class="token string">'录入'</span><span class="token punctuation">,</span> LOG_MSG<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span></code></pre>
<h4 id="5、使用POSITION函数"><a href="#5、使用POSITION函数" class="headerlink" title="5、使用POSITION函数"></a>5、使用<code>POSITION</code>函数</h4><p>position功能跟locate功能相似。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> DBCM<span class="token punctuation">.</span>LOGINFO <span class="token keyword">WHERE</span>  POSITION<span class="token punctuation">(</span><span class="token string">'录入'</span> <span class="token operator">IN</span> LOG_MSG<span class="token punctuation">)</span></code></pre>
<h4 id="6、使用INSTR函数"><a href="#6、使用INSTR函数" class="headerlink" title="6、使用INSTR函数"></a>6、使用<code>INSTR</code>函数</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> DBCM<span class="token punctuation">.</span>LOGINFO <span class="token keyword">WHERE</span>  INSTR<span class="token punctuation">(</span>LOG_MSG<span class="token punctuation">,</span><span class="token string">'录入'</span><span class="token punctuation">)</span></code></pre>
<h4 id="7、使用FIND-IN-SET函数"><a href="#7、使用FIND-IN-SET函数" class="headerlink" title="7、使用FIND_IN_SET函数"></a>7、使用<code>FIND_IN_SET</code>函数</h4><p><code>FIND_IN_SET</code>是<code>Mysql</code>里的函数。语法：</p>
<pre class=" language-sql"><code class="language-sql">FIND_IN_SET<span class="token punctuation">(</span>str<span class="token punctuation">,</span>strlist<span class="token punctuation">)</span></code></pre>
<p>假如字符串<code>str</code> 在由N个子链组成的字符串列表<code>strlist</code> 中，则返回值的范围在 1 到 N 之间。</p>
<p>字符串列表<code>strlist</code> 就是一个由一些被<code>&quot;,&quot;</code>符号分开的自链组成的字符串。</p>
<p>如果第一个参数是一个常量字符串，而第二个是搜索列，则FIND_IN_SET() 函数被优化，使用比特计算。</p>
<p>如果<code>str</code>不在<code>strlist</code> 或<code>strlist</code>为空字符串，则返回值为 0 。</p>
<p>如任意一个参数为NULL，则返回值为 NULL。这个函数在第一个参数包含一个逗号<code>&quot;,&quot;</code>时将无法正常运行。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> FIND_IN_SET<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'a,b,c,d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：2</span></code></pre>
<p>使用该种查询时，条件比较严苛：<code>Mysql</code>数据库；匹配列内容以<code>“,”</code>分割。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--使用Mysql测试</span>
<span class="token keyword">select</span>  <span class="token operator">*</span> <span class="token keyword">from</span>  DBCM<span class="token punctuation">.</span>LOGINFO <span class="token keyword">where</span> FIND_IN_SET<span class="token punctuation">(</span><span class="token string">'录入'</span><span class="token punctuation">,</span>LOG_MSG<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SQL</tag>
        <tag>模糊查询</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-常用命令与授权</title>
    <url>/posts/523aed6c.html</url>
    <content><![CDATA[<h2 id="Mysql-常用命令"><a href="#Mysql-常用命令" class="headerlink" title="Mysql 常用命令"></a>Mysql 常用命令</h2><blockquote>
<p>虽然现在已经有很多界面化的连接工具可以直接鼠标操作。但是若环境不允许远程连接怎么呢？所以常用命令还是有用武之地的。整理一下。</p>
</blockquote>
<h3 id="一、连接命令"><a href="#一、连接命令" class="headerlink" title="一、连接命令"></a>一、连接命令</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## mysql终端连接</span>
mysql  <span class="token punctuation">[</span> -h  <span class="token operator">&lt;</span>hostname <span class="token operator">|</span> ip<span class="token operator">></span> <span class="token punctuation">]</span> -u <span class="token operator">&lt;</span>username<span class="token operator">></span> <span class="token punctuation">[</span>-P <span class="token operator">&lt;</span>port<span class="token operator">></span><span class="token punctuation">]</span> -p <span class="token punctuation">[</span><span class="token operator">&lt;</span>userpass<span class="token operator">></span><span class="token punctuation">]</span></code></pre>
<p>参数含义：</p>
<p><strong>-h:</strong> 主机名，表示连接的目标数据库主机名或者IP地址。</p>
<p><strong>-u:</strong> 用户名，表示连接的目标数据库的用户名。</p>
<p><strong>-P:</strong> 端口，表示连接的目标数据库的端口，不写默认是3306，非默认须确定端口号。</p>
<p><strong>-p:</strong> 表示连接的目标数据库的密码，-p后面可以直接输入密码，也可以不写执行命令的时候输入密码，下文同理。</p>
<p>关于 <code>-u</code>和<code>username</code>是否一定要连在一起，并没有找到答案。</p>
<h3 id="二、基础查询命令"><a href="#二、基础查询命令" class="headerlink" title="二、基础查询命令"></a>二、基础查询命令</h3><p>执行登录之后使用。</p>
<pre class=" language-mysql"><code class="language-mysql">-- 列出全部已有数据库
show databases;

-- 创建新数据库
create database <database_name>; 

-- 创建指定数据库
drop database <database_name>;

-- 打开/使用指定数据库
use <database_name>;

-- 列出打开的数据库所有的表名
show tables;

-- 查看数据库指定的表结构
desc <table_name>;

-- 删除表
drop table <table_name>;</code></pre>
<h3 id="三、数据库备份"><a href="#三、数据库备份" class="headerlink" title="三、数据库备份"></a>三、数据库备份</h3><h4 id="1、直接备份库"><a href="#1、直接备份库" class="headerlink" title="1、直接备份库"></a>1、直接备份库</h4><p>（A）备份一个库</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 备份指定主机某个库</span>
mysqldump -h host_name -P port -u user_name -p user_pass –database database_name <span class="token operator">></span> bak_file_name.sql

<span class="token comment" spellcheck="true">## 备份本地数据库，执行时输密码</span>
mysqldump -u user_name –p –database database_name  <span class="token operator">></span>  bak_file_name.suffix</code></pre>
<p>实例如：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 备份192.168.66.82上的数据库DBCM</span>
mysqldump -h 192.168.66.82 -u root –p123456  –database dbcm  <span class="token operator">></span>  dbcm_20200617.sql

<span class="token comment" spellcheck="true">## 备份数据库DBCM，执行时输密码</span>
mysqldump -u root –p  –database dbcm  <span class="token operator">></span>  dbcm_20200617.sql</code></pre>
<p>（B）备份多个库:</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 备份指定主机里的多个库</span>
mysqldump -h <span class="token function">hostname</span> -u username -p user_pass –databases db_name1 db_name2 db_name3 <span class="token operator">></span> more_dbname_file.suffix</code></pre>
<p>如备份系统自带库：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 备份192.168.66.82上的数据库自带系统库</span>
mysqldump -h 192.168.66.82 -u root –p123456  –databases information_schema mysql <span class="token operator">></span> sys_bak.sql</code></pre>
<p>说明：后续列举就不再分别列远程与本地了，区别只是<code>-h host_name</code>及<code>-P host_port</code>，统一用本地列举。</p>
<h4 id="2、直接备份库的表"><a href="#2、直接备份库的表" class="headerlink" title="2、直接备份库的表"></a>2、直接备份库的表</h4><p>备份指定库的指定表 </p>
<pre class=" language-bash"><code class="language-bash">mysqldump -u user_name –p –database database_name  table_name1  table_name2 <span class="token operator">></span>  bak_fileName.suffix</code></pre>
<p>例如：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">##备份数据库DBCM里的loginfo表</span>
mysqldump -u root –p –database dbcm loginfo  <span class="token operator">></span>  dbcm_loginfo_20200617.sql
<span class="token comment" spellcheck="true">## 多张表</span>
mysqldump -u root –p –database dbcm loginfo user <span class="token operator">></span>  dbcm_log_user_20200617.sql</code></pre>
<h4 id="3、压缩备份"><a href="#3、压缩备份" class="headerlink" title="3、压缩备份"></a>3、压缩备份</h4><pre class=" language-bash"><code class="language-bash">mysqldump -h host_name -u user_name -p user_pass -database db_name <span class="token operator">|</span> <span class="token function">gzip</span> <span class="token operator">></span> backup_file.sql.gz</code></pre>
<h4 id="4、只备份数据库表结构"><a href="#4、只备份数据库表结构" class="headerlink" title="4、只备份数据库表结构"></a>4、只备份数据库表结构</h4><pre class=" language-bash"><code class="language-bash">mysqldump  –no-data -u user_name -p user_pass –databases db_name1 db_name2 db_name3 <span class="token operator">></span> db_table_bak.sql</code></pre>
<h4 id="5、备份所有数据库"><a href="#5、备份所有数据库" class="headerlink" title="5、备份所有数据库"></a>5、备份所有数据库</h4><pre class=" language-bash"><code class="language-bash">mysqldump –all-databases -u user_name -p user_pass <span class="token operator">></span> all_db.sql</code></pre>
<h4 id="6、带删除的备份"><a href="#6、带删除的备份" class="headerlink" title="6、带删除的备份"></a>6、带删除的备份</h4><p>备份<code>MySQL</code>数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库</p>
<p>通俗的说就是<code>CREATE TABLE table_name</code>之前有<code>DROP TABLE IF EXISTS table_name</code>的动作。mysql默认备份就支持。</p>
<pre class=" language-bash"><code class="language-bash">mysqldump --add-drop-table -u username -p password -database databasename <span class="token operator">></span> backup_file.sql</code></pre>
<h4 id="7、binlog增量备份"><a href="#7、binlog增量备份" class="headerlink" title="7、binlog增量备份"></a>7、binlog增量备份</h4><p>增量备份是使用<code>mysql</code>的<code>binlog</code>日志作为记录新增的变化。</p>
<p><code>--master-data</code>：</p>
<p>在<code>mysqldump</code>命令中使用<code>--master-data=2</code>，会记录<code>binlog</code>文件和<code>position</code>的信息。</p>
<p><code>--single-transaction</code>：</p>
<p><code>--single-transaction</code>会将隔离级别设置成<code>repeatable-commited</code></p>
<p>首先进行全备</p>
<pre><code>mysqldump -u username -p password --single-transaction --master-data=2 db_name &gt; backup_all_file.sql</code></pre><p>备份文件中会有</p>
<p><code>-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;bin-log.000002&#39;, MASTER_LOG_POS=xxx;</code></p>
<p>是指备份后所有的更改将会保存到新文件bin-log.000002二进制文件中。</p>
<h3 id="四、数据库还原"><a href="#四、数据库还原" class="headerlink" title="四、数据库还原"></a>四、数据库还原</h3><h4 id="1、直接还原"><a href="#1、直接还原" class="headerlink" title="1、直接还原"></a>1、直接还原</h4><pre class=" language-bash"><code class="language-bash">mysql -h <span class="token function">hostname</span> -u user_name -p user_pass database_name <span class="token operator">&lt;</span> backup_file.sql</code></pre>
<h4 id="2、压缩还原"><a href="#2、压缩还原" class="headerlink" title="2、压缩还原"></a>2、压缩还原</h4><pre class=" language-bash"><code class="language-bash">gunzip <span class="token operator">&lt;</span> backup_file.sql.gz <span class="token operator">|</span> mysql -u user_pass -p password database_name</code></pre>
<h4 id="3、source导入"><a href="#3、source导入" class="headerlink" title="3、source导入"></a>3、source导入</h4><p>使用source命令，需要使用命令登录mysql，用use进入到某个数据库后执行</p>
<pre class=" language-mysql"><code class="language-mysql">source d:\backup_file.sql</code></pre>
<h4 id="4、数据库转移"><a href="#4、数据库转移" class="headerlink" title="4、数据库转移"></a>4、数据库转移</h4><pre class=" language-bash"><code class="language-bash">mysqldump -u user_name -p user_pass db_name <span class="token operator">|</span> mysql –host<span class="token operator">=</span>*.*.*.* -C db_name</code></pre>
<h4 id="5、增量还原-恢复"><a href="#5、增量还原-恢复" class="headerlink" title="5、增量还原/恢复"></a>5、增量还原/恢复</h4><p>首先导入全备数据，source亦可。</p>
<pre class=" language-bash"><code class="language-bash">mysql -h host_name -u user_name -p user_pass  <span class="token operator">&lt;</span> backup_all_file.sql</code></pre>
<p>然后，恢复bin-log.000002</p>
<pre class=" language-bash"><code class="language-bash">mysqlbinlog bin-log.000002 <span class="token operator">|</span> mysql -h host_name -u user_name -p user_pass</code></pre>
<p>如果还有后续新增同理恢复。</p>
<p>恢复部分，恢复到某个操作的前面一个position点。</p>
<p>控制<code>binlog</code>的区间的参数有：</p>
<pre class=" language-mysql"><code class="language-mysql">--start-position  # 开始点 
--stop-position # 结束点
--start-date  # 开始时间 
--stop-date  # 结束时间</code></pre>
<p>找到需要操的恢复点，后进行恢复</p>
<pre class=" language-bash"><code class="language-bash">mysqlbinlog mysql-bin.000003 --stop-position<span class="token operator">=</span>308 <span class="token operator">|</span>mysql -h host_name -u user_name -p user_pass </code></pre>
<p>找到需要的恢复时间区间，进行恢复指定时间区间数据</p>
<pre class=" language-bash"><code class="language-bash">mysqlbinlog mysql-bin.000003 --start-datetime<span class="token operator">=</span><span class="token string">'2019-12-01 00:00:00'</span> --stop-datetime<span class="token operator">=</span><span class="token string">'2019-12-31 23:59:59'</span> <span class="token operator">|</span>mysql -h host_name -u user_name -p user_pass</code></pre>
<p>查看<code>binlog</code>内容，可以将<code>binlog</code>内容写入到临时文件查看：</p>
<pre><code>mysqlbinlog --no-defaults --database=db   --base64-output=decode-rows -v --start-datetime=&#39;2019-12-01 00:00:00&#39; --stop-datetime=&#39;2019-12-31 23:59:59&#39;  mysql-bin.000003 &gt;  binlog003.sql</code></pre><h3 id="五、授权管理"><a href="#五、授权管理" class="headerlink" title="五、授权管理"></a>五、授权管理</h3><p>经常见到或自己设置使用的授权长这样：</p>
<pre class=" language-mysql"><code class="language-mysql">##给指定root用户在本机登录连接及操作所有Schema的所有表的权限
grant all privileges on *.* to 'root'@'localhost' identified by 'user_pass';
## 刷新权限设置
flush privileges;</code></pre>
<p>实际使用的时候可能会进行一些更细节的授权限制，那么怎么办呢？</p>
<h4 id="1、查看用户权限"><a href="#1、查看用户权限" class="headerlink" title="1、查看用户权限"></a>1、查看用户权限</h4><pre class=" language-mysql"><code class="language-mysql">##查看当前登录用户权限
show grants;
## 查看其他 MySQL 用户权限,注意user_name和localhost要加引号
show grants for user_name@localhost;</code></pre>
<h4 id="2、基本授权命令"><a href="#2、基本授权命令" class="headerlink" title="2、基本授权命令"></a>2、基本授权命令</h4><pre class=" language-mysql"><code class="language-mysql">grant <privileges>  on schema.table to user_name@host_name identified by user_pass</code></pre>
<p><strong>privileges</strong> ：包括常见的查询、插入、更新、删除操作外，还包括创建表、索引、视图、存储过程、函数等权限。使用时关键字 “privileges” 可以省略。</p>
<p><strong>schema.table</strong> ：可以细节到指定库指定表，<code>*.*</code> 表示所有的库下所有的表。</p>
<p><strong>user_name@host_name identified by user_pass</strong>：表示允许哪个用户使用指定密码从哪个主机登录；常见的写法如下：（<code>identified by user_pass</code>实际使用时记得加上）</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>‘root’@’localhost’</td>
<td>允许root用户从本机连接登录</td>
</tr>
<tr>
<td>‘root’@’%’</td>
<td>允许root用户从任意机器连接登录</td>
</tr>
<tr>
<td>‘root’@’192.168.0.221’</td>
<td>允许root用户从<code>IP</code>为<code>192.168.0.221</code>的机器连接登录</td>
</tr>
<tr>
<td>‘root’@’192.168.0.%’</td>
<td>允许root用户从<code>IP</code>网段为<code>192.168.0.*</code>的机器连接登录</td>
</tr>
</tbody></table>
<blockquote>
<p>不写@选项时，效果与加@’%’是一样。</p>
<p>‘%’从名义上包括任何主机，据说有些版本’%’不包括<code>localhost</code>，则需要单独对<code>@&#39;localhost&#39;</code>进行赋值。</p>
</blockquote>
<p>（1）给普通用户授权</p>
<p>普通用户一般可以授权基本数据的查询、写入、修改、删除操作，修改、删除视实际要求情况授权。</p>
<p><code>bus_dbname</code> ：表示业务数据库。<code>common_user</code>：普通用户连接账户。</p>
<pre class=" language-mysql"><code class="language-mysql">## 分别授权
grant select on bus_dbname.* to common_user@'%'
grant insert on bus_dbname.* to common_user@'%'
grant update on bus_dbname.* to common_user@'%'
grant delete on bus_dbname.* to common_user@'%'

## 合并操作，使用英文逗号分隔
grant select, insert, update, delete on bus_dbname.* to common_user@'%'</code></pre>
<p>（2）给高权用户授权</p>
<p>如开发人员，<code>DBA</code>等，允许建表结构，删表，改表结构，改外键，建视图，临时表，索引，存储过程等。</p>
<p><code>bus_dbname</code> ：表示业务数据库。<code>dev_userr</code>：开发或管理用户连接账户。</p>
<pre class=" language-mysql"><code class="language-mysql">## 授权dev_user用户 在MySQL的数据库bus_dbname中建表操作 
grant create on bus_dbname.* to dev_user@'192.168.0.%';
## 授权 改表
grant alter on bus_dbname.* to dev_user@'192.168.0.%';
## 授权 删表
grant drop on bus_dbname.* to dev_user@'192.168.0.%';

## 授权 外键权限。
grant references on bus_dbname.* to dev_user@'192.168.0.%';

## 授权 临时表权限。
grant create temporary tables on bus_dbname.* to dev_user@'192.168.0.%';
## 授权 索引权限。
grant index on bus_dbname.* to dev_user@'192.168.0.%';

## 授权 视图创建。
grant create view on bus_dbname.* to dev_user@'192.168.0.%';
## 授权 视图查看代码。
grant show view on bus_dbname.* to dev_user@'192.168.0.%';

##给普通 DBA/dev_user授权
grant all privileges on bus_dbname.* to dev_user@'localhost'
##可以省略privileges
grant all on bus_dbname.* to dev_user@'localhost' 

##其实是给dev_user授权所有库和所以表，一般可以给DBA
grant all on *.* to dev_user@'localhost'</code></pre>
<p>关于存储过程和函数的使用关键字：<code>create routine</code>。</p>
<p>授权<code>create  routine</code>表示可以创建<code>procedure</code> 和<code>function</code> 。</p>
<p>如果用户创建了<code>procedure</code>或<code>function</code>那么<code>mysql</code>会自动赋予该用户对<code>procedure</code> 或 <code>function</code> 的<code>alter routine</code>和<code>execute</code> 权限。</p>
<pre class=" language-mysql"><code class="language-mysql">grant create routine on bus_dbname.* to dev_user@'192.168.0.%'; </code></pre>
<p>创建存储过程：</p>
<pre class=" language-mysql"><code class="language-mysql">delimiter $
create procedure sp_hello_mysql()
begin
    select 'hello mysql';
end 
$</code></pre>
<p>再去查询授权</p>
<pre class=" language-mysql"><code class="language-mysql">show grants;</code></pre>
<p>就可以看到用户<code>alter routine</code>和<code>execute</code> 权限。</p>
<p>（3）授权分层</p>
<p><code>grant</code>的授权可以授权给整个<code>mysql</code>库，也可以指定某个库，指定某个库的某个表，指定表的列，指定视图、指定函数、指定存储过程等</p>
<pre class=" language-mysql"><code class="language-mysql">## 授权 MySQL中的所有数据库下的所有表，也就是完整的全部权限
grant all on *.* to 'root'@'localhost'; 

## 授权user_name 给某个指定的数据库的查询权限
grant select  on bus_dbname.* to user_name@localhost; 

## 授权 给某个指定的数据库的指定表select, insert, update, delete权限
grant select, insert, update, delete on bus_dbname.table_name to user_name@localhost; 

## 授权 给某个指定的数据库的指定表查询指定列的权限
grant select(id, name, rank) on bus_dbname.table_name to user_name@localhost;

## 授权 指定的存储过程执行权限
grant execute on procedure bus_dbname.pr_procname to user_name@localhost;
## 授权 指定的函数执行权限
grant execute on function bus_dbname.fn_funcname to user_name@localhost;</code></pre>
<h4 id="3、撤销授权命令"><a href="#3、撤销授权命令" class="headerlink" title="3、撤销授权命令"></a>3、撤销授权命令</h4><p>撤销授权使用<code>revoke</code>命令。</p>
<p><code>revoke</code> 和<code>grant</code> 的语法相似，需要把关键字 <code>to</code> 换成 <code>from</code>,命令格式：</p>
<pre class=" language-mysql"><code class="language-mysql">## 授权dev_user用户在本地登录后的 操作所有库所有表的所有权限
grant all on *.* to dev_user@localhost ;
## 撤销dev_user用户在本地登录后的 操作所有库所有表的所有权限
revoke all on *.* from dev_user@localhost;</code></pre>
<h4 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h4><p>（1）执行<code>grant</code>,<code>revoke</code> 操作权限后，相关用户，重新连接<code>MySQL</code> 数据库后，权限才能生效。</p>
<p>（2）用户被授予了某个权限，那么默认情况下，该用户是不能把这个权限授予给其他人的.。</p>
<p>可以使用<code>WITH GRANT OPTION</code>这个子句来让该用户可以将权限再授予给其他人。</p>
<p><code>WITH GRANT OPTION</code>：表示允许权限传递。用于对象授权。区别于 用于系统权限授权的<code>with admin option</code>。</p>
<p>还可以通过直接授予GRANT OPTION权限来达到这个效果。</p>
<pre class=" language-mysql"><code class="language-mysql">##使用 WITH GRANT OPTION允许权限传递
grant select, insert, update, delete on bus_dbname.table_name to user_name@localhost WITH  GRANT OPTION; 

## 直接授权GRANT OPTION
grant select,grant option on bus_dbname.table_name to user_name@localhost ; </code></pre>
<p>（3）权限传递<code>WITH  GRANT OPTION</code>用户的权限被收回时，其他被传递的相同权限自动收回。</p>
<p>（4）权限信息用user、db、host、<code>tables_priv</code>和<code>columns_priv</code>表被存储在<code>mysql</code>数据库中</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-Access denied for</title>
    <url>/posts/7c170969.html</url>
    <content><![CDATA[<h2 id="Linux下MySQL的Access-denied-for-user"><a href="#Linux下MySQL的Access-denied-for-user" class="headerlink" title="Linux下MySQL的Access denied for user"></a>Linux下MySQL的Access denied for user</h2><blockquote>
<p>使用环境：Centos7.4 ，Mysql5.7</p>
</blockquote>
<h3 id="1、root不能在版本地登录"><a href="#1、root不能在版本地登录" class="headerlink" title="1、root不能在版本地登录"></a>1、root不能在版本地登录</h3><p><strong>问题描述：</strong></p>
<p>在linux命令行用mysql -uroot -ppasswaord 登录却报了这么个错：</p>
<p>ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)</p>
<p><strong>解决方法：</strong></p>
<p>（1）首先要确定登录密码正确，如果密码不对也会出现这个错误。（可以看应用里连接配置确认）</p>
<p>（2）如果密码正确之后还是不能连接：</p>
<p>​    （a）编辑<code>/etc/my.cnf</code>的mysqld下 添加<code>skip-grant-tables</code></p>
<p>​    （b）重启MySQL服务，根据版本选择。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld restart
systemctl restart mysqld.service</code></pre>
<p>​    （c）直接mysql -uroot 登录</p>
<p>​    （d）修改MySQL密码</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 5.7之前</span>
<span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> password<span class="token operator">=</span>password<span class="token punctuation">(</span><span class="token string">'your_password'</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'root'</span> <span class="token operator">and</span> host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true"># 5.7之后</span>
<span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> authentication_string<span class="token operator">=</span>password<span class="token punctuation">(</span><span class="token string">'your_password'</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'root'</span> <span class="token operator">and</span> host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">;</span>

flush <span class="token keyword">privileges</span><span class="token punctuation">;</span></code></pre>
<p>​    （e）注释掉<code>skip-grant-table</code>、重启MySQL服务。再次登录验证即可。</p>
<h3 id="2、用户不能在非本地登录"><a href="#2、用户不能在非本地登录" class="headerlink" title="2、用户不能在非本地登录"></a>2、用户不能在非本地登录</h3><p><strong>问题描述：</strong></p>
<p>一般出现在客户端连接mysql服务的时候：</p>
<p>mysql access denied for user root@ip useing password</p>
<p><strong>解决方法：</strong></p>
<p>（1）首先确保密码正确</p>
<p>（2）如果密码正确还是不能连接，说明缺少授权。</p>
<p>​    （a）mysql -uroot 在服务端登录</p>
<p>​    （b）查询用户登录的授权状态</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">use</span> mysql<span class="token punctuation">;</span>
<span class="token keyword">select</span> host<span class="token punctuation">,</span><span class="token keyword">user</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span></code></pre>
<p>​    （c）确认用户在指定IP没有授权，就授权</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 适用于开发账户，授权root在任意主机登录，拥有全部schema的全部表的全部权限</span>
<span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'root'</span>@'<span class="token operator">%</span><span class="token string">' IDENTIFIED BY '</span>your_password' <span class="token keyword">WITH</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">-- 刷新权限，刷新之后客户端需要重新连接方可生效</span>
FLUSH   <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span></code></pre>
<p>​    （d）客户端重新连接即可。</p>
<p><font color="red" >特别说明：</font>如果对权限管理比较严格，可以按IP授权，也可以按网段授权，可以授权不同的权限级别，可以授权不同操作权限等相关操作，可以参考关于Mysql授权的的内容在《Mysql常用命令》中的授权部分。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建静态博客（一）——基础搭建</title>
    <url>/posts/9f117b.html</url>
    <content><![CDATA[<p> 原来使用springboot自己捣鼓的博客，总是不够满意，就想着实在不行搞个静态博客，比较再三选择hexo,就用Hexo再捣鼓一个静态博客，折腾了几天也算有成果了。</p>
<a id="more"></a>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>本文环境如下</p>
<pre><code>$ hexo -v
hexo：4.2.1
hexo-cli：3.1.0
os：Windows_NT 10.0.18362 win32 x64
http_parser：2.8.0
node：8.12.0
v8：6.2.414.66
uv：1.19.2
zlib：1.2.11
ares：1.10.1-DEV
modules：57
nghttp2：1.32.0
napi： 3
openssl：1.0.2p
icu：60.1
unicode：10.0
cldr：32.0
tz：2017c</code></pre><h4 id="1-安装git环境"><a href="#1-安装git环境" class="headerlink" title="1.安装git环境"></a>1.安装git环境</h4><p>安装git for windows（或者其它git客户端）[git下载]（<a href="https://git-scm.com/downloads）" target="_blank" rel="noopener">https://git-scm.com/downloads）</a><br>验证git安装命令(可以用Windows的cmd窗口或鼠标右键菜单的git bash 窗口)</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> --version</code></pre>
<h4 id="2-安装Node"><a href="#2-安装Node" class="headerlink" title="2.安装Node"></a>2.安装Node</h4><p>安装Node<a href="http://nodejs.cn/" target="_blank" rel="noopener">Node下载</a><br>验证node安装命令 (可以用Windows的cmd窗口或鼠标右键菜单的git bash 窗口)</p>
<pre class=" language-bash"><code class="language-bash">node --version</code></pre>
<h4 id="3-github账号"><a href="#3-github账号" class="headerlink" title="3.github账号"></a>3.github账号</h4><p>如果没有注册一个：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>主要是方便从git上下载各种东东。</p>
<h3 id="安装hexo及初始化"><a href="#安装hexo及初始化" class="headerlink" title="安装hexo及初始化"></a>安装hexo及初始化</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> D:hexo/    //换成你的目录
$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli   //安装hexo脚手架
$ hexo init     //Hexo 初始化 会自动在当前文件夹下下载搭建网站所需的所有文件
$ <span class="token function">npm</span> <span class="token function">install</span>   //安装依赖包命令</code></pre>
<h3 id="编译生成静态页面"><a href="#编译生成静态页面" class="headerlink" title="编译生成静态页面"></a>编译生成静态页面</h3><pre class=" language-bash"><code class="language-bash">hexo g</code></pre>
<h3 id="启动服务预览"><a href="#启动服务预览" class="headerlink" title="启动服务预览"></a>启动服务预览</h3><pre class=" language-bash"><code class="language-bash">hexo s</code></pre>
<p>打开浏览器访问：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>如果正常出现页面说明搭建成功。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre class=" language-bash"><code class="language-bash">hexo clean      //清空public文件夹内容
hexo g 或  hexo generate   //在hexo站点根目录下生成public文件夹，相关静态网页文件
hexo s 或  hexo server     //启动服务预览 http://localhost:4000
hexo d 或  hexo deploy     //部署站点，在本地生成.deploy_git文件夹，并将编译后的文件上传至 Git远程仓库，如github或自己搭建的远程服务器。</code></pre>
<p>也可以连起来使用：<font face="console" color="red" bgcolor='#fff'><code>hexo clean &amp; hexo g &amp; hexo s &amp;  hexo d</code></font></p>
<p>如有问题请参考本系列：Hexo搭建静态博客（五）——踩坑问题</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>DB2常用命令</title>
    <url>/posts/7f06fe17.html</url>
    <content><![CDATA[<h2 id="DB2-常用命令"><a href="#DB2-常用命令" class="headerlink" title="DB2 常用命令"></a>DB2 常用命令</h2><h3 id="1、启停命令"><a href="#1、启停命令" class="headerlink" title="1、启停命令"></a>1、启停命令</h3><p>先切换用户</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">su</span> - db2inst1  //切换用户</code></pre>
<p>再操作启停连接</p>
<pre class=" language-bash"><code class="language-bash">db2start  //启动数据库
db2stop   //停止数据库
db2stop force   //强制停止数据库</code></pre>
<p>连接相关操作</p>
<pre class=" language-bash"><code class="language-bash">db2 connect to  <span class="token operator">&lt;</span>databaseName <span class="token operator">></span>  //表示默认使用db2inst1连接db2的<span class="token operator">&lt;</span>dbName<span class="token operator">></span>

db2 disconnect  <span class="token operator">&lt;</span>databaseName <span class="token operator">></span>  //断开与<span class="token operator">&lt;</span>dbName<span class="token operator">></span>的连接

db2 connect to <span class="token operator">&lt;</span>databaseName<span class="token operator">></span> user <span class="token operator">&lt;</span>userName<span class="token operator">></span> using <span class="token operator">&lt;</span>password<span class="token operator">></span> //使用本地别名连接远端数据库</code></pre>
<h3 id="2、建库命令"><a href="#2、建库命令" class="headerlink" title="2、建库命令"></a>2、建库命令</h3><pre class=" language-bash"><code class="language-bash">db2 create db <span class="token operator">&lt;</span>databaseName <span class="token operator">></span>     //创建数据库

db2 create db <span class="token operator">&lt;</span>databaseName<span class="token operator">></span> using codeset utf-8 territory CN  //创建数据库使用utf-8编码

db2 drop db <span class="token operator">&lt;</span>databaseName <span class="token operator">></span>  //创建数据库使用utf-8编码</code></pre>
<h3 id="3、查看信息"><a href="#3、查看信息" class="headerlink" title="3、查看信息"></a>3、查看信息</h3><pre class=" language-bash"><code class="language-bash">db2 get db cfg  <span class="token comment" spellcheck="true">## 查看数据库配置</span>
db2 get db cfg <span class="token keyword">for</span> DBCM  <span class="token comment" spellcheck="true">## 查看指定数据库的配置</span>

db2 list db directory   <span class="token comment" spellcheck="true">## 列出所有数据库</span>
db2 list active databases <span class="token comment" spellcheck="true">## 列出所有活动的数据库</span>

db2 list tables <span class="token keyword">for</span> all <span class="token comment" spellcheck="true">## 列出当前数据库下所有的表</span>
db2 list tables <span class="token keyword">for</span> schema dbcm <span class="token comment" spellcheck="true">## 列出当前数据库中schema为dbcm的表</span>

db2 list tablespaces show detail <span class="token comment" spellcheck="true">## 显示数据库空间使用情况</span>
db2 list tablespaces  <span class="token comment" spellcheck="true">## 列出表空间</span>

db2 list tables    <span class="token comment" spellcheck="true">## 查看数据库中所有表结构</span>
db2 list tables <span class="token keyword">for</span> system   <span class="token comment" spellcheck="true">## 列出所有系统表</span>

db2 describe table <span class="token operator">&lt;</span>tableName<span class="token operator">></span>  <span class="token comment" spellcheck="true">## 查看表结构</span></code></pre>
<h3 id="4、查询操作"><a href="#4、查询操作" class="headerlink" title="4、查询操作"></a>4、查询操作</h3><p><code>DB2</code>命令查询：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token number">db2</span> <span class="token string">"select ... "</span>
db2level</code></pre>
<p><code>SQL</code>系统信息查询：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--查找所有表 的中文名里包含'%日志%'的表，前提建表时有中文注释</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> SYSCAT<span class="token punctuation">.</span><span class="token keyword">TABLES</span> <span class="token keyword">where</span> REMARKS <span class="token operator">like</span> <span class="token string">'%日志%'</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">--查询现有的Schema</span>
<span class="token keyword">select</span> SCHEMANAME<span class="token punctuation">,</span>owner<span class="token punctuation">,</span>CREATE_TIME <span class="token keyword">from</span> syscat<span class="token punctuation">.</span>schemata

<span class="token variable">@desc</span> LOGINFO  <span class="token comment" spellcheck="true">--查询LOGINFO表的表结构，DBVisualizer 中可以界面操作。</span>

<span class="token comment" spellcheck="true">--查询DB2版本</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> sysibm<span class="token punctuation">.</span>sysvERSIONS </code></pre>
<p>查询前100条数据：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--查找前100条日志数据</span>
<span class="token keyword">Select</span> <span class="token operator">*</span> <span class="token keyword">from</span> DBCM<span class="token punctuation">.</span>LOGINFO  <span class="token keyword">fetch</span> <span class="token keyword">first</span> <span class="token number">100</span> <span class="token keyword">rows</span> only<span class="token punctuation">;</span></code></pre>
<p>分页查询：</p>
<pre class=" language-sql"><code class="language-sql">rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>简单查询实例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
<span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> row_id <span class="token keyword">from</span>  LOGINFO  
<span class="token punctuation">)</span> <span class="token keyword">where</span> row_id <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">10</span></code></pre>
<p>复杂查询示例，实际使用可能较多：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> tmp_page<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> row_id <span class="token keyword">from</span> <span class="token punctuation">(</span> 
        <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> LOGINFO <span class="token keyword">where</span> OPTYPE<span class="token operator">=</span><span class="token string">'1'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">desc</span> 
    <span class="token punctuation">)</span> <span class="token keyword">as</span> tmp_page
<span class="token punctuation">)</span> <span class="token keyword">where</span> row_id <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">10</span></code></pre>
<h3 id="5、建表操作"><a href="#5、建表操作" class="headerlink" title="5、建表操作"></a>5、建表操作</h3><p>实际项目中，相对比较完整的建表的操作包括建表、字段、注释（建议有）、索引（非必须），本次为示例完整性建一下索引，如下：</p>
<p>其中<code>DBCM</code>是SCHEMA，<code>DBCM_APP</code>是对应的表空间。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO
<span class="token punctuation">(</span>
     ID <span class="token keyword">BIGINT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> GENERATED <span class="token keyword">BY</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">AS</span> <span class="token keyword">IDENTITY</span><span class="token punctuation">,</span>
     <span class="token keyword">ENABLE</span> <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span>
     USER_ID CHARACTER<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     COUNT_AMT <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     LOG_MSG <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     OP_DATE <span class="token keyword">DATE</span> <span class="token keyword">default</span> <span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span>
     OP_TIME TIME <span class="token keyword">default</span>  <span class="token keyword">CURRENT</span>  TIME<span class="token punctuation">,</span>
     OP_TIMESTAMP <span class="token keyword">TIMESTAMP</span> <span class="token keyword">default</span>  <span class="token keyword">CURRENT</span>  <span class="token keyword">timestamp</span><span class="token punctuation">,</span>
     OP_TYPE CHAR<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">(</span>ID<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token operator">in</span> DBCM_APP <span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--表与字段相关注释</span>
<span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO <span class="token operator">IS</span> <span class="token string">"操作日志表"</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">.</span><span class="token keyword">ENABLE</span> <span class="token operator">IS</span> <span class="token string">"查询限制（1-可查，0-禁查）"</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">.</span>USER_ID <span class="token operator">IS</span> <span class="token string">"用户ID"</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">.</span>COUNT_AMT <span class="token operator">IS</span> <span class="token string">"操作金额"</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">.</span>LOG_MSG <span class="token operator">IS</span> <span class="token string">"操作信息"</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">.</span>OP_DATE <span class="token operator">IS</span> <span class="token string">"操作日期"</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">.</span>OP_TIME <span class="token operator">IS</span> <span class="token string">"操作时间"</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">.</span>OP_TIMESTAMP <span class="token operator">IS</span> <span class="token string">"操作时间戳"</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">.</span>OP_TYPE <span class="token operator">IS</span> <span class="token string">"操作时类型"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--创建表索引</span>
<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx1_dbcm_user_id <span class="token keyword">ON</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">(</span>USER_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx1_dbcm_opdate <span class="token keyword">ON</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">(</span>OP_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>如果要删除索引</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> idx1_dbcm_opdate <span class="token keyword">ON</span> DBCM<span class="token punctuation">.</span>LOGINFO<span class="token punctuation">(</span>OP_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="6、改表操作"><a href="#6、改表操作" class="headerlink" title="6、改表操作"></a>6、改表操作</h3><p>改表操作在实际中也会遇到，业务变更导致字段变化。</p>
<h4 id="增加列-："><a href="#增加列-：" class="headerlink" title="增加列 ："></a>增加列 ：</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span><span class="token keyword">schema</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span>tableName<span class="token operator">></span> <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>columnName<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token keyword">type</span><span class="token operator">></span></code></pre>
<p>如给刚才的<code>LOGINFO</code>表追加一个备用字段<code>MARK_1</code>：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> MARK_1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>添加带默认值的属性：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span>table_name<span class="token punctuation">]</span> <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">[</span>column_name<span class="token punctuation">]</span> <span class="token punctuation">[</span>column_type<span class="token punctuation">]</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">WITH</span> <span class="token keyword">DEFAULT</span> <span class="token punctuation">[</span><span class="token keyword">value</span><span class="token punctuation">]</span></code></pre>
<p>如新增带默认值的时间戳列:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO  <span class="token keyword">ALTER</span> <span class="token keyword">column</span> test_timestamp  <span class="token keyword">SET</span> <span class="token keyword">DEFAULT</span>  <span class="token keyword">current</span> <span class="token keyword">timestamp</span><span class="token punctuation">;</span></code></pre>
<h4 id="修改列-："><a href="#修改列-：" class="headerlink" title="修改列 ："></a>修改列 ：</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span><span class="token keyword">schema</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span>table_name<span class="token operator">></span> <span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>columnName<span class="token operator">></span> <span class="token keyword">SET</span> <span class="token keyword">DATA</span> <span class="token keyword">TYPE</span> <span class="token operator">&lt;</span>columnType<span class="token operator">></span></code></pre>
<p>如给刚才的<code>LOGINFO</code>表修改<code>OP_TYPE</code>字段：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO  <span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> OP_TYPE <span class="token keyword">SET</span> <span class="token keyword">DATA</span> <span class="token keyword">TYPE</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span></code></pre>
<p>如修改<code>OP_TYPE</code>字段，删除非空属性：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO  <span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> OP_TYPE <span class="token keyword">DROP</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span></code></pre>
<p>修改列默认值：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span>  <span class="token operator">&lt;</span><span class="token keyword">schema</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span>table_name<span class="token operator">></span>  <span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">[</span>column_name<span class="token punctuation">]</span> <span class="token keyword">SET</span> <span class="token keyword">default</span> <span class="token punctuation">[</span><span class="token keyword">value</span><span class="token punctuation">]</span></code></pre>
<h4 id="重命名列："><a href="#重命名列：" class="headerlink" title="重命名列："></a>重命名列：</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span>table_name<span class="token punctuation">]</span>  <span class="token keyword">RENAME</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">[</span>column_name<span class="token punctuation">]</span>  <span class="token keyword">TO</span> <span class="token punctuation">[</span>new_column_name<span class="token punctuation">]</span>  <span class="token punctuation">;</span></code></pre>
<p>如重命名<code>OP_TYPE</code>字段：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> DBCM<span class="token punctuation">.</span>LOGINFO  <span class="token keyword">RENAME</span> <span class="token keyword">COLUMN</span> OP_TYPE <span class="token keyword">TO</span> NEW_OP_TYPE<span class="token punctuation">;</span></code></pre>
<h4 id="删除列："><a href="#删除列：" class="headerlink" title="删除列："></a>删除列：</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span>  <span class="token operator">&lt;</span><span class="token keyword">schema</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span>tableName<span class="token operator">></span>  <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span>  <span class="token operator">&lt;</span>columnName<span class="token operator">></span>  </code></pre>
<p>如给刚才的<code>LOGINFO</code>表删除备用字段<code>MARK_1</code>：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span>  DBCM<span class="token punctuation">.</span>LOGINFO   <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span>  MARK_1 <span class="token punctuation">;</span></code></pre>
<p>你以为这样就完美了吗？不，还要进行重构表。</p>
<h4 id="重构表："><a href="#重构表：" class="headerlink" title="重构表："></a>重构表：</h4><p>重构表操作，可以使用命令，也可以使用<code>SQL</code>操作：</p>
<p>（1）命令操作模式：</p>
<pre class=" language-BASH"><code class="language-BASH">REORG TABLE  <schema>.<tableName> </code></pre>
<p>以上面的<code>LOGINFO</code>表为例，执行命令：</p>
<pre class=" language-bash"><code class="language-bash">REORG TABLE DBCM.LOGINFO <span class="token punctuation">;</span></code></pre>
<p>（2）<code>SQL</code>操作模式：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CALL</span> SYSPROC<span class="token punctuation">.</span>admin_cmd<span class="token punctuation">(</span><span class="token string">'reorg table  &lt;schema>.&lt;tableName>  '</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>以上面的<code>LOGINFO</code>表为例，执行<code>SQL</code>：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CALL</span> SYSPROC<span class="token punctuation">.</span>admin_cmd<span class="token punctuation">(</span><span class="token string">'reorg table DB2INST1.DATA_BASE'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="REORG扩展："><a href="#REORG扩展：" class="headerlink" title="REORG扩展："></a><code>REORG</code>扩展：</h4><p>什么是<code>REORG</code>?</p>
<p>对表数据进行增删改等操作，经过一系列更改后，逻辑上连续的数据可能会位于不连续的物理数据页上，在许多插入操作创建了溢出记录时尤其如此。按这种方式组织数据时，数据库管理器必须执行其他读操作才能访问顺序数据。而在删除大量行后，也需要执行其他的读操作。</p>
<p><code>REORG</code>（重组/重构）表的操作会整理数据碎片来减少浪费的空间，并对行进行重新排序以合并溢出记录，从而加快数据访问速度并最终提高查询性能。</p>
<p>什么时候执行<code>REORG</code> ?</p>
<p>（a）增加列，扩长度，修改列类型等。</p>
<p>（b）表中的记录变化量很大时，则需要在表上做<code>REORG</code>操作来优化数据库性能。</p>
<p>（c）对数据库对象的大量操作，如反复地删除表，删除索引，存储过程，会引起系统表中数据的频繁改变，导致表或索引碎片太多时需要<code>REORG</code>。可以使用<code>db2</code>工具<code>reorgchk</code>检查。</p>
]]></content>
      <categories>
        <category>DB2</category>
      </categories>
      <tags>
        <tag>DB2</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL之查询前N条记录</title>
    <url>/posts/3c74f69f.html</url>
    <content><![CDATA[<h2 id="SQL查询前N条记录的不同玩法"><a href="#SQL查询前N条记录的不同玩法" class="headerlink" title="SQL查询前N条记录的不同玩法"></a>SQL查询前N条记录的不同玩法</h2><h3 id="查询前N条记录"><a href="#查询前N条记录" class="headerlink" title="查询前N条记录"></a>查询前N条记录</h3><p>说明：</p>
<blockquote>
<p>N —就是我们要查询的N条记录。</p>
<p>示例默认查询前10条记录。</p>
<p>语法演示的都是简单查询，如果有条件和排序请自行添加，示例默认为无条件和默认排序。</p>
<p>想了解各个数据库SQL分页？请参考<a href="2cbe04e7.html">《SQL之SQL分页的N种玩法》</a>。</p>
<p>想了解Mybtatis模糊查询？请参考<a href="4c7816b.html">《Mybatis-模糊查询的N种玩法》</a>。</p>
</blockquote>
<h4 id="1、TOP-关键字"><a href="#1、TOP-关键字" class="headerlink" title="1、TOP 关键字"></a>1、TOP 关键字</h4><p>TOP 关键字支持的数据库： <code>SQL Server</code> 、 <code>Access</code> 。</p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token keyword">top</span>  N  <span class="token operator">*</span>  <span class="token keyword">from</span> table_name <span class="token punctuation">;</span></code></pre>
<p>使用示例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token keyword">top</span> <span class="token number">10</span>  <span class="token operator">*</span>  <span class="token keyword">from</span> loginfo <span class="token punctuation">;</span></code></pre>
<h4 id="2、Limit-关键字"><a href="#2、Limit-关键字" class="headerlink" title="2、Limit 关键字"></a>2、Limit 关键字</h4><p>Limit关键字支持的数据库： <code>MySQLr</code> 、<code>MariaDB</code>、<code>PostgreSQL</code>、 <code>SQLite</code>。</p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token operator">*</span>  <span class="token keyword">from</span> table_name  <span class="token keyword">limit</span> N <span class="token punctuation">;</span></code></pre>
<p>使用示例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token operator">*</span>  <span class="token keyword">from</span> loginfo <span class="token keyword">limit</span> <span class="token number">10</span> <span class="token punctuation">;</span></code></pre>
<h4 id="3、ROWNUM-行计数器"><a href="#3、ROWNUM-行计数器" class="headerlink" title="3、ROWNUM 行计数器"></a>3、ROWNUM 行计数器</h4><p>ROWNUM 支持的数据库：<code>Oracle</code></p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token operator">*</span>  <span class="token keyword">from</span> table_name <span class="token keyword">where</span> ROWNUM <span class="token operator">&lt;=</span> N <span class="token punctuation">;</span></code></pre>
<p>使用示例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token operator">*</span>  <span class="token keyword">from</span> loginfo <span class="token keyword">where</span> ROWNUM <span class="token operator">&lt;=</span> <span class="token number">10</span> <span class="token punctuation">;</span></code></pre>
<h4 id="4、Fetch-frist-N-rows-only"><a href="#4、Fetch-frist-N-rows-only" class="headerlink" title="4、Fetch frist  N   rows  only"></a>4、Fetch frist  N   rows  only</h4><p>Fetch first  N   rows  only 支持的数据库：<code>DB2</code></p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token operator">*</span>  <span class="token keyword">from</span> table_name  <span class="token keyword">Fetch</span> <span class="token keyword">first</span>  N  <span class="token keyword">rows</span>  only <span class="token punctuation">;</span></code></pre>
<p>使用示例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token operator">*</span>  <span class="token keyword">from</span> loginfo <span class="token keyword">Fetch</span> <span class="token keyword">first</span>  <span class="token number">10</span>  <span class="token keyword">rows</span>  only <span class="token punctuation">;</span></code></pre>
<h3 id="数据库和分页关键字-函数对应关系表"><a href="#数据库和分页关键字-函数对应关系表" class="headerlink" title="数据库和分页关键字/函数对应关系表"></a>数据库和分页关键字/函数对应关系表</h3><p>数据库查询和分页关键字/函数对应关系：</p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>分页关键字/函数</th>
</tr>
</thead>
<tbody><tr>
<td>SQL Server 、 Access</td>
<td>TOP</td>
</tr>
<tr>
<td>MySQLr 、MariaDB、PostgreSQL、 SQLite</td>
<td>Limit</td>
</tr>
<tr>
<td>Oracle</td>
<td>ROWNUM</td>
</tr>
<tr>
<td>DB2</td>
<td>Fetch frist  N   rows  only</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DB2常用函数</title>
    <url>/posts/d22e90ef.html</url>
    <content><![CDATA[<h2 id="DB2常用函数"><a href="#DB2常用函数" class="headerlink" title="DB2常用函数"></a>DB2常用函数</h2><h3 id="一、寄存器使用"><a href="#一、寄存器使用" class="headerlink" title="一、寄存器使用"></a>一、寄存器使用</h3><p>使用方式：<code>SYSIBM.SYSDUMMY1</code>、<code>SYSIBM.DUAL</code>、<code>values</code></p>
<p>使用示例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token string">'hello db2'</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>SYSDUMMY1<span class="token punctuation">;</span> 
<span class="token keyword">SELECT</span> <span class="token string">'hello db2'</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> 
<span class="token keyword">VALUES</span> <span class="token string">'hello db2'</span><span class="token punctuation">;</span> </code></pre>
<h3 id="二、时间处理相关"><a href="#二、时间处理相关" class="headerlink" title="二、时间处理相关"></a>二、时间处理相关</h3><h4 id="1、日期与时间"><a href="#1、日期与时间" class="headerlink" title="1、日期与时间"></a>1、日期与时间</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--使用寄存器方式</span>
<span class="token keyword">VALUES</span> <span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span> <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--查日期</span>
<span class="token keyword">VALUES</span> <span class="token keyword">CURRENT</span> TIME <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--查时间</span>
<span class="token keyword">VALUES</span> <span class="token keyword">CURRENT</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--查时间戳</span></code></pre>
<h4 id="2、年月日时分秒"><a href="#2、年月日时分秒" class="headerlink" title="2、年月日时分秒"></a>2、年月日时分秒</h4><p>年月日时分秒相关函数</p>
<pre class=" language-sql"><code class="language-sql">YEAR<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--获取年；</span>
MONTH<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--获取月；</span>
DAY<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--获取日；</span>
HOUR<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">--获取小时；</span>
MINUTE<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--获取分钟；</span>
SECOND<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">--获取秒；</span>
<span class="token keyword">DATE</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">--获取日期；</span>
TIME<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--获取时间；</span>
<span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">--获取时间戳。</span></code></pre>
<p>示例：</p>
<pre class=" language-sql"><code class="language-sql"> <span class="token comment" spellcheck="true">--使用寄存器方式获取当前年份</span>
<span class="token keyword">SELECT</span> YEAR<span class="token punctuation">(</span><span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--values方式获取当前月份</span>
<span class="token keyword">VALUES</span> MONTH（<span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> </code></pre>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--表示查当前月份的日志记录</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> DBCM<span class="token punctuation">.</span>LOGINFO L <span class="token keyword">WHERE</span> MONTH<span class="token punctuation">(</span>L<span class="token punctuation">.</span>OP_TIME<span class="token punctuation">)</span><span class="token operator">=</span> MONTH<span class="token punctuation">(</span><span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span> <span class="token operator">and</span> MONTH<span class="token punctuation">(</span>L<span class="token punctuation">.</span>OP_TIME<span class="token punctuation">)</span> <span class="token operator">=</span> MONTH<span class="token punctuation">(</span><span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span></code></pre>
<p>参数也可以是指定字符串</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> YEAR<span class="token punctuation">(</span><span class="token string">'2020-06-01'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span>
<span class="token keyword">VALUES</span> HOUR（<span class="token string">'2020-06-01 20:20:06'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> </code></pre>
<h4 id="3、年月日时分秒加减运行"><a href="#3、年月日时分秒加减运行" class="headerlink" title="3、年月日时分秒加减运行"></a>3、年月日时分秒加减运行</h4><p>还可以直接运行操作：要求加减带单位的时间长度。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token string">'2020-06-01 22:18:12'</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span> YEAR <span class="token operator">+</span><span class="token number">1</span> MONTH <span class="token operator">+</span><span class="token number">1</span> DAY <span class="token operator">+</span><span class="token number">1</span> HOUR <span class="token operator">+</span><span class="token number">1</span> MINUTE <span class="token operator">+</span><span class="token number">1</span> SECOND <span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--结果：2021-07-02 23:19:13</span>

<span class="token keyword">VALUES</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token string">'2020-05-30 21:18:12'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> YEAR <span class="token operator">-</span><span class="token number">1</span> MONTH <span class="token operator">-</span><span class="token number">1</span> DAY <span class="token operator">-</span><span class="token number">1</span> HOUR <span class="token operator">-</span><span class="token number">1</span> MINUTE <span class="token operator">-</span><span class="token number">1</span> SECOND <span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--结果：2019-04-29 20:17:11</span>

<span class="token comment" spellcheck="true">--表示查询当前月份的英文名称</span>
<span class="token keyword">SELECT</span> MONTHNAME<span class="token punctuation">(</span><span class="token keyword">CURRENT</span> <span class="token keyword">date</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span></code></pre>
<p>以<code>LOGINFO</code>表为例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--查询今年上个月的日志</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> DBCM<span class="token punctuation">.</span>LOGINFO L <span class="token keyword">WHERE</span> YEAR<span class="token punctuation">(</span>L<span class="token punctuation">.</span>OP_TIME<span class="token punctuation">)</span><span class="token operator">=</span> YEAR<span class="token punctuation">(</span><span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span> <span class="token operator">and</span> MONTH<span class="token punctuation">(</span>L<span class="token punctuation">.</span>OP_TIME<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token punctuation">(</span>MONTH<span class="token punctuation">(</span><span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span></code></pre>
<p>4、日期相关相关函数</p>
<pre class=" language-sql"><code class="language-sql">WEEK<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--判断时间年份及当前该年第几周</span>
MONTHNAME<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--获取月份英文名称</span>
DAY<span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">--判断时间是该月的第几天</span>
DAYNAME<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">--判断传入时间是周几的英文名称</span>
DAYOFYEAR<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">--判断传入时间是该年的第几天</span>
DAYOFMONTH<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--判断传入时间是该月的第几天</span>
DAYOFWEEK<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--判断传入时间是该周的第几天</span>
days<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">--可以获取两个时间相差天数</span></code></pre>
<p>使用示例：</p>
<p><code>WEEK()</code>:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> week<span class="token punctuation">(</span><span class="token string">'2020-06-10'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：24,表示传入时间是2020年第24周</span></code></pre>
<p><code>MONTHNAME()</code>：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> MONTHNAME<span class="token punctuation">(</span><span class="token string">'2020-06-10'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：June</span></code></pre>
<p><code>DAY()</code>:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> day<span class="token punctuation">(</span><span class="token string">'2020-06-10'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：10，6月的第10天</span></code></pre>
<p><code>DAYNAME()</code>:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> DAYNAME<span class="token punctuation">(</span><span class="token string">'2020-06-10'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：Wednesday</span></code></pre>
<p><code>DAYOFYEAR()</code>:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> DAYOFYEAR<span class="token punctuation">(</span><span class="token string">'2020-06-10'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">--结果：162</span></code></pre>
<p><code>DAYOFMONTH()</code>:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> DAYOFMONTH<span class="token punctuation">(</span><span class="token string">'2020-06-10'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">--结果：10，6月的第10天</span></code></pre>
<p><code>DAYOFWEEK()</code>:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> DAYOFWEEK<span class="token punctuation">(</span><span class="token string">'2020-06-10'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">--结果：4, 默认一周日为第一天，周三是第4天</span>
<span class="token keyword">VALUES</span> DAYOFWEEK<span class="token punctuation">(</span><span class="token string">'2020-06-14'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">--结果：1</span></code></pre>
<p><code>DAYOFWEEK_ISO()</code>:可以和<code>DAYOFWEEK()</code>比较一下：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> DAYOFWEEK_ISO<span class="token punctuation">(</span><span class="token string">'2020-06-10'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">--结果：3</span>
<span class="token keyword">VALUES</span> DAYOFWEEK_ISO<span class="token punctuation">(</span><span class="token string">'2020-06-14'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">--结果：7</span></code></pre>
<p><code>DAYS()</code>:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> DAYS<span class="token punctuation">(</span><span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token operator">-</span>DAYS<span class="token punctuation">(</span><span class="token keyword">CURRENT</span> <span class="token keyword">DATE</span><span class="token operator">-</span><span class="token number">10</span> DAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--结果：10 ，可以计算日期差多少天</span></code></pre>
<pre><code>values DAYNAME(current timestamp)
</code></pre><p><code>TIMESTAMPDIFF</code>:</p>
<pre class=" language-sql"><code class="language-sql">TIMESTAMPDIFF<span class="token punctuation">(</span>n<span class="token punctuation">,</span>CHAR<span class="token punctuation">(</span><span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token string">'2012-05-25 10:23:24'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token string">'2012-05-25 10:20:24'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>根据两个时间戳记之间的时差，返回由第一个参数定义的类型表示的估计时差。（整除部分，不会四舍五入）其中n的含义如下：</p>
<p>n=2：秒 ；    n=4 ：分；     n=8：时；</p>
<p>n=16 ：天；    n=32 ：周；</p>
<p>n=64：月；    n=128 ：季度；     n=256:年；</p>
<p>使用示例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUES</span> TIMESTAMPDIFF<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> char<span class="token punctuation">(</span><span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token string">'2020-06-14 12:12:12'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token string">'2020-06-10 12:12:12'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--结果：4 ，表示相差4天</span></code></pre>
<h4 id="4、时间的格式"><a href="#4、时间的格式" class="headerlink" title="4、时间的格式"></a>4、时间的格式</h4><p>ISO，使用国际标准组织（ISO）制订的日期和时间格式；USA，使用美国日期和时间的 IBM 标准格式。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">values</span> char<span class="token punctuation">(</span><span class="token keyword">current</span> <span class="token keyword">date</span><span class="token punctuation">,</span>iso<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--2020-06-10</span>
<span class="token keyword">values</span> char<span class="token punctuation">(</span><span class="token keyword">current</span> <span class="token keyword">date</span><span class="token punctuation">,</span>usa<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--06/10/2020</span>
<span class="token keyword">values</span> char<span class="token punctuation">(</span><span class="token keyword">current</span> time<span class="token punctuation">,</span>iso<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--18.08.53</span></code></pre>
<h3 id="三、字符串函数"><a href="#三、字符串函数" class="headerlink" title="三、字符串函数"></a>三、字符串函数</h3><h4 id="1、日期时间转换"><a href="#1、日期时间转换" class="headerlink" title="1、日期时间转换"></a>1、日期时间转换</h4><p>（1）<code>TO_CHAR()</code>把时间转换成指定格式的字符串类型。低版本<code>DB2</code>不支持。</p>
<p><code>“YYYY-MM-DD HH:MI:SS”</code> 十二小时制；</p>
<p><code>“YYYY-MM-DD HH24:MI:SS”</code>二十四小时制。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> TO_CHAR<span class="token punctuation">(</span><span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token string">'2020-06-10 12:18:12'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'YYYY-MM-DD HH24:MI:SS'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--结果：2020-06-10 12:18:12</span></code></pre>
<p>（2）<code>char(arg)</code>把参数转化成字符串</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">values</span> char<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--把100转化为100字符串内容</span></code></pre>
<h4 id="2、LENGTH函数"><a href="#2、LENGTH函数" class="headerlink" title="2、LENGTH函数"></a>2、LENGTH函数</h4><p>语法</p>
<pre><code>LENGTH(ARG)</code></pre><p>LENGTH函数返回参数<code>ARG</code>的长度。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> LENGTH<span class="token punctuation">(</span>LOG_MSG<span class="token punctuation">)</span> <span class="token keyword">FROM</span> DBCM<span class="token punctuation">.</span>LOGINFO</code></pre>
<h4 id="3、CONCAT函数"><a href="#3、CONCAT函数" class="headerlink" title="3、CONCAT函数"></a>3、<code>CONCAT</code>函数</h4><p>字符串连接函数。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span>CONCAT<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span><span class="token string">' world'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">' !'</span><span class="token punctuation">)</span>  <span class="token keyword">as</span> test
<span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--结果：hello world !</span></code></pre>
<h4 id="4、去空格函数"><a href="#4、去空格函数" class="headerlink" title="4、去空格函数"></a>4、去空格函数</h4><p><code>LTRIM</code>、<code>RTRIM</code>函数去空格</p>
<p><code>DB2</code>中无<code>trim()</code>函数，所以要去空格要执行左右去空格。</p>
<p><code>LTRIM()</code>：<code>LTRIM</code>函数从<code>CHAR</code>、<code>VARCHAR</code>、<code>GRAPHIC</code>或者<code>VARGRAPHIC</code>中去掉左侧空格。<br><code>RTRIM()</code>：<code>RTRIM</code>函数则去去掉右侧的空格。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> LTRIM<span class="token punctuation">(</span><span class="token string">'   hello 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>RTRIM<span class="token punctuation">(</span><span class="token string">' 2world !  '</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span></code></pre>
<h4 id="5、截取-截断函数"><a href="#5、截取-截断函数" class="headerlink" title="5、截取/截断函数"></a>5、截取/截断函数</h4><p>（1）<code>SUBSTR</code>函数</p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql">SUBSTR<span class="token punctuation">(</span>ARG1<span class="token punctuation">,</span>POS<span class="token punctuation">,</span><span class="token operator">&lt;</span>LENGTH<span class="token operator">></span><span class="token punctuation">)</span></code></pre>
<p><code>SUBSTR</code>函数返回<code>ARG1</code>中<code>POS</code>位置开始的<code>LENGTH</code>个字符，如果没有指定<code>LENGTH</code>，则返回剩余的字符。</p>
<p><code>substr()</code>是指从position开始算（包括position这个字符），截取的长度，也包括位置+长度所在的字符(前提是字符串的长度大于或等于两者之和)。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> SUBSTR<span class="token punctuation">(</span><span class="token string">'helloworld'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：ow</span></code></pre>
<p>（2）<code>LEFT</code>、<code>RIGHT</code>函数</p>
<p><code>LEFT(ARG,LENGTH)</code>：LEFT函数返回<code>ARG</code>最左边<code>LENGTH</code>个字符串，<code>ARG</code>可以是<code>CHAR</code>或<code>BINARY STRING</code>。</p>
<p><code>RIGHT(ARG,LENGTH)</code>：RIGHT函数返回<code>ARG</code>最右边的<code>LENGTH</code>个字符串</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">LEFT</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">RIGHT</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--结果： he  ld</span></code></pre>
<h4 id="6、大小写转换"><a href="#6、大小写转换" class="headerlink" title="6、大小写转换"></a>6、大小写转换</h4><p><code>LCASE</code>、<code>LOWER</code>、<code>UCASE</code>、<code>UPPER</code>函数</p>
<p>LCASE()、LOWER()：<br>LCASE、LOWER函数返回定长、变长字符串的小写形式。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">LCASE</span><span class="token punctuation">(</span><span class="token string">'heLLo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>LOWER<span class="token punctuation">(</span><span class="token string">'WORLD'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：hello  world</span></code></pre>
<p>UCASE()、UPPER()：<br>UCASE、UPPER函数返回定长、变长字符串的大写形式。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">UCASE</span><span class="token punctuation">(</span><span class="token string">'heLLo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>UPPER<span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：HELLO  WORLD</span></code></pre>
<h4 id="7、替换函数"><a href="#7、替换函数" class="headerlink" title="7、替换函数"></a>7、替换函数</h4><p>（a）INSERT函数</p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span><span class="token punctuation">(</span>ARG1<span class="token punctuation">,</span>POS<span class="token punctuation">,</span>SIZE<span class="token punctuation">,</span>ARG2<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">--找到位置替换</span></code></pre>
<p>INSERT函数返回一个字符串，将<code>ARG1</code>从<code>POS</code>处删除<code>SIZE</code>个字符，将<code>ARG2</code>插入该位置。</p>
<p>（b）REPLACE函数</p>
<p>语法：</p>
<pre><code>REPLACE(EXP1,EXP2,EXP3)</code></pre><p>REPLACE函数用<code>EXP3</code>代替<code>EXP1</code>中所有的<code>EXP2</code>。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> REPLACE<span class="token punctuation">(</span><span class="token string">'ROMANND'</span>，<span class="token string">'NND'</span><span class="token punctuation">,</span><span class="token string">'CCB'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span></code></pre>
<h4 id="8、条件查找字符串"><a href="#8、条件查找字符串" class="headerlink" title="8、条件查找字符串"></a>8、条件查找字符串</h4><p>根据条件查找字符串，返回字符串。</p>
<p>（a）REPEAT函数</p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql">REPEAT<span class="token punctuation">(</span>ARG1<span class="token punctuation">,</span>NUM_TIMES<span class="token punctuation">)</span></code></pre>
<p>REPEAT函数返回<code>ARG1</code>被重复<code>NUM_TIMES</code>次的字符串。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> REPEAT<span class="token punctuation">(</span><span class="token string">'hello'</span>，<span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span></code></pre>
<p>（b）SPACE函数</p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql">SPACE<span class="token punctuation">(</span>SIZE<span class="token punctuation">)</span></code></pre>
<p>SPACE函数返回一个包含<code>SIZE</code>个空格的字符串。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> SPACE<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果没发打，就是10个空格字符串</span></code></pre>
<h3 id="四、判断函数"><a href="#四、判断函数" class="headerlink" title="四、判断函数"></a>四、判断函数</h3><h4 id="1、VALUE函数"><a href="#1、VALUE函数" class="headerlink" title="1、VALUE函数"></a>1、VALUE函数</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">VALUE</span><span class="token punctuation">(</span>EXPRESSION1<span class="token punctuation">,</span>EXPRESSION2<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">--VALUE函数是用返回一个非空的值，当其第一个参数非空，直接返回该参数的值，如果第一个参数为空，则返回第二个参数的值。</span>

<span class="token comment" spellcheck="true">--表示如果LOGINFO.ID为空，则返回空串，如果LOGINFO.ID不为空，则返回LOGINFO.ID。</span>
<span class="token keyword">SELECT</span> <span class="token keyword">VALUE</span><span class="token punctuation">(</span>ID<span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> LOGINFO</code></pre>
<h4 id="2、COALESCE函数"><a href="#2、COALESCE函数" class="headerlink" title="2、COALESCE函数"></a>2、COALESCE函数</h4><p>处理null的函数。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">COALESCE</span><span class="token punctuation">(</span>ARG1<span class="token punctuation">,</span>ARG2<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">--COALESCE返回参数集中第一个非null参数。</span>
<span class="token comment" spellcheck="true">--用法类似于VALUE函数。当其第一个参数非空，直接返回该参数的值，如果第一个参数为空，则返回第二个参数的值</span></code></pre>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">COALESCE</span><span class="token punctuation">(</span>COUNT_AMT<span class="token punctuation">,</span> <span class="token string">'0.00'</span><span class="token punctuation">)</span> <span class="token keyword">from</span> LOGINFO <span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--金额为null的时候，显示0.00</span></code></pre>
<h4 id="3、NVL函数"><a href="#3、NVL函数" class="headerlink" title="3、NVL函数"></a>3、NVL函数</h4><p>处理null的函数。</p>
<pre class=" language-sql"><code class="language-sql">NVL<span class="token punctuation">(</span>exp1<span class="token punctuation">,</span> exp2<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">--如果exp1为NULL，则函数返回exp2，否则返回exp1本身。但此函数有一定局限，所以就有了NVL2函数。</span></code></pre>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> nvl<span class="token punctuation">(</span>COUNT_AMT<span class="token punctuation">,</span> <span class="token string">'0.00'</span><span class="token punctuation">)</span> <span class="token keyword">from</span> LOGINFO <span class="token punctuation">;</span></code></pre>
<blockquote>
<p><code>NVL2</code>函数：<code>Oracle/PLsql</code>中的一个函数,Oracle在<code>NVL</code>函数的功能上扩展，提供了<code>NVL2</code>函数。<code>NVL2(exp1, exp2, exp3)</code>的功能为：如果<code>exp1</code>为NULL，则函数返回<code>exp3</code>，若<code>exp1</code>不为null，则返回<code>exp2</code>。</p>
</blockquote>
<h4 id="4、CAST函数"><a href="#4、CAST函数" class="headerlink" title="4、CAST函数"></a>4、CAST函数</h4><p>与char有类似功能。可以用来转换类型。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span><span class="token keyword">CURRENT</span> TIME <span class="token keyword">AS</span> CHAR<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>SYSDUMMY1</code></pre>
<h4 id="5、VARCHAR函数"><a href="#5、VARCHAR函数" class="headerlink" title="5、VARCHAR函数"></a>5、<code>VARCHAR</code>函数</h4><p>语法：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">VARCHAR</span><span class="token punctuation">(</span>ARG<span class="token punctuation">,</span>LENGTH<span class="token punctuation">)</span></code></pre>
<p><code>VARCHAR</code>函数返回<code>ARG</code>字符串、日期型、图形串的可变长度<code>LENGTH</code>的字符串表示。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token string">'helloworld'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span></code></pre>
<h4 id="6、CASE-WHEN函数"><a href="#6、CASE-WHEN函数" class="headerlink" title="6、CASE-WHEN函数"></a>6、CASE-WHEN函数</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  id<span class="token punctuation">,</span>USER_ID<span class="token punctuation">,</span> 
<span class="token punctuation">(</span><span class="token keyword">case</span> 
<span class="token keyword">when</span><span class="token punctuation">(</span>COUNT_AMT<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">then</span> <span class="token string">'一般'</span>
<span class="token keyword">when</span><span class="token punctuation">(</span>COUNT_AMT<span class="token operator">></span><span class="token number">10000</span>  <span class="token operator">and</span>  COUNT_AMT<span class="token operator">&lt;=</span><span class="token number">50000</span> <span class="token punctuation">)</span>   <span class="token keyword">then</span> <span class="token string">'普通'</span>   
<span class="token keyword">when</span><span class="token punctuation">(</span>COUNT_AMT<span class="token operator">></span><span class="token number">50000</span>  <span class="token operator">and</span> COUNT_AMT<span class="token operator">&lt;=</span><span class="token number">100000</span> <span class="token punctuation">)</span>   <span class="token keyword">then</span> <span class="token string">'富裕'</span> 
<span class="token keyword">else</span>   <span class="token string">'土豪'</span>  <span class="token keyword">end</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">status</span>
<span class="token keyword">FROM</span>  DBCM<span class="token punctuation">.</span>LOGINFO </code></pre>
<h4 id="7、exists-A-函数"><a href="#7、exists-A-函数" class="headerlink" title="7、exists(A)函数"></a>7、exists(A)函数</h4><p>判断是否存在，存在数据返回true，不存在返回false。</p>
<p>在<code>sql</code>中再具体使用示例说明。</p>
<h4 id="8、判断字符位置"><a href="#8、判断字符位置" class="headerlink" title="8、判断字符位置"></a>8、判断字符位置</h4><p>（a）<code>instr</code>函数</p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql">instr<span class="token punctuation">(</span>源字符串<span class="token punctuation">,</span> 要查找的字符串<span class="token punctuation">,</span> 从第几个字符开始<span class="token punctuation">,</span> 要找到第几个匹配的序号<span class="token punctuation">)</span></code></pre>
<p>数据库中字符串索引都是从1开始，从0开始的话是搜索不到的。</p>
<p>默认查找顺序为从左到右。当起始位置为负数的时候，从右边开始查找。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">values</span> instr<span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--DB2执行报错</span>
<span class="token keyword">values</span> instr<span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--结果：5</span>
<span class="token keyword">values</span> instr<span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--结果：8</span>

<span class="token keyword">select</span> instr<span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--结果：8</span></code></pre>
<p>（b）<code>LOCATE</code>函数<br>语法：</p>
<pre class=" language-sql"><code class="language-sql">LOCATE<span class="token punctuation">(</span>ARG1<span class="token punctuation">,</span>ARG2<span class="token punctuation">,</span><span class="token operator">&lt;</span>POS<span class="token operator">></span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--只有起始位置</span></code></pre>
<p>LOCATE函数在<code>ARG2</code>中查找<code>ARG1</code>第一次出现的位置，如果指定<code>POS</code>，则从<code>ARG2</code>的<code>POS</code>处开始查找<code>ARG1</code>第一次出现的位置。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  LOCATE<span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'hello world'</span><span class="token punctuation">)</span> <span class="token keyword">from</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：3</span></code></pre>
<p>（c）<code>POSSTR</code>函数</p>
<p>语法：</p>
<pre class=" language-sql"><code class="language-sql">POSSTR<span class="token punctuation">(</span>EXP1<span class="token punctuation">,</span>EXP2<span class="token punctuation">)</span></code></pre>
<p><code>POSSTR</code>函数返回<code>EXP2</code>在<code>EXP1</code>中的位置。 –没有起始位置和结束位置 SELECT LOCATE(NAME，’a’) FROM T1</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  POSSTR<span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">,</span><span class="token string">'wo'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：7</span></code></pre>
<h3 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h3><p>（1）row_number() over()函数</p>
<p>排序、分页常用。</p>
<p>排序：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> row_id <span class="token keyword">from</span>  LOGINFO  </code></pre>
<p>分页：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
<span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> row_id <span class="token keyword">from</span>  LOGINFO  
<span class="token punctuation">)</span> <span class="token keyword">where</span> row_id <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">10</span></code></pre>
<p>（2）DIGITS函数：</p>
<p>DIGITS函数返回<code>SMALLINT</code>、<code>INTEGER</code>、<code>BIGIT</code>或者<code>DECIMAL</code>参数的字符串值。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGITS<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span></code></pre>
<p>（3）DOUBLE、FLOAT函数:</p>
<p>DOUBLE、FLOAT函数如果参数是一个数字表达式，返回与其对应的浮点数，否则返回错误代码。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DOUBLE</span><span class="token punctuation">(</span><span class="token string">'4569'</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span></code></pre>
<p>（4）INT函数</p>
<p>INT函数返回整型常量中的数字、字符串或者日期、时间的整数表示。</p>
<pre><code>SELECT INT(&#39;123&#39;) FROM SYSIBM.DUAL;</code></pre><p>（5）<code>BIGINT</code>函数</p>
<p><code>BIGINT</code>函数返回整型常量中的数字、字符串或者时间戳的64位长整数表示。</p>
<pre><code>SELECT BIGINT(&#39;789987&#39;) FROM SYSIBM.DUAL;</code></pre><p>（6）<code>SMALLINT</code>函数</p>
<p><code>SMALLINT</code>函数返回整型常量中的数字、字符串短整数表示。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">SMALLINT</span><span class="token punctuation">(</span><span class="token string">'124'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span></code></pre>
<p>（7）REAL函数</p>
<p>REAL函数返回一个数值的单精度浮点数表示。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">REAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：10.0</span></code></pre>
<p>（8）<code>DEC[IMAL]</code>函数</p>
<p><code>DEC[IMAL]</code>函数返回一个数值、<code>DECIMAL</code>的字符串、<code>INTEGER</code>的字符串、<code>FLOAT-POINT</code>的字符串、日期、时间或时间戳的<code>DECIMAL</code>数值。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DEC</span><span class="token punctuation">(</span><span class="token number">10.1314</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：10</span></code></pre>
<p>（9）HEX函数</p>
<p>HEX函数返回一个字符串的值的16进制表示。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> HEX<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：0A000000</span></code></pre>
<p>（10）FLOOR函数</p>
<p>FLOOR函数取小于或等于参数的最大整数。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> FLOOR<span class="token punctuation">(</span><span class="token number">10.50</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> SYSIBM<span class="token punctuation">.</span>DUAL<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--结果：10</span></code></pre>
]]></content>
      <categories>
        <category>DB2</category>
      </categories>
      <tags>
        <tag>DB2</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL之SQL分页的N种玩法</title>
    <url>/posts/2cbe04e7.html</url>
    <content><![CDATA[<h2 id="SQL分页的N种玩法"><a href="#SQL分页的N种玩法" class="headerlink" title="SQL分页的N种玩法"></a>SQL分页的N种玩法</h2><p>整理说明：</p>
<blockquote>
<p>大概以取前3页为例。</p>
<p>page_size — &gt;每页显示条数 10，后面不再重复说明。</p>
<p>page_num  —&gt; 页码  1,2,3 取前面的2页或3页</p>
<p>从<a href="3c74f69f.html">《SQL之查询前N条记录》</a>一文整理的<code>“数据库和分页关键字/函数对应关系表”</code>可以看到分页大致分4类数据库，就以代表性的数据库来列举，相同关键字或函数的数据库用法相似，不再单列。</p>
<p>想了解Mybtatis模糊查询？请参考<a href="4c7816b.html">《Mybatis-模糊查询的N种玩法》</a>。</p>
</blockquote>
<h3 id="一、SQL-Server-分页"><a href="#一、SQL-Server-分页" class="headerlink" title="一、SQL Server 分页"></a>一、SQL Server 分页</h3><h4 id="（1）TOP方式"><a href="#（1）TOP方式" class="headerlink" title="（1）TOP方式"></a>（1）TOP方式</h4><p>查询第一页的时候，用top方法，效率最高。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token keyword">top</span> <span class="token number">10</span>  pagesize   <span class="token keyword">from</span> table_name 
<span class="token keyword">where</span> id <span class="token operator">not</span> <span class="token operator">in</span><span class="token punctuation">(</span> <span class="token keyword">select</span> <span class="token keyword">top</span>  page_size <span class="token operator">*</span><span class="token punctuation">(</span>page_num  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>   id <span class="token keyword">from</span> table_name<span class="token punctuation">)</span></code></pre>
<p>如：</p>
<p>第1页：page_num  =1 时</p>
<pre><code>select top 10  *  from loginfo where id not in(select top 0  id from loginfo)</code></pre><p>第2页：page_num  =2 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">top</span> <span class="token number">10</span>  <span class="token operator">*</span>  <span class="token keyword">from</span> loginfo <span class="token keyword">where</span> id <span class="token operator">not</span> <span class="token operator">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">top</span> <span class="token number">10</span> id <span class="token keyword">from</span> loginfo<span class="token punctuation">)</span></code></pre>
<p>第2页：page_num  =3 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">top</span> <span class="token number">10</span>  <span class="token operator">*</span>  <span class="token keyword">from</span> loginfo <span class="token keyword">where</span> id <span class="token operator">not</span> <span class="token operator">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">top</span> <span class="token number">20</span> id <span class="token keyword">from</span> loginfo<span class="token punctuation">)</span></code></pre>
<h4 id="（2）row-number-分页"><a href="#（2）row-number-分页" class="headerlink" title="（2）row_number()分页"></a>（2）row_number()分页</h4><p> SQLServer2005以后出现。其实就是把数据编号，再根据编号分页显示。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> 
<span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>Rn<span class="token operator">=</span>row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span><span class="token punctuation">)</span> <span class="token keyword">from</span> loginfo<span class="token punctuation">)</span> <span class="token keyword">as</span> t
<span class="token keyword">where</span> t<span class="token punctuation">.</span>Rn <span class="token operator">between</span> <span class="token punctuation">(</span>page_num <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span> page_size <span class="token operator">+</span><span class="token number">1</span> <span class="token operator">and</span> page_num <span class="token operator">*</span> page_size <span class="token punctuation">;</span></code></pre>
<p>如：</p>
<p>第1页：page_num=1 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> 
<span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span> row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span><span class="token punctuation">)</span> <span class="token keyword">as</span> rownum <span class="token keyword">from</span> loginfo<span class="token punctuation">)</span> <span class="token keyword">as</span> t
<span class="token keyword">where</span> t<span class="token punctuation">.</span>rownum <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span>  <span class="token number">10</span></code></pre>
<p>第2页：page_num=2 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> 
<span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span><span class="token punctuation">)</span> <span class="token keyword">as</span> rownum <span class="token keyword">from</span> loginfo<span class="token punctuation">)</span> <span class="token keyword">as</span> t
<span class="token keyword">where</span> t<span class="token punctuation">.</span>rownum <span class="token operator">between</span> <span class="token number">11</span> <span class="token operator">and</span>  <span class="token number">20</span></code></pre>
<p>第2页：page_num=3 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> 
<span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>Rn<span class="token operator">=</span>row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span><span class="token punctuation">)</span> <span class="token keyword">from</span> loginfo<span class="token punctuation">)</span> <span class="token keyword">as</span> t
<span class="token keyword">where</span> t<span class="token punctuation">.</span>Rn <span class="token operator">between</span> <span class="token number">21</span> <span class="token operator">and</span>  <span class="token number">30</span></code></pre>
<h4 id="（3）offset-fetch-next-方式"><a href="#（3）offset-fetch-next-方式" class="headerlink" title="（3）offset  fetch next 方式"></a>（3）offset  fetch next 方式</h4><p>Sqlserve2012开始支持。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">order</span> <span class="token keyword">by</span> id
<span class="token keyword">offset</span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">*</span> page_size <span class="token keyword">rows</span> <span class="token keyword">fetch</span> <span class="token keyword">next</span> page_size <span class="token keyword">rows</span> only</code></pre>
<p>如：</p>
<p>第1页：page_num=1 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> loginfo <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">offset</span> <span class="token number">0</span> <span class="token keyword">rows</span> <span class="token keyword">fetch</span> <span class="token keyword">next</span> <span class="token number">10</span> <span class="token keyword">rows</span> only</code></pre>
<p>第2页：page_num=2 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> loginfo <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">offset</span> <span class="token number">10</span> <span class="token keyword">rows</span> <span class="token keyword">fetch</span> <span class="token keyword">next</span> <span class="token number">10</span> <span class="token keyword">rows</span> only</code></pre>
<p>第2页：page_num=3 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> loginfo <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">offset</span> <span class="token number">20</span> <span class="token keyword">rows</span> <span class="token keyword">fetch</span> <span class="token keyword">next</span> <span class="token number">10</span> <span class="token keyword">rows</span> only</code></pre>
<p>表示从第10行开始取接下来的10行数据。</p>
<h3 id="二、Mysql分页"><a href="#二、Mysql分页" class="headerlink" title="二、Mysql分页"></a>二、Mysql分页</h3><h4 id="（1）Limit"><a href="#（1）Limit" class="headerlink" title="（1）Limit"></a>（1）Limit</h4><p>Limit适用于数据量较少的情况，数据量在万以下，会进行全表扫描。</p>
<p>mysql数据库使用limit分页查询时，索引是从0开始的，表中第1条数据的索引是0，第2条数据的索引是1，第3条数据的索引是2，以此类推…</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">limit</span> <span class="token keyword">index</span><span class="token punctuation">,</span> pagesize<span class="token punctuation">;</span></code></pre>
<p>index表示结果集索引开始行提前数据；</p>
<p>pagesize表示结果集索引开始行,取出pagesize条记录数据。</p>
<p>实际使用时：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">limit</span>  <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span> page_size<span class="token punctuation">,</span> page_size<span class="token punctuation">;</span> </code></pre>
<p>如：</p>
<p>第1页：page_num  =1 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> loginfo <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--从第1行开始，取10条数据，索引是[0-9]</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> loginfo <span class="token keyword">limit</span> <span class="token number">10</span> <span class="token punctuation">;</span></code></pre>
<p>第2页：page_num  =2 时</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> loginfo <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--从第11行开始，取10条数据，索引是[10-19]</span></code></pre>
<p>第3页、第4页以此类推…</p>
<h4 id="（2）主键或唯一索引分页"><a href="#（2）主键或唯一索引分页" class="headerlink" title="（2）主键或唯一索引分页"></a>（2）主键或唯一索引分页</h4><p>利用索引扫描，可以提升查询速度，可用于万级数据量。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">where</span> id_primarykey <span class="token operator">></span> <span class="token punctuation">(</span>page_num<span class="token operator">*</span>page_size<span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id_primarykey <span class="token keyword">asc</span> <span class="token keyword">limit</span> page_size</code></pre>
<p>如：</p>
<p>第1页：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_s_log <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">10</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span> <span class="token keyword">limit</span> <span class="token number">10</span></code></pre>
<p>第2页：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_s_log <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">20</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span> <span class="token keyword">limit</span> <span class="token number">10</span></code></pre>
<h4 id="（3）索引预执行PREPARE"><a href="#（3）索引预执行PREPARE" class="headerlink" title="（3）索引预执行PREPARE"></a>（3）索引预执行PREPARE</h4><p>语法</p>
<pre class=" language-sql"><code class="language-sql">PREPARE stmt_name <span class="token keyword">FROM</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> id_primarykey <span class="token operator">></span> <span class="token punctuation">(</span>page_num <span class="token operator">*</span> page_size<span class="token punctuation">)</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id_primarykey <span class="token keyword">asc</span> <span class="token keyword">limit</span> page_size。</code></pre>
<p>《Mysql预执行PREPARE》</p>
<h4 id="（4）利用子查询-嵌套查询"><a href="#（4）利用子查询-嵌套查询" class="headerlink" title="（4）利用子查询/嵌套查询"></a>（4）利用子查询/嵌套查询</h4><p>利用子查询，如果有索引或主键尽量使用索引或主键排序，子查询是在索引上完成。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span>  id <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> table_name <span class="token keyword">ORDER</span>
<span class="token keyword">BY</span> id <span class="token keyword">desc</span> <span class="token keyword">LIMIT</span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">desc</span> <span class="token keyword">LIMIT</span>  page_size</code></pre>
<p>我测试实际运行数据库一张日志表中4万条数据的情况下查询速度对比，我的主键id是32位字符串。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--执行时间约：0.030 sec</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_s_log <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">30000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span> 

<span class="token comment" spellcheck="true">--执行时间约：0.012 sec</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_s_log <span class="token keyword">WHERE</span> ID <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> T_S_LOG <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> ID   <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">30000</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span>  <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>子查询明显比单纯的<code>limit index, page_size</code>快。</p>
<h4 id="（5）利用连接查询"><a href="#（5）利用连接查询" class="headerlink" title="（5）利用连接查询"></a>（5）利用连接查询</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">AS</span> t1
<span class="token keyword">JOIN</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> table_name <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">desc</span> <span class="token keyword">LIMIT</span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size <span class="token punctuation">)</span><span class="token keyword">AS</span> t2
<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>id <span class="token operator">&lt;=</span> t2<span class="token punctuation">.</span>id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> t1<span class="token punctuation">.</span>id <span class="token keyword">desc</span> <span class="token keyword">LIMIT</span> page_size<span class="token punctuation">;</span></code></pre>
<p>从查询的临时表t2可以看得出当页码越大速度会越慢，此方法慎用。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--执行时间约：11.193 sec</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_s_log <span class="token keyword">AS</span> t1 <span class="token keyword">JOIN</span> <span class="token punctuation">(</span> 
    <span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t_s_log <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token keyword">AS</span> t2
<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>id <span class="token operator">&lt;=</span> t2<span class="token punctuation">.</span>id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> t1<span class="token punctuation">.</span>id <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<h4 id="（6）BETWEEN-AND分页"><a href="#（6）BETWEEN-AND分页" class="headerlink" title="（6）BETWEEN AND分页"></a>（6）BETWEEN AND分页</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">where</span> id <span class="token operator">BETWEEN</span> start_id <span class="token operator">AND</span> end_id<span class="token punctuation">;</span></code></pre>
<p>可以看出这是直接定位ID的范围的方式，它十分依赖id的，如id的连续性问题，但是作为无删除的应用环境下是十分实用的且高效的。<code>BETWEEN  ADN</code>的方式支持字符串ID。但是作为一种分页查询的方式，采用直接定位ID范围的方式，依旧是比较有效率的。</p>
<h3 id="三、Oracle-分页"><a href="#三、Oracle-分页" class="headerlink" title="三、Oracle 分页"></a>三、Oracle 分页</h3><p>oracle主要还是使用<code>ROWNUM</code>进行分页。</p>
<h4 id="（1）直接简单粗暴的方式"><a href="#（1）直接简单粗暴的方式" class="headerlink" title="（1）直接简单粗暴的方式"></a>（1）直接简单粗暴的方式</h4><p>先排序再取需要的数据，数据越多越慢。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> t<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>rownum num <span class="token keyword">from</span> table_name t
<span class="token punctuation">)</span> 
<span class="token keyword">where</span> t<span class="token punctuation">.</span>num <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>page_num <span class="token operator">*</span> page_size<span class="token punctuation">)</span> <span class="token operator">and</span>  t<span class="token punctuation">.</span>num<span class="token operator">>=</span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size <span class="token operator">+</span><span class="token number">1</span>
<span class="token comment" spellcheck="true">--where BETWEEN (page_num-1)*page_size +1 AND  (page_num * page_size) </span></code></pre>
<p>排序好了直接拿，</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  <span class="token operator">*</span>，ROWNUM  rn  <span class="token keyword">FROM</span> table_name <span class="token keyword">where</span> rm <span class="token operator">BETWEEN</span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size <span class="token operator">+</span><span class="token number">1</span> <span class="token operator">AND</span>  <span class="token punctuation">(</span>page_num <span class="token operator">*</span> page_size<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">--注意：oracle 没有 as</span></code></pre>
<h4 id="（2）子查询-嵌套查询"><a href="#（2）子查询-嵌套查询" class="headerlink" title="（2）子查询/嵌套查询"></a>（2）子查询/嵌套查询</h4><p>子查询都是通过限定查询范围的方式缩小查询范围。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> t<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>ROWNUM r <span class="token keyword">FROM</span> table_name t <span class="token keyword">WHERE</span> r <span class="token operator">&lt;=</span> page_num<span class="token operator">*</span>page_size
<span class="token punctuation">)</span> <span class="token keyword">WHERE</span> r <span class="token operator">></span><span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size
<span class="token comment" spellcheck="true">--没有+1是因为用的大于号</span></code></pre>
<p>​    （a）不排序的子查询</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> tmp<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> t<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>ROWNUM rn <span class="token keyword">from</span> table_name t <span class="token keyword">where</span> t<span class="token punctuation">.</span>rn <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>page_num <span class="token operator">*</span> page_size<span class="token punctuation">)</span>
<span class="token punctuation">)</span> tmp 
<span class="token keyword">where</span> tmp<span class="token punctuation">.</span>rn <span class="token operator">>=</span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size <span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">-- +1是因为用的大于或等于号</span></code></pre>
<p>​    （b）带 <code>order by</code>的排序</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> tmp<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> t<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> rownum rn <span class="token keyword">from</span> <span class="token punctuation">(</span>
        <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> T_BASE_PROVINCE <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span>
    <span class="token punctuation">)</span> t
     <span class="token keyword">where</span> t<span class="token punctuation">.</span>rn <span class="token operator">&lt;=</span>  <span class="token punctuation">(</span>page_num <span class="token operator">*</span> page_size<span class="token punctuation">)</span>
<span class="token punctuation">)</span> tmp
<span class="token keyword">where</span> tmp<span class="token punctuation">.</span>rn <span class="token operator">>=</span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size <span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">;</span></code></pre>
<h4 id="（3）使用minus作差"><a href="#（3）使用minus作差" class="headerlink" title="（3）使用minus作差"></a>（3）使用minus作差</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">where</span> rownum<span class="token operator">&lt;=</span><span class="token punctuation">(</span>page_num <span class="token operator">*</span> page_size<span class="token punctuation">)</span>
minus 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">where</span> rownum<span class="token operator">&lt;=</span><span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size</code></pre>
<h4 id="（4）WITH-AS方式"><a href="#（4）WITH-AS方式" class="headerlink" title="（4）WITH  AS方式"></a>（4）WITH  AS方式</h4><p><code>WITH  AS</code>将SQL语句中单独的子查询语句提取出来，作为一个单独的临时表来组织命名。在原来的语句中，就可以使用新的别名来替代子查询。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">WITH</span> tmp1 <span class="token keyword">AS</span><span class="token punctuation">(</span>
<span class="token punctuation">(</span>
      <span class="token keyword">SELECT</span> ROWNUM <span class="token keyword">AS</span> rowno<span class="token punctuation">,</span> tt<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span>  
         <span class="token keyword">SELECT</span> <span class="token operator">*</span>  <span class="token keyword">FROM</span> table_name t
              <span class="token keyword">WHERE</span> <span class="token keyword">some</span> conditions
              <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> fact_up_time<span class="token punctuation">,</span> flight_no
     <span class="token punctuation">)</span> tt
    <span class="token keyword">WHERE</span> ROWNUM <span class="token operator">&lt;=</span> page_num<span class="token operator">*</span>page_size
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tmp1<span class="token punctuation">.</span>rowno <span class="token operator">></span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size</code></pre>
<p>这里是有排序的，无排序的写法同理。</p>
<p>总结：<strong>能不查全表尽量不去查全表，尽快缩小查询范围，再提取分页数据。</strong></p>
<h3 id="四、DB2分页"><a href="#四、DB2分页" class="headerlink" title="四、DB2分页"></a>四、DB2分页</h3><h4 id="（1）BETWEEN-AND分页"><a href="#（1）BETWEEN-AND分页" class="headerlink" title="（1）BETWEEN AND分页"></a>（1）BETWEEN AND分页</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span> <span class="token punctuation">)</span> <span class="token keyword">as</span> rowid <span class="token keyword">from</span> table_name
<span class="token punctuation">)</span><span class="token keyword">as</span> <span class="token number">a</span>

<span class="token keyword">where</span> <span class="token number">a</span><span class="token punctuation">.</span>rowid <span class="token operator">>=</span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size<span class="token operator">+</span><span class="token number">1</span>  <span class="token operator">AND</span> <span class="token number">a</span><span class="token punctuation">.</span>rowid <span class="token operator">&lt;=</span> page_num<span class="token operator">*</span>page_size
<span class="token comment" spellcheck="true">--where a.rowid  between (page_num-1)*page_size+1  and  page_num*page_size</span></code></pre>
<p>在实际使用中，table_name可能会是一个真正业务数据子查询：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> tmp_page<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> row_id <span class="token keyword">from</span> <span class="token punctuation">(</span> 
        <span class="token keyword">select</span>  ID<span class="token punctuation">,</span> LOG_MSG<span class="token punctuation">,</span> OPACCOUNT<span class="token punctuation">,</span> OP_TIME<span class="token punctuation">,</span> OPTYPE<span class="token punctuation">,</span> VERIFY_ACCOUNT<span class="token punctuation">,</span> ADDRIP<span class="token punctuation">,</span> DBAPP <span class="token keyword">from</span> LOGINFO <span class="token keyword">WHERE</span> <span class="token punctuation">(</span> OP_TIME <span class="token operator">>=</span> <span class="token string">'2020-06-15 17:05:52'</span> <span class="token operator">and</span> OPTYPE <span class="token operator">=</span> <span class="token string">'登录'</span> <span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">desc</span>
    <span class="token punctuation">)</span> <span class="token keyword">as</span> tmp_page
<span class="token punctuation">)</span> <span class="token keyword">where</span> row_id <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">30</span> </code></pre>
<h4 id="（2）WITH-AS-方式"><a href="#（2）WITH-AS-方式" class="headerlink" title="（2）WITH  AS 方式"></a>（2）WITH  AS 方式</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">WITH</span> TMP <span class="token keyword">AS</span><span class="token punctuation">(</span>
    <span class="token comment" spellcheck="true">--先找出需要的数据</span>
   <span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span> <span class="token punctuation">)</span> <span class="token keyword">as</span> row_id <span class="token keyword">from</span> table_name

<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">--最后根据序号取数据</span>
<span class="token keyword">SELECT</span> TMP<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> TMP <span class="token keyword">WHERE</span>  row_id <span class="token operator">between</span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size <span class="token operator">and</span> page_num<span class="token operator">*</span>page_size</code></pre>
<p>本质还是借助<code>rownumber() over()</code>排好序，明显可以看到缺点是临时表较大。</p>
<p>实际使用示例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">with</span> tmp <span class="token keyword">as</span><span class="token punctuation">(</span>
    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>

        <span class="token keyword">select</span> tmp_page<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> row_id <span class="token keyword">from</span> <span class="token punctuation">(</span> 

                <span class="token keyword">select</span>  ID<span class="token punctuation">,</span> LOG_MSG<span class="token punctuation">,</span> OPACCOUNT<span class="token punctuation">,</span>OP_TIME<span class="token punctuation">,</span> OPTYPE 
                <span class="token keyword">from</span> LOGINFO <span class="token keyword">WHERE</span> <span class="token punctuation">(</span> OPTYPE <span class="token operator">>=</span><span class="token string">'2020-06-15 17:05:52'</span> <span class="token operator">and</span> OPTYPE <span class="token operator">=</span> <span class="token string">'登陆'</span>                     <span class="token punctuation">)</span>  <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">desc</span>
         <span class="token punctuation">)</span> <span class="token keyword">as</span> tmp_page  
    <span class="token punctuation">)</span> 
<span class="token punctuation">)</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tmp <span class="token keyword">where</span> row_id <span class="token operator">between</span> <span class="token number">30</span> <span class="token operator">and</span> <span class="token number">40</span></code></pre>
<h4 id="（3）Fetch-first-rows-only"><a href="#（3）Fetch-first-rows-only" class="headerlink" title="（3）Fetch first rows only"></a>（3）Fetch first rows only</h4><p>使用Fetch first rows only分页依旧借助<code>WITH  AS</code>但是可以不断缩小临时表的范围。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">WITH</span> TMP <span class="token keyword">AS</span><span class="token punctuation">(</span>
    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
            <span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">asc</span> <span class="token punctuation">)</span> <span class="token keyword">as</span> row_id <span class="token keyword">from</span> table_name
    <span class="token punctuation">)</span> 
    <span class="token keyword">where</span>  row_id <span class="token operator">></span> <span class="token punctuation">(</span>page_num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>page_size
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> TMP<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> TMP <span class="token keyword">WHERE</span>   <span class="token keyword">fetch</span> <span class="token keyword">first</span>  pagesize  <span class="token keyword">rows</span> only</code></pre>
<p>实际使用示例：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">with</span> tmp <span class="token keyword">as</span><span class="token punctuation">(</span>
    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>

        <span class="token keyword">select</span> tmp_page<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>rownumber<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> row_id <span class="token keyword">from</span> <span class="token punctuation">(</span> 

            <span class="token keyword">select</span>  ID<span class="token punctuation">,</span>  LOG_MSG<span class="token punctuation">,</span> OPACCOUNT<span class="token punctuation">,</span> OP_APPNAME<span class="token punctuation">,</span> OP_DATABASE<span class="token punctuation">,</span> OP_TIME<span class="token punctuation">,</span> OPTYPE 
            <span class="token keyword">from</span> LOGINFO <span class="token keyword">WHERE</span> <span class="token punctuation">(</span> OPTYPE <span class="token operator">>=</span><span class="token string">'2020-06-15 17:05:52'</span> <span class="token operator">and</span> OPTYPE <span class="token operator">=</span> <span class="token string">'登录'</span> <span class="token punctuation">)</span>               <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">desc</span>

         <span class="token punctuation">)</span> <span class="token keyword">as</span> tmp_page 

    <span class="token punctuation">)</span> <span class="token keyword">where</span> row_id <span class="token operator">></span><span class="token number">20</span>

<span class="token punctuation">)</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tmp <span class="token keyword">fetch</span> <span class="token keyword">first</span>  <span class="token number">10</span> <span class="token keyword">rows</span> only</code></pre>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>SQL分页</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建静态博客（四）——插件安装</title>
    <url>/posts/cda13ebe.html</url>
    <content><![CDATA[<p>Hexo静态博客插件安装相关内容，本文以安装search和abbrlink插件为例。</p>
<a id="more"></a>

<p>注意：安装插件不是非必须，除了部分插件跟着主题必须安装之外，其他插件属于可选。</p>
<h2 id="安装插件命令"><a href="#安装插件命令" class="headerlink" title="安装插件命令"></a>安装插件命令</h2><pre><code>npm install   hexo-generator-feed  --save   #订阅
npm install   hexo-generator-search --save  #搜索</code></pre><h2 id="本地搜索插件"><a href="#本地搜索插件" class="headerlink" title="本地搜索插件"></a>本地搜索插件</h2><p>这里说一下添加本地搜索，有的主题已经自己带了搜索功能，只要配置开启即可。如果没有带主题可以自己加上。<br><font color=red>特别说明：如果主题自带搜索，看自带搜索操作说明即可，如果主题无搜索看自定义模式说明即可。</font></p>
<h3 id="步骤一-安装插件"><a href="#步骤一-安装插件" class="headerlink" title="步骤一 安装插件"></a>步骤一 安装插件</h3><p>第一步：安装搜索插件 <code>npm install hexo-generator-searchdb --save</code></p>
<h3 id="步骤二-修改配置"><a href="#步骤二-修改配置" class="headerlink" title="步骤二 修改配置"></a>步骤二 修改配置</h3><p>第二步：根目录_config.yml文件配置添加</p>
<pre><code>search:
  path: search.xml
  field: post
  format: html
  limit: 10000</code></pre><p>主题配置_config.yml添加</p>
<pre><code>local_search: 
  enable: true</code></pre><h3 id="步骤三-添加搜索"><a href="#步骤三-添加搜索" class="headerlink" title="步骤三 添加搜索"></a>步骤三 添加搜索</h3><p>第三步:添加搜索框</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>search-content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pure-form<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>local-search-input<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>q<span class="token punctuation">"</span></span> <span class="token attr-name">results</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">autocomplete</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>off<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>搜索<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pure-input pure-input-1<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span><span class="token number">204</span>, <span class="token number">232</span>, <span class="token number">207</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>local-search-result<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>第1种，主题自带搜索模式，有独立的search页面,生成页面前面已经讲到了，把代码放到source/search/index.md文件中即可。</p>
<p>第2种，自定义模式，直接加在首页，想加哪个位置看自己喜好，位置找主题下的布局文件夹_layout或layout/partials之类的文件夹下,里面有head.ejs或head.swig文件（如果不是请自己查找节点，文件反正就那些）,添加html代码</p>
<h3 id="步骤四-引入js文件"><a href="#步骤四-引入js文件" class="headerlink" title="步骤四 引入js文件"></a>步骤四 引入js文件</h3><p>第四步：引入js</p>
<p>第1种，主题自带搜索模式，主题下的配置文件一般有scripts设置，直接配置路径，一般都有示例如</p>
<pre><code>scripts:
#- //cdn.bootcss.com/zepto/1.2.0/zepto.min.js
#- /js/xoxo.js
  - /js/search.js</code></pre><p>第2种，自定义模式，没有scripts配置,就在找主题下的布局文件夹_layout或layout/中，有js.ejs或srcipt.ejs，<br>文件可以从这里拿：<a href="https://github.com/zhzy2017/hexo-search-plugin-snippets" target="_blank" rel="noopener">https://github.com/zhzy2017/hexo-search-plugin-snippets</a><br>把search.js 放到source\js目录下,引入使用也有不同的方法</p>
<h3 id="步骤五-引入css文件"><a href="#步骤五-引入css文件" class="headerlink" title="步骤五 引入css文件"></a>步骤五 引入css文件</h3><p>第五步：css设置<br>有的带搜索的无须操作，没有的从下载hexo-search-plugin-snippets里面拿拷贝到source/css里面，引入即可，</p>
<p>第1种，主题自带搜索模式，一般不需要配置写在公共文件中，如果没有样式可以在主题下的配置文件一般有stylesheets设置，直接配置路径，一般都有示例：</p>
<pre><code>stylesheets:
# - /css/normalize.css
 - //cdn.bootcss.com/pure/1.0.0/pure-min.css
 - /css/xoxo.css
</code></pre><p>第2种，自定义模式，跟配引入js类似，找一下主题目录ejs或swig文件引入，或者直接用css或less文件放到source/css目录下的某个文件中，这样不需要引文件</p>
<p>其他插件，具体使用自行搜索，一般是修改配置或添加代码</p>
<pre><code>npm install hexo-generator-index-pin-top –save  #文章置顶插件 
npm uninstall hexo-generator-index –save     #文章置顶插件 
npm i –save hexo-wordcount        #文章字数+阅读时长统计     
npm install hexo-baidu-url-submit –save     #百度链接主动推送     
npm install hexo-deployer-ftpsync –save     #hexo上传至FTP服务器     
npm install hexo-deployer-cos –save     #hexo上传至腾讯云COS     
npm install hexo-deployer-aliyun –save     #hexo上传至阿里云     
npm install –save hexo-admin     #hexo管理插件     
hexo-blog-encrypt(请看文档)     #hexo文章加密码 
npm install leancloud-storage –save     #Valine评论     
Valine评论邮件通知     Valine评论提醒 
npm install hexo-deployer-git –save hexo安装git（允许使用git命令）</code></pre><p>更多插件请访问插件中心：<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a><br>使用参考链接参考<a href="https://blog.csdn.net/q2158798/article/details/82354154" target="_blank" rel="noopener">幻凡ss</a></p>
<h3 id="修改修改永久链接"><a href="#修改修改永久链接" class="headerlink" title="修改修改永久链接"></a>修改修改永久链接</h3><p>Hexo修改修改永久链接的默认格式,方便SEO.<br><code>npm install hexo-abbrlink --save</code>  #文章永久链接 <a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="noopener">项目地址在这里</a></p>
<h4 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink --save</code></pre>
<h4 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="2.修改配置"></a>2.修改配置</h4><pre><code># permalink: :year/:month/:day/:title/
# permalink_defaults:
permalink: posts/:abbrlink.html
abbrlink:
  alg: crc32  # 算法：crc16(default) and crc32
  rep: hex    # 进制：dec(default) and hex</code></pre><h4 id="3-重启"><a href="#3-重启" class="headerlink" title="3.重启"></a>3.重启</h4><pre class=" language-bash"><code class="language-bash">hexo clean <span class="token operator">&amp;</span> heox g <span class="token operator">&amp;</span> hexo s</code></pre>
<p>点击一篇文章，检查浏览器地址看看是不是发生变化了？</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建静态博客（五）——踩坑问题</title>
    <url>/posts/ce4a93ff.html</url>
    <content><![CDATA[<p> 本文记录捣鼓hexo博客时遇到的一些踩坑的记录及相关解决思路。</p>
<a id="more"></a>

<p>常见报错多在 <code>hexo g</code> 的时候报错</p>
<h5 id="1-YAMLException"><a href="#1-YAMLException" class="headerlink" title="1. YAMLException"></a>1. YAMLException</h5><pre><code>ERROR Process failed: _posts/hexo-problem.md
YAMLException: end of the stream or a document separator is expected at line x, column y:
at ...</code></pre><p>解决思路：<br>A. 一般是因为缺少分隔符，缺少空格，<code>key: value</code> ，英文冒号后面留空格，一般错会提示哪个文件的第几行第几列。<br>B.其次是头部yaml配置</p>
<pre><code>---
key: value
---</code></pre><p>缺少也会导致文章内容报错，具体报错的行列位置如果没有问题，就检查头部或者附件标点，或分段测试，该方案适合文章报错<br>C.还有一些特殊字符，如<code>[ ]</code>也会导致报错，我在title中使用英文<code>[ ]</code>也会报错，但提示的位置没有问题，注意特殊字符使用</p>
<h5 id="2-某个ejs或swig文件报错"><a href="#2-某个ejs或swig文件报错" class="headerlink" title="2.  某个ejs或swig文件报错"></a>2.  某个ejs或swig文件报错</h5><p>（1）此类问题一般是使用某个主题之后会出现，注意主题下的配置文件_config.yml检查是否配置，参考（一）A的思路<br>（2）缺少相关插件如xoxo主题生成时就有readingTime的报错，安装了hexo-reading-time的插件后解决，如是其他同理网上搜一下</p>
<pre><code>npm install   hexo-reading-time --save</code></pre><p>(3)使用主题的时候注意先阅读相关使用文档，有些主题需要一些插件</p>
<h5 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h5><p>后续补充</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建静态博客（三）——主题更换</title>
    <url>/posts/a5bf7e18.html</url>
    <content><![CDATA[<p>Hexo静态博客已经搭建好了，链接页面有了，主题不好看怎么换呢？本文记录主题更换相关内容。</p>
 <a id="more"></a>

<p>选择一个自己喜欢的 Hexo 主题站：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>极简主题推荐：<br><a href="https://github.com/zhzy2017/hexo-theme-polarbear.git" target="_blank" rel="noopener">hexo-theme-polarbear</a><br><a href="https://github.com/zhzy2017/gd4Ark.github.io.git" target="_blank" rel="noopener">hexo-theme-polarbear  （gd4Ark的扩展版）</a> （下载后执行安装npm install）<br><a href="https://github.com/zhzy2017/hexo-theme-sky.git" target="_blank" rel="noopener">hexo-theme-sky</a><br><a href="https://github.com/zhzy2017/hexo-theme-xoxo.git" target="_blank" rel="noopener">hexo-theme-xoxo</a><br><a href="https://github.com/zhzy2017/hexo-theme-xoxo-plus.git" target="_blank" rel="noopener">hexo-theme-xoxo-plus</a><br>漂亮主题推荐：<br>[hexo-theme-matery]（<a href="https://github.com/blinkfox/hexo-theme-matery）" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery）</a><br>[hexo-theme-ayer]（<a href="https://github.com/Shen-Yu/hexo-theme-ayer）" target="_blank" rel="noopener">https://github.com/Shen-Yu/hexo-theme-ayer）</a></p>
<p>其中极简主题有些没有search功能，如需要自己安装search插件，参考Hexo搭建静态博客（四）——插件安装<br>极简主题我比较喜欢hexo-theme-polarbear，对扩展版进行补充搜索功能。</p>
<p>如安装主题hexo-theme-xoxo-plus。</p>
<h4 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1.下载主题"></a>1.下载主题</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> themes
<span class="token function">git</span> clone https://github.com/zhzy2017/hexo-theme-xoxo-plus.git</code></pre>
<h4 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="2.修改配置"></a>2.修改配置</h4><p>修改全局配置根目录_config.yml, 注意theme的值要和theme目录的主题的文件夹名字一致</p>
<pre><code># Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
# landscape
theme: hexo-theme-xoxo-plus</code></pre><h4 id="3-启动预览"><a href="#3-启动预览" class="headerlink" title="3.启动预览"></a>3.启动预览</h4><pre class=" language-bash"><code class="language-bash">hexo g <span class="token operator">&amp;</span> hexo s</code></pre>
<p>浏览器访问：<br>大功告成。</p>
<p>如果对该主题的其他设置请参考主题用法，到主题目录下修改主题的配置文件_config.yml</p>
<p>如有问题请参考本系列：<a href="/post/ce4a93ff.html">Hexo搭建静态博客（五）——踩坑问题</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建静态博客（六）——项目部署</title>
    <url>/posts/c68d7a69.html</url>
    <content><![CDATA[<p>本文记录将hexo博客部署到github、云服务器上的相关操作操作。</p>
<a id="more"></a>

<h4 id="关于部署"><a href="#关于部署" class="headerlink" title="关于部署"></a>关于部署</h4><p>常见部署在github上，如果有自己独立的服务器也可以部署在服务上，此处用的腾讯云服务器。</p>
<h3 id="一-Github上部署"><a href="#一-Github上部署" class="headerlink" title="一  Github上部署"></a>一  Github上部署</h3><h4 id="1-准备环境："><a href="#1-准备环境：" class="headerlink" title="1 准备环境："></a>1 准备环境：</h4><p>​    有github账户</p>
<p>​    在账户里创建仓库, New repository，仓库名固定格式： <code>你的github账户名.github.io</code></p>
<p>​    git免密登陆（可选，非必须）</p>
<h4 id="2-安装部署插件"><a href="#2-安装部署插件" class="headerlink" title="2  安装部署插件"></a>2  安装部署插件</h4><p>​    安装部署插件deploy-git </p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save</code></pre>
<h4 id="3-Hexo修改根目录配置文件"><a href="#3-Hexo修改根目录配置文件" class="headerlink" title="3  Hexo修改根目录配置文件"></a>3  Hexo修改根目录配置文件</h4><pre class=" language-yml"><code class="language-yml">deploy:
  type: git
  repo: https://github.com/your_github_name/your_github_name.github.io.git
  branch: master</code></pre>
<p>如果配置了免密登录: </p>
<pre><code>git@github.com:yourgithubName/your_github_name.github.io.git</code></pre><p>没有配置请使用：</p>
<pre><code>https://github.com/your_github_name/your_github_name.github.io.git</code></pre><p><code>https</code>开头每次要输入密码，<code>git</code>开头表示是用ssh方式连接。</p>
<h4 id="4-生成并部署"><a href="#4-生成并部署" class="headerlink" title="4  生成并部署"></a>4  生成并部署</h4><pre class=" language-bash"><code class="language-bash">hexo g <span class="token operator">&amp;</span> hexo d</code></pre>
<p>如果没有配置免密登陆，部署的时候可能会用到git的用户名和密码。</p>
<h4 id="5-访问验证"><a href="#5-访问验证" class="headerlink" title="5  访问验证"></a>5  访问验证</h4><p>打开浏览器访问：<a href="https://YourgithubName.github.io" target="_blank" rel="noopener">https://YourgithubName.github.io</a></p>
<p>如我<code>github</code>博客地址：<a href="https://small-rose.github.io">https://small-rose.github.io</a></p>
<h3 id="二-云服务器部署"><a href="#二-云服务器部署" class="headerlink" title="二  云服务器部署"></a>二  云服务器部署</h3><p>部署到云服务有两种方式，一种是利用git仓库配合hooks自动部署更新，另一种是插件的方式，插件的话可以参考如下：</p>
<table>
<thead>
<tr>
<th>插件安装命令</th>
<th>功能</th>
<th>文档</th>
</tr>
</thead>
<tbody><tr>
<td>npm install hexo-deployer-cos –save</td>
<td>hexo上传至腾讯云COS</td>
<td><a href="https://github.com/sdlzhd/hexo-deployer-cos#user-content-options" target="_blank" rel="noopener">https://github.com/sdlzhd/hexo-deployer-cos#user-content-options</a></td>
</tr>
<tr>
<td>npm install hexo-deployer-aliyun –save</td>
<td>hexo上传至阿里云</td>
<td><a href="https://github.com/yedaodao/hexo-deployer-aliyun" target="_blank" rel="noopener">https://github.com/yedaodao/hexo-deployer-aliyun</a></td>
</tr>
</tbody></table>
<h4 id="1-准备环境：-1"><a href="#1-准备环境：-1" class="headerlink" title="1  准备环境："></a>1  准备环境：</h4><p>​    有一台云服务器，本文是腾讯云服务器</p>
<p>​    准备工作大概如下</p>
<pre class=" language-html"><code class="language-html">（1）服务器安装git服务并创建仓库

（2）配置hooks

（3）安装及配置Nginx</code></pre>
<h4 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2  安装git"></a>2  安装git</h4><p>安装命令：</p>
<pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> <span class="token function">git</span> </code></pre>
<p>如果你的服务器不能直接yum安装，可以参考    git安装教程：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span>  /usr/local/src   <span class="token comment" spellcheck="true">#进入你的下载目录           </span>
<span class="token function">wget</span> https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.24.0.tar.gz    <span class="token comment" spellcheck="true">#下载，不能下载就自己上传一下</span>
<span class="token function">tar</span> -zvxf git-2.24.0.tar.gz    <span class="token comment" spellcheck="true">#解压</span>
<span class="token function">cd</span> git-2.24.0                
<span class="token function">make</span> all prefix<span class="token operator">=</span>/usr/local/git    <span class="token comment" spellcheck="true">#编译</span>
<span class="token function">make</span> <span class="token function">install</span> prefix<span class="token operator">=</span>/usr/local/git    <span class="token comment" spellcheck="true">#安装git到指定目录</span>
<span class="token keyword">echo</span> <span class="token string">'export PATH=<span class="token variable">$PATH</span>:/usr/local/git/bin'</span> <span class="token operator">>></span> /etc/bashrc  <span class="token comment" spellcheck="true">#配置环境变量</span>
<span class="token function">source</span> /etc/bashrc       <span class="token comment" spellcheck="true">#刷新环境变量</span></code></pre>
<p>验证Git是否安装成功：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> --version</code></pre>
<p>添加git用户并授权：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">useradd</span> -r -s /bin/bash -c <span class="token string">'git version control'</span> -d /home/git <span class="token function">git</span> 
<span class="token function">passwd</span> <span class="token function">git</span> 
<span class="token function">mkdir</span> -p /home/git  
<span class="token function">chown</span> git:git /home/git </code></pre>
<p>创建仓库：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /home/git/
<span class="token function">git</span> init --bare myHexoBlog.git</code></pre>
<p>如果要配置SSH免登录：</p>
<p>a.客户端生成密钥</p>
<pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"这里换上你的邮箱"</span></code></pre>
<p>然后会出现询问，大概意思如下：</p>
<pre><code>1. 确认秘钥的保存路径（如果不需要改路径则直接回车）；
2. 如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；
3. 创建密码（如果不需要密码则直接回车）；
4. 确认密码；</code></pre><p>要免密登录请输密码的时候回车即可。根据提示找到密钥所在文件：</p>
<pre><code>id_rsa  #私钥
id_rsa.pub  #公钥</code></pre><p>b.服务端导入客户端公钥</p>
<p>在/home/git下已经创建.ssh目录，然后创建authorized_keys文件，并将客户端生成的公钥导入进去。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /home/git/
<span class="token function">mkdir</span> .ssh
<span class="token function">chmod</span> 755 .ssh
<span class="token function">touch</span> .ssh/authorized_keys
<span class="token function">chmod</span> 644 .ssh/authorized_keys</code></pre>
<p>将 <code>id_rsa.pub</code> 文件的内容写入<code>authorized_keys</code></p>
<p>c. 服务端SSH将RSA认证打开</p>
<pre class=" language-bash"><code class="language-bash">vim /etc/ssh/sshd_config</code></pre>
<p>其中三个地方的设置要确认如下：</p>
<pre><code>RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys</code></pre><p>git用户不允许登录shell</p>
<pre class=" language-bash"><code class="language-bash">vim /etc/passwd</code></pre>
<p>将</p>
<pre><code>git:x:502:502::/home/git:/bin/bash</code></pre><p> 改为</p>
<pre><code>git:x:502:502::/home/git:/usr/local/git/bin/git-shell</code></pre><h4 id="3-配置hooks自动部署"><a href="#3-配置hooks自动部署" class="headerlink" title="3 配置hooks自动部署"></a>3 配置hooks自动部署</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /home/hexoBlog
<span class="token function">chown</span> git:git /home/hexoBlog 

<span class="token function">cd</span> /home/hexoBlog
<span class="token function">cd</span> /home/git/myHexoBlog.git/hooks
vim  post-receive  <span class="token comment" spellcheck="true">#创建hooks执行文件</span></code></pre>
<p>配置hooks，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）</p>
<pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">git</span> --work-tree<span class="token operator">=</span>/home/hexoBlog --git-dir<span class="token operator">=</span>/home/git/myHexoBlog.git checkout -f</code></pre>
<p>如果是使用Apache服务,可以直接把work-tree目录指向/var/www/html</p>
<h4 id="4-安装Nginx服务"><a href="#4-安装Nginx服务" class="headerlink" title="4 安装Nginx服务"></a>4 安装Nginx服务</h4><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y nginx</code></pre>
<p>如果你不能直接安装，请先配置安装源</p>
<pre class=" language-bahs"><code class="language-bahs">sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></pre>
<p>启动Nginx</p>
<pre class=" language-bash"><code class="language-bash">systemctl start nginx.service</code></pre>
<p>浏览器输入你的域名或者IP，出现欢迎页面代表安装启动成功。</p>
<p>修改配置：</p>
<pre class=" language-bash"><code class="language-bash">nginx -t  <span class="token comment" spellcheck="true">#查看nginx安装路径 配置文件路径</span>
vim /etc/nginx/nginx.conf</code></pre>
<p>找到server部分</p>
<pre><code>server {
    listen 80 default_server;
    listen [::]:80 default_server;
    root /home/hexoBlog;    #需要修改

    server_name www.zhangxiaocai.cn; #需要修改

    include /etc/nginx/default.d/*.conf;
    location / {
    }
    error_page 404 /404.html;
        location = /40x.html {
    }
}</code></pre><p>修改好之后<code>ESC</code> 输入<code>:wq</code>保存退出。接下来验证配置</p>
<pre class=" language-bash"><code class="language-bash">nginx -t</code></pre>
<p>如果出现以下内容代表配置成功：</p>
<pre class=" language-bash"><code class="language-bash">nginx: the configuration <span class="token function">file</span> /etc/nginx/nginx.conf syntax is ok
nginx: configuration <span class="token function">file</span> /etc/nginx/nginx.conf <span class="token function">test</span> is successful</code></pre>
<p>重新加载配置或重启nginx服务</p>
<pre class=" language-bash"><code class="language-bash">nginx -s reload</code></pre>
<p>更多<code>Nginx</code>相关内容，访问<code>Nginx</code></p>
<h4 id="5-本地配置修改"><a href="#5-本地配置修改" class="headerlink" title="5 本地配置修改"></a>5 本地配置修改</h4><p>修改项目根目录的配置文件</p>
<pre><code>deploy:
    type: git
    repo: git@你的云服务器的IP地址:/home/git/myHexoBlog.git
    branch: master</code></pre><p>清理-生成-部署</p>
<pre class=" language-bash"><code class="language-bash">hexo clean <span class="token operator">&amp;</span> hexo g <span class="token operator">&amp;</span> hexo d</code></pre>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java 查漏补缺-jdk版本版本变化补充学习</title>
    <url>/posts/80dc9555.html</url>
    <content><![CDATA[<h2 id="JDK各个版本的变化补充学习"><a href="#JDK各个版本的变化补充学习" class="headerlink" title="JDK各个版本的变化补充学习"></a>JDK各个版本的变化补充学习</h2><h3 id="JDK1-5"><a href="#JDK1-5" class="headerlink" title="JDK1.5"></a>JDK1.5</h3><h4 id="1-类包装器"><a href="#1-类包装器" class="headerlink" title="1. 类包装器."></a>1. 类包装器.</h4><p>自动装箱与拆箱。实际操作中比较常见。</p>
<h4 id="2-枚举类型使用。"><a href="#2-枚举类型使用。" class="headerlink" title="2. 枚举类型使用。"></a>2. 枚举类型使用。</h4><p>实际中按需使用。我也在实际中使用过，需要注意的是使用枚举类型与扩展性的问题，比如性别永远只有”男”和”女”，不会增加扩展第三种，那么枚举是推荐使用的，如果枚举内容是扩展的，不建议使用枚举类型。</p>
<h4 id="3-静态方法倒入。"><a href="#3-静态方法倒入。" class="headerlink" title="3. 静态方法倒入。"></a>3. 静态方法倒入。</h4><p>说实话，这个我在实际中真没有用过。语法<code>import static</code><br>大致分两种：<br>   （1）导入指定类的某个静态成员变量、方法。<br>   （2）导入指定类的全部的静态成员变量、方法。</p>
<p>示例如下：</p>
<pre class=" language-JAVA"><code class="language-JAVA">/*
 * 使用import static,导入java.lang.System下的out这个静态成员变量
 */
import static java.lang.System.out;

public class ImptTest {

    public static void main(String[] args) {
        out.println("hello world");
    }
}</code></pre>
<p>导入静态方法示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
 * 使用import static,导入java.lang.Math这个类中的round方法
 */</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>round<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImptTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//out.println("hello world");</span>
        <span class="token function">round</span><span class="token punctuation">(</span><span class="token number">123.123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>导入全部静态成员、静态方法示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
 * 像这样使用.*,则表示类中所有的静态成员变量和静态方法都被导入了
 */</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>System<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>*<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImptTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="4-可变参数使用。"><a href="#4-可变参数使用。" class="headerlink" title="4. 可变参数使用。"></a>4. 可变参数使用。</h4><p>该特征在实际中使用过，实用性还是非常不错的。</p>
<p>主要特征：<br>（1）一个方法中只能指定一个可变参数，<br>（2）可变参数必须是方法的最后一个参数。<br>（3）可变参数类型必须一致.<br>（4）拥有可变参数的方法可以被重载，在调用方法的时，如果能够和固定参数的方法匹配，也能够与可变长参数的方法匹配，则会调用固定参数的方法。<br>（5）被调用的方法不允许和两个可变参数匹配，否则出现错误。</p>
<p>调用特点：<br>（1）可以不写参数，即传入空参。<br>（2）可以直接在里边写入参数，参数间用逗号隔开；<br>（3）可变参数兼容数组，数组不能兼容可变参数；<br>（4）注意参数里的null<br>如示例：</p>
<pre class=" language-JAVA"><code class="language-JAVA">public static void say(String...names) { 
    for(String name : names) {
        System.out.print(name + ",hello! "); 
    }
}</code></pre>
<p>调用示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String<span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token string">"cat"</span><span class="token punctuation">,</span> <span class="token string">"dog"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不传递参数</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">,</span> <span class="token string">"cat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传递多个参数</span>
    <span class="token function">say</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可传递数组</span>
<span class="token punctuation">}</span></code></pre>
<p>反面定义示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>names<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span>String name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">",hello! "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>names <span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>names<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">//不允许出现多个可变参数</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span>String sex<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>names<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
     <span class="token comment" spellcheck="true">//调用时与第一个say方法冲突，不会被调用</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>names<span class="token punctuation">,</span>Sring date<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      <span class="token comment" spellcheck="true">//可变参数必须是最后一个参数</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="5-内省-Introspector"><a href="#5-内省-Introspector" class="headerlink" title="5. 内省(Introspector)"></a>5. 内省(Introspector)</h4><p>内省(Introspector) 是Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。</p>
<p>JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。</p>
<p>实际使用引入apache的BeanUtils工具包：<br>　　 BeanUtils工具包：下载：<a href="http://commons.apache.org/beanutils/" target="_blank" rel="noopener">http://commons.apache.org/beanutils/</a>　<br>    (应用的时候还需要一个logging包 <a href="http://commons.apache.org/logging/" target="_blank" rel="noopener">http://commons.apache.org/logging/</a>)</p>
<h4 id="6-泛型-Generic"><a href="#6-泛型-Generic" class="headerlink" title="6.泛型(Generic)."></a>6.泛型(Generic).</h4><p>简单的说就是可以指定集合里元素的类型。</p>
<h4 id="7-for-each循环。"><a href="#7-for-each循环。" class="headerlink" title="7. for-each循环。"></a>7. for-each循环。</h4><p>比较常用。语法<code>for(类型 变量 ： 集合){}</code></p>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk8<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForEachTest</span> <span class="token punctuation">{</span>

     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> JAXBException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>
         String<span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"tom"</span><span class="token punctuation">,</span><span class="token string">"jerry"</span><span class="token punctuation">,</span><span class="token string">"mike"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
          <span class="token keyword">for</span><span class="token punctuation">(</span>String str <span class="token operator">:</span> names<span class="token punctuation">)</span><span class="token punctuation">{</span>
              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"str:"</span><span class="token operator">+</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h3><h4 id="主要变化"><a href="#主要变化" class="headerlink" title="主要变化"></a>主要变化</h4><p>1、引入了一个支持脚本引擎的新框架Scripting for the Java Platform (JSR223脚本引擎)</p>
<p>2、UI的增强</p>
<p>3、对WebService支持的增强（JAX-WS2.0和JAXB2.0）</p>
<p>4、一系列新的安全相关的增强</p>
<p>5、JDBC4.0</p>
<p>6、Compiler API （JSR199）<br>支持动态编译。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaCompilerAPICompiler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">compile</span><span class="token punctuation">(</span>Path src<span class="token punctuation">,</span> Path output<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        JavaCompiler compiler <span class="token operator">=</span> ToolProvider<span class="token punctuation">.</span><span class="token function">getSystemJavaCompiler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span>StandardJavaFileManager fileManager <span class="token operator">=</span> compiler<span class="token punctuation">.</span><span class="token function">getStandardFileManager</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Iterable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">JavaFileObject</span><span class="token operator">></span> compilationUnits <span class="token operator">=</span> fileManager<span class="token punctuation">.</span><span class="token function">getJavaFileObjects</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Iterable<span class="token operator">&lt;</span>String<span class="token operator">></span> options <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"-d"</span><span class="token punctuation">,</span> output<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            JavaCompiler<span class="token punctuation">.</span>CompilationTask task <span class="token operator">=</span> compiler<span class="token punctuation">.</span><span class="token function">getTask</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> fileManager<span class="token punctuation">,</span> null<span class="token punctuation">,</span> options<span class="token punctuation">,</span> null<span class="token punctuation">,</span> compilationUnits<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">boolean</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>7、通用的Annotations支持 （JSR269）<br>一部分是进行注解处理的javax.annotation.processing。<br>另一部分是对程序的静态结构进行建模的javax.lang.model。</p>
<h4 id="JAXB2来实现对象与XML之间的映射"><a href="#JAXB2来实现对象与XML之间的映射" class="headerlink" title="JAXB2来实现对象与XML之间的映射"></a>JAXB2来实现对象与XML之间的映射</h4><p>JAXB:<br>    是Java Architecture for XML Binding的缩写，可以将一个Java对象和XML格式对象相互转换。JAXB2在底层是用StAX(JSR 173)来处理XML文档。</p>
<p>StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。</p>
<p>StAX 的来历 ：在JAXP1.3(JSR 206)有两种处理XML文档的方法:DOM(Document Object Model)和SAX(Simple API for XML).</p>
<p>由 于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX，所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本). JDK6里面JAXP的版本就是1.4. 。</p>
<p>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件，然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；</p>
<p>SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。<br>更多学习可以参考1：<a href="https://blog.csdn.net/visant/java/article/details/79778967" target="_blank" rel="noopener">https://blog.csdn.net/visant/java/article/details/79778967</a><br>更多学习可以参考2：<a href="http://www.blogjava.net/hsith/archive/2006/06/29/55817.html" target="_blank" rel="noopener">http://www.blogjava.net/hsith/archive/2006/06/29/55817.html</a></p>
<p>示例代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk5<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileReader<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileWriter<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Calendar<span class="token punctuation">;</span>

<span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>JAXBContext<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>JAXBException<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>Marshaller<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>Unmarshaller<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Jaxb2Test</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> JAXBException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>
        JAXBContext context <span class="token operator">=</span> JAXBContext<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//下面代码演示将对象转变为xml</span>
        Marshaller m <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">createMarshaller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Address address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token string">"China"</span><span class="token punctuation">,</span><span class="token string">"Shanghai"</span><span class="token punctuation">,</span><span class="token string">"Shanghai"</span><span class="token punctuation">,</span><span class="token string">" xuhui"</span><span class="token punctuation">,</span><span class="token string">"100080"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"小菜"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span>Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
        FileWriter fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"D:\\user.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        m<span class="token punctuation">.</span><span class="token function">marshal</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span>fw<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//下面代码演示将上面生成的xml转换为对象</span>
        FileReader fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"D:\user.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Unmarshaller um <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">createUnmarshaller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        User user2 <span class="token operator">=</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span>um<span class="token punctuation">.</span><span class="token function">unmarshal</span><span class="token punctuation">(</span>fr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Country:"</span><span class="token operator">+</span>user2<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCountry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入China</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>user类:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk5<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Calendar<span class="token punctuation">;</span>

<span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>XmlElement<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>XmlRootElement<span class="token punctuation">;</span>

<span class="token annotation punctuation">@XmlRootElement</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@XmlElement</span>
     String name<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@XmlElement</span>
     <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@XmlElement</span>
    Calendar birthDay<span class="token punctuation">;</span> 
    <span class="token annotation punctuation">@XmlElement</span>
     Address address<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> Calendar birthDay<span class="token punctuation">,</span> Address address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>birthDay <span class="token operator">=</span> birthDay<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Address <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> address<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>Address类</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk5<span class="token punctuation">;</span>

<span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>XmlAttribute<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>XmlElement<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@XmlAttribute</span>
    String country<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@XmlElement</span>
    String province<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@XmlElement</span>
    String city<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@XmlElement</span>
    String street<span class="token punctuation">;</span>

    String houseNo<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 由于没有添加@XmlElement,所以该元素不会出现在输出的xml中</span>

    <span class="token keyword">public</span> <span class="token function">Address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Address</span><span class="token punctuation">(</span>String country<span class="token punctuation">,</span> String province<span class="token punctuation">,</span> String city<span class="token punctuation">,</span> String street<span class="token punctuation">,</span> String houseNo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>country <span class="token operator">=</span> country<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>province <span class="token operator">=</span> province<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>street <span class="token operator">=</span> street<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>houseNo <span class="token operator">=</span> houseNo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getCountry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> country<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>转换的XML内容：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>小菜<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>age</span><span class="token punctuation">></span></span>18<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>age</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>birthDay</span><span class="token punctuation">></span></span>2020-02-24T22:09:03.019+08:00<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>birthDay</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address</span> <span class="token attr-name">country</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>China<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>province</span><span class="token punctuation">></span></span>Shanghai<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>province</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>Shanghai<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>street</span><span class="token punctuation">></span></span> xuhui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>street</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>address</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span></code></pre>
<p>注意@XmlAccessorType注解。<br>另Castor实现XML与Java的互转 <a href="http://www.castor.org/" target="_blank" rel="noopener">http://www.castor.org/</a></p>
<p>另外还有 Compiler API，Http Server API，插入式注解处理API(Pluggable Annotation Processing API)，对脚本语言的支持如: ruby, groovy, javascript，Common Annotations 涉及内容较多篇幅较长，后续单独学习。</p>
<h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><h4 id="1-switch中可以使用字符串。"><a href="#1-switch中可以使用字符串。" class="headerlink" title="1. switch中可以使用字符串。"></a>1. switch中可以使用字符串。</h4><pre><code>非常实用的。</code></pre><h4 id="2-泛型实例化类型自动推断。"><a href="#2-泛型实例化类型自动推断。" class="headerlink" title="2. 泛型实例化类型自动推断。"></a>2. 泛型实例化类型自动推断。</h4><p>指定类型:</p>
<pre class=" language-java"><code class="language-java">    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<p>自动推断:</p>
<pre class=" language-java"><code class="language-java">    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<h4 id="3-数值字面量改进"><a href="#3-数值字面量改进" class="headerlink" title="3. 数值字面量改进."></a>3. 数值字面量改进.</h4><p>数字前面加”0B”或”0b”表示二进制数。如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> binary <span class="token operator">=</span> <span class="token number">0b10011001</span><span class="token punctuation">;</span></code></pre>
<p>数值中可以添加”_”。 如： </p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> one_million <span class="token operator">=</span> 1_000_000<span class="token punctuation">;</span></code></pre>
<h4 id="4-try-with-resources语句。"><a href="#4-try-with-resources语句。" class="headerlink" title="4. try-with-resources语句。"></a>4. try-with-resources语句。</h4><p>try-with-resources语句中会被自动调用，用于自动释放资源。自动关闭接口AutoCloseable。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span>OutputStream fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:/file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 不需要再次指明fos.close();</span>
<span class="token punctuation">}</span></code></pre>
<ol start="5">
<li>优化异常处理</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>
   result <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalArgumentException</span> <span class="token operator">|</span> IllegalAccessException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><h4 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h4><p>Lambda表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数进行传递。</p>
<p>Lambda 表达式的标准格式：</p>
<pre><code>(参数类型 参数名) -&gt; {
    方法体;
    return 返回值;
}</code></pre><p>Lambda 表达式的省略规则：<br>    1. 小括号中的参数类型可以省略。<br>    2. 如果小括号中只有一个参数，那么可以省略小括号。<br>    3. 如果大括号中只有一条语句，那么可以省略大括号，return，分号。<br>其他注意：不允许声明一个与局部变量同名的参数或者局部变量。<br>四种方法引用类型<br>| 类型          | 示例                                      |<br>|—————|——————————————-|<br>| 引用静态方法 |    ContainingClass::staticMethodName |<br>| 引用某个对象的实例方法     |containingObject::instanceMethodName |<br>| 引用某个类型的任意对象的实例方法 |    ContainingType::methodName |<br>| 引用构造方法 |    ClassName::new  |</p>
<pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">// 使用 java 7 排序</span>
   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sortJava7</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> names<span class="token punctuation">)</span><span class="token punctuation">{</span>   
      Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token annotation punctuation">@Override</span>
         <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment" spellcheck="true">// 使用 java 8 排序</span>
   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sortJava8</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> names<span class="token punctuation">)</span><span class="token punctuation">{</span>
      Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span></code></pre>
<p>Lambda 使用条件</p>
<p>Lambda 表达式的使用前提:</p>
<pre><code>必须有接口（不能是抽象类），接口中有且仅有一个需要被重写的抽象方法。
必须支持上下文推导，要能够推导出来 Lambda 表达式表示的是哪个接口中的内容。 
可以使用接口当做参数，然后传递 Lambda 表达式(常用)，也可以将 Lambda 表达式赋值给一个接口类型的变量。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk8<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{</span>

    <span class="token keyword">void</span> <span class="token function">printStr</span><span class="token punctuation">(</span>String string<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span>  <span class="token class-name">LambdaTest</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//使用接口当做参数</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span>MyInterface m<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//m = s -> System.out.println(s)</span>
        m<span class="token punctuation">.</span><span class="token function">printStr</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//使用接口当做参数，然后传递Lambda表达式。</span>
        <span class="token comment" spellcheck="true">//method(s -> System.out.println(s));</span>

        <span class="token comment" spellcheck="true">//使用匿名内部类方式创建对象</span>
        <span class="token comment" spellcheck="true">/*
        MyInterface m = new MyInterface() {
            @Override
            public void printStr(String str) {
                System.out.println(str);
            }
        };
        */</span>
        <span class="token comment" spellcheck="true">//Lambda 表达式赋值给接口类型变量</span>
        MyInterface m <span class="token operator">=</span> str <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        m<span class="token punctuation">.</span><span class="token function">printStr</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment" spellcheck="true">// 1.1使用匿名内部类  </span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token annotation punctuation">@Override</span>  
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello world !"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

        <span class="token comment" spellcheck="true">// 1.2使用 lambda expression  </span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello world !"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

        <span class="token comment" spellcheck="true">// 2.1使用匿名内部类  </span>
        Runnable race1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token annotation punctuation">@Override</span>  
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello world !"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>  

        <span class="token comment" spellcheck="true">// 2.2使用 lambda expression  </span>
        Runnable race2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello world !"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

        <span class="token comment" spellcheck="true">// 直接调用 run 方法(没开新线程哦!)  </span>
        race1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        race2<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h4><p>JDK 8之前就有的函数式接口（使用@FunctionalInterface定义 ）</p>
<pre class=" language-java"><code class="language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Runnable

java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Callable

java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>PrivilegedAction

java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Comparator

java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileFilter

java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>PathMatcher 

java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler

java<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>PropertyChangeListener

java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span>event<span class="token punctuation">.</span>ActionListener  

javax<span class="token punctuation">.</span>swing<span class="token punctuation">.</span>event<span class="token punctuation">.</span>ChangeListener </code></pre>
<h4 id="3-接口默认方法与静态方法"><a href="#3-接口默认方法与静态方法" class="headerlink" title="3. 接口默认方法与静态方法"></a>3. 接口默认方法与静态方法</h4><p>接口默认方法，用<code>default</code>关键字。<br>接口静态方法，用<code>static</code>关键字：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk8<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{</span>

    <span class="token keyword">void</span> <span class="token function">printStr</span><span class="token punctuation">(</span>String string<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" this is default method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isNull</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Interface Null Check"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">return</span> str <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> 
<span class="token punctuation">}</span></code></pre>
<p>注意：类继承多个Interface接口同名方法(如show())时，必须在子类中@Override重写父类show()方法。</p>
<p>特性说明：</p>
<pre><code>1,函数式接口仅仅只有一个方法(非默认或静态方法)，用于显示转换成ladbma表达式。
2, java.lang.Runnable接口 java.util.concurrent.Callable接口是两个最典型的函数式接口。
3.如果一个函数式接口添加一个普通方法，就变成了非函数式接口（一般定义的接口）。
4.Jdk8 规范里添加了注解@FunctionalInterface来限制函数式接口不能修改为普通的接口.</code></pre><p>jdk8新增了四个重要的函数式接口：函数形接口 、供给形接口、消费型接口、判断型接口 </p>
<h4 id="4-日期时间的API"><a href="#4-日期时间的API" class="headerlink" title="4. 日期时间的API."></a>4. 日期时间的API.</h4><p>新的时间及日期API类在java.time包中，不可变且线程安全的。<br>Instant获取时间戳, LocalDate只处理日期、LocalTime只处理时间,LocalDateTime只处理日期时间，ZonedDateTime包含时区的日期时间<br>TemporalAdjusters 日期调整<br>DateTimeFormatter 替代之前版本的SimpleDateFormat类<br>YearMonth年月组合,MonthDay月日组合<br>Clockdeng</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk8<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>Clock<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDate<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDateTime<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalTime<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>System<span class="token punctuation">.</span>out<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DateTimeTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

         LocalDate date <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         LocalTime time <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>Clock<span class="token punctuation">.</span><span class="token function">systemUTC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         LocalDateTime dttm <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" date = "</span> <span class="token operator">+</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" time = "</span> <span class="token operator">+</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>
         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" dttm = "</span> <span class="token operator">+</span>dttm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>控制台输出：</p>
<pre><code> date = 2020-05-31
 time = 16:29:41.010
 dttm = 2020-05-31T00:29:41.010</code></pre><p>更多内容参考<a href="/post/d0e15f60.html">《java 查漏补缺-java8里的日期时间API》</a></p>
<h4 id="5-Optional-类"><a href="#5-Optional-类" class="headerlink" title="5. Optional 类"></a>5. Optional 类</h4><p>Optional 是个容器，它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。比较友好的的解决空指针异常。Optional.of()或者Optional.ofNullable()：创建Optional对象，差别在于of不允许参数是null，而ofNullable则无限制。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk8<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Optional<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>System<span class="token punctuation">.</span>out<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OptionalTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 参数不能是null</span>
        Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> opt1 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 参数可以是null</span>
        Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> opt2 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 参数可以是非null</span>
        Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> opt3 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> opt4 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt4<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// orElse</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt1<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt4<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"1000"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"1000"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>

        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional1<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="6-Nashorn-JavaScript引擎。"><a href="#6-Nashorn-JavaScript引擎。" class="headerlink" title="6. Nashorn, JavaScript引擎。"></a>6. Nashorn, JavaScript引擎。</h4><p>Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk8<span class="token punctuation">;</span>

<span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptEngine<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptEngineManager<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NashornTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ScriptException <span class="token punctuation">{</span>
        ScriptEngine engine <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEngineByName</span><span class="token punctuation">(</span><span class="token string">"nashorn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        engine<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"print('Hello World!');"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>Nashorn JavaScript基于ECMAScript 5.1，但是它的后续版本会对ES6提供支持：<br>Nashorn的当前策略遵循ECMAScript规范。当我们在JDK8中发布它时，它将基于ECMAScript 5.1。Nashorn未来的主要发布基于ECMAScript 6。<br>Nashorn定义了大量对ECMAScript标准的语言和API扩展。但是首先让我们看一看Java和JavaScript代码如何交互。</p>
<p>注意：</p>
<p>该引擎在java11是被弃用。ECMAScript语言标准的快速发展，维护Nashorn引擎变得越发挑战，因此该引擎将在Java中废弃。<br>两个模块将会被最终弃用，被标注为@Deprecated(forRemoval=true)。</p>
<p>jdk.scripting.nashorn模块，包含dk.nashorn.api.scripting和jdk.nashorn.api.tree包。jdk.scripting.nashorn.shell模块，包含jjs工具，运行jjs将显示警告。</p>
<p>需要注意的是，java.scripting模块中javax.script包下的相关API不受影响。</p>
<h4 id="7-新工具"><a href="#7-新工具" class="headerlink" title="7. 新工具"></a>7. 新工具</h4><p>新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。<br>Nashorn引擎jjs：<br>jjs是一个基于标准Nashorn引擎的命令行工具，可以接受js源码并执行。<br>类依赖分析器jdeps：<br>jdeps是一个命令行工具，它可以展示包层级和类层级的Java类依赖关系，它以.class文件、目录或者Jar文件为输入，然后会把依赖关系输出到控制台。<br>JVM的新特性<br>使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用<code>-XX:MetaSpaceSize</code>和<code>-XX:MaxMetaspaceSize</code>代替原来的<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>。</p>
<h4 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h4><p>若遇到随时补充学习。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建静态博客（二）——创建页面</title>
    <url>/posts/c1358fc8.html</url>
    <content><![CDATA[<p>本文记录将hexo博客创建页面相关操作操作。</p>
<a id="more"></a>

<p>作者：阿兰那</p>
<h2 id="1-创建链接页面的基本命令"><a href="#1-创建链接页面的基本命令" class="headerlink" title="1.创建链接页面的基本命令"></a>1.创建链接页面的基本命令</h2><font color=red>
```
hexo new page  yourpagename
```
</font>

<h4 id="2-创建about页面"><a href="#2-创建about页面" class="headerlink" title="2.创建about页面"></a>2.创建about页面</h4><pre><code>hexo new page about</code></pre><p>修改source/about/index.md文件即可。文件内可以使用markdown或html语法。</p>
<h4 id="3-创建分类"><a href="#3-创建分类" class="headerlink" title="3.创建分类"></a>3.创建分类</h4><pre><code>hexo new page categories   //创建分类</code></pre><p>修改source/categories/index.md文件即可.<br>补充红色字体内容： <font color=red><code>type: &quot;categories&quot;</code></font></p>
<pre><code>---
title: categories
date: 2020-05-14 21:51:42
type: categories
---</code></pre><p>那么在写文章的时候就可以在头部使用分类了，如：</p>
<pre><code>---
title: Hexo搭建静态博客及踩坑问题
date: 2020-05-13
categories: Hexo
---
 this is my article ...
</code></pre><h4 id="4-创建标签"><a href="#4-创建标签" class="headerlink" title="4.创建标签"></a>4.创建标签</h4><pre><code>hexo new page tags         //创建标签</code></pre><p>修改source/tags/index.md文件即可:<br>补充红色字体内容： <font color=red><code>type: &quot;tags&quot;</code></font></p>
<pre><code>---
title: tags
date: 2020-05-14 21:51:42
type: tags
---</code></pre><p>那么在写文章的时候就可以在头部使用标签了，如：</p>
<pre><code>---
title: Hexo搭建静态博客及踩坑问题
date: 2020-05-13
categories: Hexo
tags: Hexo
---
 this is my article ...
</code></pre><p>是不是很简单呢？</p>
<p>如有问题请参考本系列：Hexo搭建静态博客（五）——踩坑问题</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java 查漏补缺-Java8 中的 Optional</title>
    <url>/posts/e748f349.html</url>
    <content><![CDATA[<h2 id="Java8-中的-Optional"><a href="#Java8-中的-Optional" class="headerlink" title="Java8 中的 Optional"></a>Java8 中的 Optional</h2><h3 id="关于Optional"><a href="#关于Optional" class="headerlink" title="关于Optional"></a>关于Optional</h3><p>该类位于java.util下，属于final类，其实就是一个工具类。<br>主要是为了预防运行时抛出 <code>NullPointException</code></p>
<p>使用示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>xiaocai<span class="token punctuation">.</span>cn<span class="token punctuation">.</span>optional<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Optional<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OptionalTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> optionalS <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"zhangxiaocai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optionalS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">//输出： zhangxiaocai</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h3 id="Optional主要方法API"><a href="#Optional主要方法API" class="headerlink" title="Optional主要方法API"></a>Optional主要方法API</h3><p>|方法API     | 说明 |<br>|of(T value)     | 把指定的值封装为Optional对象，如果指定的值为null，则抛出NullPointerException |<br>|ofNullable(T value)  | 把指定的值封装为Optional对象，如果指定的值为null，则创建一个空的Optional对象 |<br>|get()     | 如果创建的Optional中有值存在，则返回此值，否则抛出NoSuchElementException |<br>|isPresent()     | 如果创建的Optional中的值存在，返回true，否则返回false |<br>|ifPresent(Consumer&lt;? super T&gt; consumer)     | 如果创建的Optional中的值存在，则执行该方法的调用，否则什么也不做 |<br>|orElse(T value)     | 如果创建的Optional中有值存在，则返回此值，否则返回一个默认值 |<br>|orElseGet(Supplier&lt;? extends T&gt; other)     | 如果创建的Optional中有值存在，则返回此值，否则返回一个由Supplier接口生成的值 |<br>|orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)    | 如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常 |<br>|empty()     | 创建一个空的Optional对象 |<br>|orElseThrow     | 如果创建的Optional中有值存在，则返回此值，否则抛出一个由指定的Supplier接口生成的异常 |<br>|filter(Predicate&lt;? super <T> predicate)     | 如果创建的Optional中的值满足filter中的条件，则返回包含该值的Optional对象，否则返回一个空的Optional对象 |<br>|map(Function&lt;? super T,? extends U&gt; mapper)     | 如果创建的Optional中的值存在，对该值执行提供的Function函数调用 |<br>|flagMap(Function&lt;? super T,Optional<U>&gt; mapper)     | 如果创建的Optional中的值存在，就对该值执行提供的Function函数调用，返回一个Optional类型的值，否则就返回一个空的Optional对象 |</p>
<h3 id="普通思维实例演示"><a href="#普通思维实例演示" class="headerlink" title="普通思维实例演示"></a>普通思维实例演示</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>xiaocai<span class="token punctuation">.</span>cn<span class="token punctuation">.</span>optional<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Optional<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>System<span class="token punctuation">.</span>out<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OptionalTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> optionalS <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"zhangxiaocai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optionalS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


         UserModel user <span class="token operator">=</span> null<span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">//Optional&lt;UserModel> userOption1 = Optional.of(user);//会抛异常</span>
         <span class="token comment" spellcheck="true">//out.println(userOption1.get());</span>
         Optional<span class="token operator">&lt;</span>UserModel<span class="token operator">></span> userOption2 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不会抛异常</span>
         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userOption2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用的时候会抛异常，因此调用需要先判断</span>


         user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"xiaocai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         user<span class="token punctuation">.</span><span class="token function">setEmail</span><span class="token punctuation">(</span><span class="token string">"small-rose@qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">//即使使用了之前的变量名，依旧是一个新的对象</span>
         userOption2 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userOption2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token keyword">if</span><span class="token punctuation">(</span>userOption2<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userOption2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
             Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> uid <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>userOption2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token keyword">if</span><span class="token punctuation">(</span>uid<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                 out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user  id is "</span><span class="token operator">+</span>uid<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span>
             Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> email <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>userOption2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token keyword">if</span><span class="token punctuation">(</span>email<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                 out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"you can send mail to "</span><span class="token operator">+</span>email<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span>

             <span class="token comment" spellcheck="true">//Optional.orElse - 如果值存在，返回它，否则返回提供的默认值</span>
             Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> nameopt <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>userOption2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             String name <span class="token operator">=</span> nameopt<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"zhangxiaocai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user name is "</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
             out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user is null "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h3 id="函数式编程演示"><a href="#函数式编程演示" class="headerlink" title="函数式编程演示"></a>函数式编程演示</h3><p>函数式编程注意方法API中传的参数。<br>留意带参数的几个API:<br><code>ifPresent(Consumer&lt;? super T&gt; consumer</code>、<br><code>orElseGet(Supplier&lt;? extends T&gt; other)</code><br><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code><br><code>map(Function&lt;? super T,? extends U&gt; mapper)</code><br><code>flagMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)</code></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>xiaocai<span class="token punctuation">.</span>cn<span class="token punctuation">.</span>optional<span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>System<span class="token punctuation">.</span>out<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Optional<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Supplier<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OptionalFuncTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

         UserModel user1 <span class="token operator">=</span> null <span class="token punctuation">;</span>
         Optional<span class="token operator">&lt;</span>UserModel<span class="token operator">></span> userop1 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">//如果user1为null，就实例化一个</span>
         <span class="token comment" spellcheck="true">//orElse 与之前相同 写法1</span>
         UserModel defuser1 <span class="token operator">=</span>userop1<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UserModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>defuser1<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">//函数式 orElseGet 写法2</span>
         UserModel defuser2 <span class="token operator">=</span> userop1<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">UserModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">//if(userop1.isPresent()){ defuser2 = userop1.get(); }else{ defuser2 = new UserModel(); }</span>

         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>defuser2<span class="token punctuation">)</span><span class="token punctuation">;</span>

         UserModel user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"xiaocai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         user<span class="token punctuation">.</span><span class="token function">setEmail</span><span class="token punctuation">(</span><span class="token string">"small-rose@qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


         Optional<span class="token operator">&lt;</span>UserModel<span class="token operator">></span> userop2 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">//如果 userop 里的对象不为空，则取出名称并打印</span>
         <span class="token comment" spellcheck="true">//函数式ifPresent 是无返回值的 Consumer消费型接口</span>
         userop2<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>u <span class="token operator">-</span><span class="token operator">></span>  out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">// if(userop2.isPresent()){ out.println(userop2.get().getName()); }</span>

         <span class="token comment" spellcheck="true">//user1如果是空的，就实例化一个，但是名称也是空的，为了测试orElseGet</span>
         Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> nameop <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>userop1<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">UserModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">//函数式orElseGet 是有返回值的 Supplier供给型接口</span>
         String userName <span class="token operator">=</span> nameop<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"zhangxiaocai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">// if(nameop.isPresent()){ userName = nameop.get(); }else{ userName = "zhangxiaocai"; }</span>

         out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user name is "</span> <span class="token operator">+</span>userName<span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">//如果要求不允许随便实例化怎么办呢？那就可以判断，是否为空，若为空抛出异常即可</span>
         userop1<span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span>IllegalArgumentException<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// userop2.map(  uOptionalFuncTest::sendEmail (u));</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sendEmail</span><span class="token punctuation">(</span>UserModel u<span class="token punctuation">)</span><span class="token punctuation">{</span>

        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" send email to "</span> <span class="token operator">+</span> u<span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习导航（第三版）</title>
    <url>/posts/2a1a7c1f.html</url>
    <content><![CDATA[<pre><code>本文记录关于深入理解JVM（第三版）相关学习导航笔记。</code></pre><h2 id="JVM学习导航"><a href="#JVM学习导航" class="headerlink" title="JVM学习导航"></a>JVM学习导航</h2><p>###一 概况</p>
<h4 id="1-java发现历程"><a href="#1-java发现历程" class="headerlink" title="1. java发现历程"></a>1. java发现历程</h4><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/java_tech_sys_1.jpg" alt="java技术体系"></p>
<h4 id="2-java技术体系"><a href="#2-java技术体系" class="headerlink" title="2. java技术体系"></a>2. java技术体系</h4><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/java_tech_sys_1.jpg" alt="java技术体系"></p>
<p>###二 JVM主要内容</p>
<h4 id="1-JVM内存自动管理中的的内存结构。"><a href="#1-JVM内存自动管理中的的内存结构。" class="headerlink" title="1. JVM内存自动管理中的的内存结构。"></a>1. JVM内存自动管理中的的内存结构。</h4><pre><code>程序计数器
java堆（Heap）
方法区
虚拟机栈
本地方法栈

SOF,OOM</code></pre><h4 id="2-JVM中对象的创建过程"><a href="#2-JVM中对象的创建过程" class="headerlink" title="2. JVM中对象的创建过程"></a>2. JVM中对象的创建过程</h4><pre><code>检查堆中的类符号
检查类加载
分配新对象内存空间——指针碰撞，空闲列表
初始化零值
执行&lt;init&gt;()方法</code></pre><h4 id="3-垃圾收集器算法"><a href="#3-垃圾收集器算法" class="headerlink" title="3. 垃圾收集器算法"></a>3. 垃圾收集器算法</h4><p>   分代回收理论<br>   标记——清除算法<br>   标记——复制算法<br>   标记——整理算法<br>   半复制算法</p>
<h4 id="4-常见的垃圾收集器"><a href="#4-常见的垃圾收集器" class="headerlink" title="4. 常见的垃圾收集器"></a>4. 常见的垃圾收集器</h4><pre><code>Serial收集器
ParNew收集器
Parallel Scavenge收集器
Serial Old收集器
Parallel Old收集器
CMS收集器
Garbage First收集器 (Region布局)
ZGC (Region/ZPage布局)
Shenandah (Region布局)</code></pre><h4 id="5-低延迟垃圾收集器"><a href="#5-低延迟垃圾收集器" class="headerlink" title="5. 低延迟垃圾收集器"></a>5. 低延迟垃圾收集器</h4><pre><code>Shenandoah收集器
ZGC收集器</code></pre><h4 id="6-内存分配回收策略"><a href="#6-内存分配回收策略" class="headerlink" title="6. 内存分配回收策略"></a>6. 内存分配回收策略</h4><pre><code>对象优先在Eden分配
大对象直接进入老年代
长期存活的对象将进入老年代
动态对象年龄判定
空间分配担保</code></pre><h4 id="7-性能监控、故障处理工具"><a href="#7-性能监控、故障处理工具" class="headerlink" title="7. 性能监控、故障处理工具"></a>7. 性能监控、故障处理工具</h4><pre><code>基础故障处理工具
可视化故障处理工具
Hotspot虚拟机插件及工具</code></pre><h4 id="8-调优分析学习"><a href="#8-调优分析学习" class="headerlink" title="8. 调优分析学习"></a>8. 调优分析学习</h4><h4 id="9-JVM类文件结构"><a href="#9-JVM类文件结构" class="headerlink" title="9. JVM类文件结构"></a>9. JVM类文件结构</h4><pre><code>魔数、版本信息
常量池
访问标志
类索引、父类索引、接口类索引集合
字段表集合
方法表集合
属性表集合</code></pre><h4 id="10-JVM字节码指令"><a href="#10-JVM字节码指令" class="headerlink" title="10. JVM字节码指令"></a>10. JVM字节码指令</h4><pre><code>字节码与数据类型
加载和存储指令
运算指令
类型转换指令
对象创建与访问
操作数栈
转移控制指令
方法调用与返回
异常指令
同步指令</code></pre><h4 id="11-JVM类加载机制"><a href="#11-JVM类加载机制" class="headerlink" title="11. JVM类加载机制"></a>11. JVM类加载机制</h4><pre><code>加载
连接（ 验证 - 准备- 解析）
初始化
使用
卸载

类对象与数组对象加载
类的比较
双亲委派模型工作过程
双亲委派模型破坏</code></pre><h4 id="12-JVM字节码执行引擎"><a href="#12-JVM字节码执行引擎" class="headerlink" title="12. JVM字节码执行引擎"></a>12. JVM字节码执行引擎</h4><table>
<thead>
<tr>
<th>编号</th>
<th>文章地址</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="9f103da7.html">JVM内存结构</a></td>
</tr>
<tr>
<td>2</td>
<td><a href="b287f556.html">JVM的对象创建</a></td>
</tr>
<tr>
<td>3</td>
<td><a href="bce48291.html">JVM的对象生死</a></td>
</tr>
<tr>
<td>4</td>
<td><a href="50b49e8d.html">JVM垃圾收集器算法</a></td>
</tr>
<tr>
<td>5</td>
<td><a href="d01dbbb1.html">JVM常见的垃圾收集器</a></td>
</tr>
<tr>
<td>6</td>
<td><a href="f8161112.html">JVM低延迟垃圾收集器：Shenandoah</a></td>
</tr>
<tr>
<td>7</td>
<td><a href="e3d9aed7.html">JVM低延迟垃圾收集器:ZGC</a></td>
</tr>
<tr>
<td>8</td>
<td><a href="96a9f88d.html">JVM低内存分配回收策略</a></td>
</tr>
<tr>
<td>9</td>
<td><a href="ed0fd586.html">JVM监控调优工具</a></td>
</tr>
<tr>
<td>10</td>
<td>[JVM收集器与常见参数]</td>
</tr>
<tr>
<td>11</td>
<td>[JVM调优指南]</td>
</tr>
<tr>
<td>12</td>
<td><a href="a2ceb3e5.html">JVM字节码指令</a></td>
</tr>
<tr>
<td>12-1</td>
<td><a href="ee62cca5.html">JVM字节码指令表</a></td>
</tr>
<tr>
<td>13</td>
<td><a href="6698cab3.html">JVM类文件结构</a></td>
</tr>
<tr>
<td>14</td>
<td><a href="22096143.html">JVM类加载机制</a></td>
</tr>
<tr>
<td>15</td>
<td><a href="49b8efd0.html">Java模块化系统</a></td>
</tr>
<tr>
<td>16</td>
<td>[JVM字节码执行引擎]</td>
</tr>
</tbody></table>
<!--
#### java虚拟机执行子系统

1. jvm类文件结构

    class类文件结构
    字节码指令
    公有设计私有实现
    class类文件结构发展

2. jvm类加载机制


3. 字节码执行引擎


#### 程序编译与代码优化

1. 前端编译与优化


2. 后端编译与优化

     即时编译
     提前编译
     编译器优化技术
     深入理解编译器


-->]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>java 查漏补缺-java8里的日期时间API</title>
    <url>/posts/d0e15f60.html</url>
    <content><![CDATA[<h3 id="Java-8-日期时间-API"><a href="#Java-8-日期时间-API" class="headerlink" title="Java 8 日期时间 API"></a>Java 8 日期时间 API</h3><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。 旧版的<code>java.util.Date</code>是非线程安全的。</p>
<h4 id="1-java8日期时间相关API"><a href="#1-java8日期时间相关API" class="headerlink" title="1. java8日期时间相关API"></a>1. java8日期时间相关API</h4><p>Java 8 在 java.time 包下提供了很多新的 API：</p>
<div>
Local (本地) − 简化了日期时间的处理，没有时区的问题。

<p>Zoned (时区) − 通过制定的时区处理日期时间。</p>
<p>Instant（时间戳）-精确到纳秒的的某个时间点，不包含时区，允许加减运算。该方法默认使用的是UTC(协调世界时——由原子钟提供)时间，可以使用equeal 和 compareTo来比较两个时间点的值。支持旧版时间转换新版时间戳。</p>
<p>LocalDate（本地日期）− 简化了日期处理，不带时间。</p>
<p>LocalTime（本地时间）− 简化了时间处理，不带日期且没有偏移信息、无时区的时间。</p>
<p>LocalDateTime（本地日期时间）− 日期+时间的处理。</p>
<p>ZoneDateTime（时区日期时间）- 包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。</p>
<p>MonthDay- 月日组合。它是一个值类（value class）,由，不包含年信息，可以用来代表每年重复出现的一些日期或其他组合。</p>
<p>YearMonth - 年月组合。</p>
<p>WeekFields(周) - 处理周的计算。</p>
<p>DateTimeFormatter − 提供格式化和解析功能。下面详细的介绍使用方法。<br>任何修改操作都会返回一个新的实例。</p>
<p>Clock - 时钟。可以获取某个时区下（对时区是敏感的）当前的瞬时时间、日期。用来代替System.currentTimelnMillis()与TimeZone.getDefault()方法。</p>
</div>

<h4 id="2-基本获取与简单计算。"><a href="#2-基本获取与简单计算。" class="headerlink" title="2. 基本获取与简单计算。"></a>2. 基本获取与简单计算。</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk8<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>Clock<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>DayOfWeek<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>Duration<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>Instant<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDate<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDateTime<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalTime<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>Period<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>temporal<span class="token punctuation">.</span>ChronoUnit<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>temporal<span class="token punctuation">.</span>WeekFields<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>System<span class="token punctuation">.</span>out<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DateTimeTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 时间戳</span>
        Instant now <span class="token operator">=</span> Instant<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" now = "</span> <span class="token operator">+</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>

        LocalDate date <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//日期</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" date = "</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>

        LocalTime time <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>Clock<span class="token punctuation">.</span><span class="token function">systemUTC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//时间</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" time = "</span> <span class="token operator">+</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>

        LocalDateTime dttm <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" dttm = "</span> <span class="token operator">+</span> dttm<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 将java.util.Date转换为Instant</span>
        Instant instant1 <span class="token operator">=</span> Instant<span class="token punctuation">.</span><span class="token function">ofEpochMilli</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instant1<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 从字符串类型中创建Instant类型的时间</span>
        Instant instant2 <span class="token operator">=</span> Instant<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"1995-10-23T10:12:35Z"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Instant instant3 <span class="token operator">=</span> Instant<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将现在的时间加上2个小时10分钟</span>
        Instant changeIns <span class="token operator">=</span> instant3<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span>Duration<span class="token punctuation">.</span><span class="token function">ofHours</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">plusMinutes</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>changeIns<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 使用instant计算7天前</span>
        instant3<span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 方法1</span>
        instant3<span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span>Duration<span class="token punctuation">.</span><span class="token function">ofDays</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 方法2</span>

        <span class="token comment" spellcheck="true">// 计算两个Instant之间的分钟数</span>
        Instant instant4 <span class="token operator">=</span> Instant<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// long diffAsMinutes = instant.periodUntil(instant3, ChronoUnit.MINUTES); //</span>
        <span class="token comment" spellcheck="true">// 方法1</span>
        <span class="token keyword">long</span> diffAsMinutes1 <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>instant1<span class="token punctuation">,</span> instant4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 方法2</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>diffAsMinutes1 <span class="token operator">/</span> <span class="token number">60</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 一周从周日开始</span>
        WeekFields weekFields <span class="token operator">=</span> WeekFields<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>DayOfWeek<span class="token punctuation">.</span>SUNDAY<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今天是今年第"</span> <span class="token operator">+</span> today<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>weekFields<span class="token punctuation">.</span><span class="token function">weekOfYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"周"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 计算date的相差天数</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEpochDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEpochDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 计算date的相差月数</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">until</span><span class="token punctuation">(</span>LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>MONTHS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 计算date的相差月天，（相差0年1月24天）</span>
        LocalDate date1 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        LocalDate date2 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Period period <span class="token operator">=</span> Period<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>date1<span class="token punctuation">,</span> date2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>period<span class="token punctuation">.</span><span class="token function">getYears</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> period<span class="token punctuation">.</span><span class="token function">getMonths</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> period<span class="token punctuation">.</span><span class="token function">getDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Clock utc_cl <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemUTC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" utc_cl :"</span> <span class="token operator">+</span>utc_cl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Clock def_cl <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" def_cl :"</span> <span class="token operator">+</span>def_cl<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h4 id="3-日期判断与比较"><a href="#3-日期判断与比较" class="headerlink" title="3. 日期判断与比较"></a>3. 日期判断与比较</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk8<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDate<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDateTime<span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>System<span class="token punctuation">.</span>out<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DateTimeCompareTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// 日期比较</span>
        LocalDate date1 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        LocalDate date2 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// isBefore</span>
        <span class="token keyword">boolean</span> b1 <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>date2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" date1 在date2的前面 ："</span> <span class="token operator">+</span> b1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// isAfter</span>
        <span class="token keyword">boolean</span> b2 <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span>date2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" date1 在date2的后面 ："</span> <span class="token operator">+</span> b2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">boolean</span> b3 <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>date2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" date1   equals  date2  ? "</span> <span class="token operator">+</span> b3<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 日期时间比较</span>
        LocalDateTime dttm1 <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" dttm1 = "</span> <span class="token operator">+</span> dttm1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        LocalDateTime dttm2 <span class="token operator">=</span> dttm1<span class="token punctuation">.</span><span class="token function">plusDays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" dttm2 = "</span> <span class="token operator">+</span> dttm2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> b4 <span class="token operator">=</span> dttm1<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>dttm2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" dttm1 在 dttm2 的前面 ："</span> <span class="token operator">+</span> b4<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="4-时区处理"><a href="#4-时区处理" class="headerlink" title="4. 时区处理"></a>4. 时区处理</h4><p>ZonId代表的是某个特定时区，ZonedDateTime代表带时区的时间，等同于以前的GregorianCalendar类。使用该类，可以将本地时间转换成另一个时区中的对应时间。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zxc<span class="token punctuation">.</span>jdk8<span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>System<span class="token punctuation">.</span>out<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDateTime<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneId<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZonedDateTime<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimeZoneTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        LocalDateTime localDateTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" localDateTime = "</span> <span class="token operator">+</span> localDateTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

        ZoneId zone <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span>SHORT_IDS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"CTT"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取定义好的时区</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" zone = "</span> <span class="token operator">+</span> zone<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//包含时区的时间</span>
        ZonedDateTime dtWithZone <span class="token operator">=</span> ZonedDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>localDateTime<span class="token punctuation">,</span> zone<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" dtWithZone = "</span> <span class="token operator">+</span> dtWithZone<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>输出</p>
<pre><code> localDateTime = 2020-05-31T23:54:42.831
 zone = Asia/Shanghai
 dtWithZone = 2020-05-31T23:54:42.831+08:00[Asia/Shanghai]</code></pre><p> 注意：对应时区的文本可以直接手动填写，也可以调用系统默认定义的。</p>
<h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h4><p>可以参考<a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">java 8 API</a>,在实际遇到再补充。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之内存结构</title>
    <url>/posts/9f103da7.html</url>
    <content><![CDATA[<h2 id="jvm-内存管理机制"><a href="#jvm-内存管理机制" class="headerlink" title="jvm 内存管理机制"></a>jvm 内存管理机制</h2><blockquote>
<p>参考资料：<br>《深入理解Java虚拟机 JVM高级特性与最佳实践 第3版》<br>《Java虚拟机规范（Java SE 7）》</p>
</blockquote>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域.<br>jvm-pic-1.jpg</p>
<h4 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h4><blockquote>
<p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</blockquote>
<p>程序计数器特征：<br>（1）是“线程私有”的内存。每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。<br>（2）如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。<br>（3）此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2. Java虚拟机栈"></a>2. Java虚拟机栈</h4><blockquote>
<p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[栈帧是方法运行期间很重要的基础数据结构]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
</blockquote>
<p>局部变量表相关：</p>
<blockquote>
<p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
</blockquote>
<p>在《Java虚拟机规范》中， Java虚拟机栈可能出现两类异常状况：</p>
<blockquote>
<p>（1）如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；<br>（2）如果Java虚拟机栈容量可以动态扩展[Hotspot的虚拟机栈不允许扩展]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>
</blockquote>
<h4 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，区别:</p>
<blockquote>
<p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，<br>本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
</blockquote>
<p>有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。<br>本地方法栈也可能出现两类异常状况：</p>
<blockquote>
<p>（1）本地方法栈也会在栈深度溢出时抛出StackOverflowError<br>（2）本地方法栈扩展失败时抛出OutOfMemoryError。</p>
</blockquote>
<h4 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4. Java堆"></a>4. Java堆</h4><blockquote>
<p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“<strong>几乎</strong>”所有的对象实例都在这里分配内存。</p>
</blockquote>
<p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。</p>
<p>从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”、“永久代”、“Eden空间”、“From Survivor空间”、“To Survivor空间”等。</p>
<p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。</p>
<p>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
<p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。</p>
<p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>
<h4 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h4><blockquote>
<p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
</blockquote>
<p>虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。</p>
<p>在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用<code>本地内存（Native Memory）</code>来实现方法区的计划。<br>到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移至堆内存。</p>
<blockquote>
<p>jdk7开始方法区的逐渐移除：符号引用(Symbols)移至native heap，字面量(interned strings)和静态变量(class statics)移至java heap。</p>
</blockquote>
<p>到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的<code>元空间（Meta-space）</code>来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</p>
<blockquote>
<p>JDK1.8以前的HotSpot JVM有方法区，也叫永久代(permanent generation)。<br>方法区用于存放已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码。<br>方法区是一片连续的堆空间，通过-XX:MaxPermSize来设定永久代最大可分配空间，当JVM加载的类信息容量超过了这个值，会报OOM:PermGen错误。<br>永久代的GC是和老年代(old generation)捆绑在一起的，无论谁满了，都会触发永久代和老年代的垃圾收集。</p>
</blockquote>
<p>为什么要用Metaspace替代方法区？</p>
<p>随着动态类加载的情况越来越多，这块内存变得不太可控，如果设置小了，系统运行过程中就容易出现内存溢出，设置大了又浪费内存。</p>
<blockquote>
<p>方法区的内存回收目标主要是针对常量池的回收和对类型的卸载，卸载条件相当苛刻。<br>方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p>
</blockquote>
<h4 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h4><blockquote>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
</blockquote>
<p>运行时常量池特征：<br>（1）存储数据条件宽松。（保存Class文件中描述的符号引用，把由符号引用翻译出来的直接引用，均可放入运行时常量池）<br>（2）具备动态性。（预置入Class文件中常量池的内容，或运行期间新的常量[如String类的intern()方法]，均可放入）</p>
<p>运行时常量池是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h4 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h4><blockquote>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
</blockquote>
<blockquote>
<p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
</blockquote>
<blockquote>
<p>本机直接内存的分配不会受Java堆大小的限制，但受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制。<br>配置虚拟机参数时，设置-Xmx等参数信息，若使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），就会导致动态扩展时出现OutOfMemoryError。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存结构</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之垃圾收集器算法</title>
    <url>/posts/50b49e8d.html</url>
    <content><![CDATA[<h2 id="jvm-垃圾收集算法"><a href="#jvm-垃圾收集算法" class="headerlink" title="jvm 垃圾收集算法"></a>jvm 垃圾收集算法</h2><p>垃圾收集算法基本分类：<br>（1）“引用计数式垃圾收集”（Reference Counting GC）—直接垃圾收集<br>（2）“追踪式垃圾收集”（Tracing GC）—间接垃圾收集</p>
<h3 id="1-分代收集理论"><a href="#1-分代收集理论" class="headerlink" title="1. 分代收集理论"></a>1. 分代收集理论</h3><p>1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。<br>2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。<br>3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>
<p>常用名词：</p>
<blockquote>
<ul>
<li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收-集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</li>
</ul>
</blockquote>
<h3 id="2-标记-清除算法（Mark-Sweep）"><a href="#2-标记-清除算法（Mark-Sweep）" class="headerlink" title="2. 标记-清除算法（Mark-Sweep）"></a>2. 标记-清除算法（Mark-Sweep）</h3><p>最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法。</p>
<blockquote>
<p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象</p>
</blockquote>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-mark-sweep.jpg" alt="Serial收集器运行示意图"></p>
<p>主要缺点:<br>（1）执行效率不稳定，随着对象增加执行效率降低。</p>
<blockquote>
<p>如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</p>
</blockquote>
<p>（2）内存空间碎片化问题，遇到较大对象男分配，重新GC。</p>
<blockquote>
<p>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</blockquote>
<h3 id="3-标记-复制算法（Semispace-Copying）"><a href="#3-标记-复制算法（Semispace-Copying）" class="headerlink" title="3. 标记-复制算法（Semispace Copying）"></a>3. 标记-复制算法（Semispace Copying）</h3><p>标记-复制算法常被简称为复制算法。为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法：</p>
<blockquote>
<p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
</blockquote>
<p>优点：</p>
<p>（1）实现简单，运行高效。<br>（2）分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可</p>
<p>缺点：</p>
<p>（1）如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销。<br>（2）将可用内存缩小为了原来的一半。</p>
<p>![Serial收集器运行示意图](/images/jvm-images/jvm-gc-Semispace Copying.jpg)</p>
<blockquote>
<p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代。<br>在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。</p>
<p>Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间（HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1）每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。</p>
<p>当复制目标的Survivor空间不足以容纳一次Minor GC之后存活的对象时，采用一种分配担保策略：多出来的对象直接进入老年代。 </p>
</blockquote>
<h3 id="4-标记-整理算法（Mark-Compact）"><a href="#4-标记-整理算法（Mark-Compact）" class="headerlink" title="4. 标记-整理算法（Mark-Compact）"></a>4. 标记-整理算法（Mark-Compact）</h3><blockquote>
<p>不同于针对新生代的复制算法，针对老年代的特点，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法。其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
</blockquote>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-Mark-Compact.jpg" alt="Parallel Scavenge收集器运行示意图"></p>
<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。</p>
<p>优缺点：</p>
<blockquote>
<p>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行（Stop The World）。</p>
<p>如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。</p>
<p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。此语境中，吞吐量的实质是赋值器（Mutator，可以理解为使用垃圾收集的用户程序，本书为便于理解，多数地方用“用户程序”或“用户线程”代替）与收集器的效率总和。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集器算法</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之对象创建与布局</title>
    <url>/posts/b287f556.html</url>
    <content><![CDATA[<h2 id="HotSpot-虚拟机对象创建与布局"><a href="#HotSpot-虚拟机对象创建与布局" class="headerlink" title="HotSpot 虚拟机对象创建与布局"></a>HotSpot 虚拟机对象创建与布局</h2><p>HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。<br>创建对象的三种方式：new关键字、复制、反序列化。</p>
<h3 id="一-对象的创建"><a href="#一-对象的创建" class="headerlink" title="一. 对象的创建"></a>一. 对象的创建</h3><p>此处提及的对象创建，只是普通Java对象，不包括数组和Class对象。</p>
<h4 id="1-检查符合引用和类加载情况"><a href="#1-检查符合引用和类加载情况" class="headerlink" title="1. 检查符合引用和类加载情况"></a>1. 检查符合引用和类加载情况</h4><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h4 id="2-为新生对象分配内存"><a href="#2-为新生对象分配内存" class="headerlink" title="2. 为新生对象分配内存"></a>2. 为新生对象分配内存</h4><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务其实就是把一块确定大小的内存块从Java堆中划分出来存放该对象。</p>
<p>关于对象内存分配方式：<br>（1）“指针碰撞”（Bump The Pointer）</p>
<blockquote>
<p>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）</p>
</blockquote>
<p>（2）“空闲列表”（Free List）:</p>
<blockquote>
<p>Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）</p>
</blockquote>
<p>选择哪种分配方式，取决于Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此：</p>
<p>（A）当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；<br>（B）当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p>
<p>考虑对象内存分配的线程安全问题：</p>
<blockquote>
<p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<code>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</code>，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定【对分配内存空间的动作进行同步处理——实际上虚拟机是采用<code>CAS</code>配上失败重试的方式保证更新操作的原子性】。虚拟机是否使用<code>TLAB</code>，可以通过<code>-XX：+/-UseTLAB</code>参数来设定。</p>
</blockquote>
<p>每个线程在堆中都会有私有的<code>分配缓冲区(TLAB)</code>，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p>
<h4 id="3-将分配的内存初始化为零值"><a href="#3-将分配的内存初始化为零值" class="headerlink" title="3. 将分配的内存初始化为零值"></a>3. 将分配的内存初始化为零值</h4><p>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至<code>TLAB</code>分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="4-对新生的对象进行设置"><a href="#4-对新生的对象进行设置" class="headerlink" title="4. 对新生的对象进行设置"></a>4. 对新生的对象进行设置</h4><p>对象的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用<code>Object::hashCode()</code>方法时才计算）、对象的<code>GC</code>分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="5-执行-lt-init-gt-方法。"><a href="#5-执行-lt-init-gt-方法。" class="headerlink" title="5. 执行&lt;init&gt;()方法。"></a>5. 执行<code>&lt;init&gt;()</code>方法。</h4><p>new指令之后会接着执行<code>&lt;init&gt;()</code>方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>
<p><code>&lt;init&gt;()</code>方法是 对象构造时用以初始化对象的，构造器以及非静态初始化块中的代码。</p>
<p>区别与类加载的<code>&lt;clinit&gt;()</code>方法</p>
<h3 id="二、对象的布局"><a href="#二、对象的布局" class="headerlink" title="二、对象的布局"></a>二、对象的布局</h3><p><code>HotSpot</code>虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：</p>
<pre><code>对象头（Header）、
实例数据（Instance Data）
对齐填充（Padding）。</code></pre><h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1. 对象头"></a>1. 对象头</h4><p>对象头部分包括两类信息：</p>
<p>（1）第一类是用于存储对象自身的运行时数据，如哈希码<code>（HashCode）</code>、<code>GC分代年龄</code>、<code>锁状态标志</code>、<code>线程持有的锁</code>、<code>偏向线程ID</code>、<code>偏向时间戳</code>等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。</p>
<p>（2）第二类是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<pre><code>并不是所有的虚拟机实现都必须在对象数据上保留类型指针，即，查找对象的元数据信息并不一定要经过对象本身</code></pre><h4 id="2-实例数据："><a href="#2-实例数据：" class="headerlink" title="2. 实例数据："></a>2. 实例数据：</h4><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>
<blockquote>
<p>这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。</p>
<p>HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs）。<br>相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</p>
<p>如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间</p>
</blockquote>
<h4 id="3-对齐填充"><a href="#3-对齐填充" class="headerlink" title="3.对齐填充"></a>3.对齐填充</h4><p>（A）非必然，无特殊含义，仅作占位符使用。</p>
<p>（B）对象实例数据没有对齐时需要对齐填充。</p>
<blockquote>
<p>对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于<code>HotSpot虚拟机</code>的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
</blockquote>
<h3 id="三、对象的访问定位"><a href="#三、对象的访问定位" class="headerlink" title="三、对象的访问定位"></a>三、对象的访问定位</h3><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。</p>
<p>对象访问主流的访问方式主要有使用句柄和直接指针两种：</p>
<p>（1）使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images//jvm-images/jvm-obj-ref-1.jpg" alt="句柄访问示意图"></p>
<p>（2）使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-obj-ref-2.jpg" alt="直接指针访问示意图"></p>
<p><strong>句柄访问</strong> 与 <strong>直接指针</strong> 比较：</p>
<p>（A）使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。<br>（B）直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p>
<p><code>HotSpot</code>而言，它主要使用第二种方式进行对象访问。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之对象生死</title>
    <url>/posts/bce48291.html</url>
    <content><![CDATA[<h3 id="jvm-检测判断对象的生死"><a href="#jvm-检测判断对象的生死" class="headerlink" title="jvm 检测判断对象的生死"></a>jvm 检测判断对象的生死</h3><p>垃圾收集（Garbage Collection，简称GC）</p>
<p>对象生死</p>
<blockquote>
<p>堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。对象是否存活的算法各不相同。</p>
</blockquote>
<h4 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h4><p>引用计数算法:<br><P><br>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的<br></P><br>引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。</p>
<p>引用计数算法的缺陷：两个对象相互引用，永不回收。<br>代码示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * testGC()方法执行后，objA和objB会不会被GC呢？
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGC</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bigSize <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ReferenceCountingGC objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ReferenceCountingGC objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objA．instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>
        objB．instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>

        objA <span class="token operator">=</span> null<span class="token punctuation">;</span>
        objB <span class="token operator">=</span> null<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 假设在这行发生GC，objA和objB是否能被回收？</span>
        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果：</p>
<pre><code>[Full GC (System) [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
Heap
    def new generation   total 9216K, used 82K [0x00000000055e0000, 0x0000000005fe0000, 0x0000000005fe0000)
    Eden space 8192K,   1% used [0x00000000055e0000, 0x00000000055f4850, 0x0000000005de0000)
    from space 1024K,   0% used [0x0000000005de0000, 0x0000000005de0000, 0x0000000005ee0000)
    to   space 1024K,   0% used [0x0000000005ee0000, 0x0000000005ee0000, 0x0000000005fe0000)
    tenured generation   total 10240K, used 210K [0x0000000005fe0000, 0x00000000069e0000, 0x00000000069e0000)
    the space 10240K,   2% used [0x0000000005fe0000, 0x0000000006014a18, 0x0000000006014c00, 0x00000000069e0000)
    compacting perm gen  total 21248K, used 3016K [0x00000000069e0000, 0x0000000007ea0000, 0x000000000bde0000)
    the space 21248K,  14% used [0x00000000069e0000, 0x0000000006cd2398, 0x0000000006cd2400, 0x0000000007ea0000)
    No shared spaces configured.</code></pre><p>内存回收日志中包含<code>“4603K-&gt;210K”</code>，意味着虚拟机并没有因为这两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>
<h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h4><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路:</p>
<blockquote>
<p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GCRoots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
</blockquote>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-1.jpg" alt="GC Roots 示意图"></p>
<p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p>
<blockquote>
<p>（1）在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。<br>（2）在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。<br>（3）在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。<br>（4）在本地方法栈中JNI（即通常所说的Native方法）引用的对象。<br>（5）Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。<br>（6）所有被同步锁（synchronized关键字）持有的对象。<br>（7）反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
</blockquote>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。</p>
<h4 id="3-对象引用及分类"><a href="#3-对象引用及分类" class="headerlink" title="3. 对象引用及分类"></a>3. 对象引用及分类</h4><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Re-ference）</code>、<code>软引用（Soft Reference）</code>、<code>弱引用（Weak Reference）</code>和<code>虚引用（PhantomReference）</code>4种，这4种引用强度依次逐渐减弱。可以简写成：</p>
<pre><code>强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</code></pre><p>（1）强引用（Strongly Re-ference）</p>
<blockquote>
<p>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似<code>“Object obj=new Object()”</code>这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
</blockquote>
<p>（2）软引用（Soft Reference）</p>
<blockquote>
<p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了<code>SoftReference</code>类来实现软引用。</p>
</blockquote>
<p>（3）弱引用（Weak Reference）</p>
<blockquote>
<p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了<code>WeakReference</code>类来实现弱引用。</p>
</blockquote>
<p>（4）虚引用（PhantomReference）</p>
<blockquote>
<p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了<code>PhantomReference</code>类来实现虚引用。</p>
</blockquote>
<h4 id="4-是生是死？"><a href="#4-是生是死？" class="headerlink" title="4. 是生是死？"></a>4. 是生是死？</h4><blockquote>
<p>在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
</blockquote>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。</p>
<p>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<p>书中代码示例：</p>
<pre><code>/**
 * 此代码演示了两点：
 * 1.对象可以在被GC时自我拯救。
 * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
 */
public class FinalizeEscapeGC {

    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive() {
        System.out.println(&quot;yes, i am still alive :)&quot;);
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(&quot;finalize method executed!&quot;);
        FinalizeEscapeGC．SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();

        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println(&quot;no, i am dead :(&quot;);
        }

        // 下面这段代码与上面的完全相同，但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println(&quot;no, i am dead :(&quot;);
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>finalize method executed!
yes, i am still alive :)
no, i am dead :(</code></pre><p>结论</p>
<blockquote>
<p>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。</p>
</blockquote>
<h4 id="5-回收方法区"><a href="#5-回收方法区" class="headerlink" title="5. 回收方法区"></a>5. 回收方法区</h4><blockquote>
<p>在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，方法区回收条件苛刻，回收成果极小。</p>
</blockquote>
<p>方法区的垃圾收集主要回收两部分内容：废弃的常量，不再使用的类型。<br>（1）废弃的常量</p>
<blockquote>
<p>回收废弃常量与回收Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。</p>
</blockquote>
<p>系统和虚拟机中均没有引用改常量即可。</p>
<p>（2）不再使用的类型</p>
<p>需要同时满足下面三个条件:<br>A. 该类所有的实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例<br>B. 加载该类的类加载器已经被回收。（难达成）<br>C. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>对象生死</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM LLGC：Shenandoah</title>
    <url>/posts/f8161112.html</url>
    <content><![CDATA[<h2 id="JVM低延迟垃圾收集器：Shenandoah"><a href="#JVM低延迟垃圾收集器：Shenandoah" class="headerlink" title="JVM低延迟垃圾收集器：Shenandoah"></a>JVM低延迟垃圾收集器：Shenandoah</h2><p>EN： JVM Low-Latency Garbage Collector : Shenandoah</p>
<h3 id="一-、Shenandoah简介"><a href="#一-、Shenandoah简介" class="headerlink" title="一 、Shenandoah简介"></a>一 、Shenandoah简介</h3><blockquote>
<p>一款不由Oracle（包括以前的Sun）公司的虚拟机团队所领导开发的HotSpot垃圾收集器。只有OpenJDK才会包含，而OracleJDK里反而不存在的收集器，“免费开源版”比“收费商业版”功能更多。</p>
</blockquote>
<blockquote>
<p>2014年RedHat把Shenandoah贡献给了OpenJDK，并推动它成为OpenJDK 12的正式特性之一，也就是后来的JEP 189。</p>
</blockquote>
<p>目标：<strong>实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。</strong></p>
<h3 id="二、Shenandoah特征及实现思路："><a href="#二、Shenandoah特征及实现思路：" class="headerlink" title="二、Shenandoah特征及实现思路："></a>二、Shenandoah特征及实现思路：</h3><p><strong>Shenandoah主要特征</strong>：</p>
<p>（1）基于Region的堆内存布局,去除传统分代。</p>
<p>（2）回收策略优先处理回收价值最大的Region</p>
<p>（3）支持并发的整理算法。</p>
<p><strong>Shenandoah收集器的实现思路</strong>：</p>
<p>（1）基于Region的堆内存布局，默认不使用分代收集，<code>(相比G1的记忆集（RemberSet）处理跨代指针时维护消耗)</code>改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系。降低了伪共享问题的发生概率。</p>
<blockquote>
<p>连接矩阵可以简单理解为一张二维表格，如果RegionN有对象指向Region M，就在表格的N行M列中打上一个标记，如图3-15所示，如果Region 5中的对象Baz引用了Region 3的Foo，Foo又引用了Region 1的Bar，那连接矩阵中的5行3列、3行1列就应该被打上标记。在回收时通过这张表格就可以得出哪些Region之间产生了跨代引用。</p>
</blockquote>
<p>（2）使用转发指针（Brooks Pointer）和读写屏障来实现与用户线程并发的整理算法。</p>
<blockquote>
<p>转发指针是在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。<br>当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。这样只要旧对象的内存仍然存在，未被清理掉，虚拟机内存中所有通过旧引用地址访问的代码便仍然可用，都会被自动转发到新对象上继续工作。</p>
</blockquote>
<h3 id="三、Shenandoah收集器的工作过程（九阶段划分）："><a href="#三、Shenandoah收集器的工作过程（九阶段划分）：" class="headerlink" title="三、Shenandoah收集器的工作过程（九阶段划分）："></a>三、Shenandoah收集器的工作过程（九阶段划分）：</h3><h4 id="1-始标记（Initial-Marking）"><a href="#1-始标记（Initial-Marking）" class="headerlink" title="1. 始标记（Initial Marking）"></a>1. 始标记（Initial Marking）</h4><p>​    （A）与G1一样，首先标记与GC Roots直接关联的对象.</p>
<p>​    （B）需要“Stop The World”，有停顿，但停顿时间与堆大小无关，只与GC Roots的数量相关。</p>
<h4 id="2-并发标记（Concurrent-Marking）"><a href="#2-并发标记（Concurrent-Marking）" class="headerlink" title="2. 并发标记（Concurrent Marking）"></a>2. 并发标记（Concurrent Marking）</h4><p>​    （A）<strong>重要的并发过程之一。</strong></p>
<p>​    （B）与G1一样，遍历对象图，标记出全部可达的对象。可达性分析。</p>
<p>​    （C）与用户线程并发执行，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。</p>
<h4 id="3-最终标记（Final-Marking）"><a href="#3-最终标记（Final-Marking）" class="headerlink" title="3. 最终标记（Final Marking）"></a>3. 最终标记（Final Marking）</h4><p>（A）与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。</p>
<p>​（B）会有一小段短暂的停顿。</p>
<h4 id="4-并发清理（Concurrent-Cleanup）"><a href="#4-并发清理（Concurrent-Cleanup）" class="headerlink" title="4. 并发清理（Concurrent Cleanup）"></a>4. 并发清理（Concurrent Cleanup）</h4><p>​    （A）清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。</p>
<h4 id="5-并发回收（Concurrent-Evacuation）"><a href="#5-并发回收（Concurrent-Evacuation）" class="headerlink" title="5. 并发回收（Concurrent Evacuation）"></a>5. 并发回收（Concurrent Evacuation）</h4><p>​    （A）<strong>重要的并发过程之一。</strong>并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。</p>
<p>​    （B）Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。</p>
<p>  （C）使用<strong>读屏障</strong>和被称为”Brooks Pointers”的<strong>转发指针</strong>实现并发过程，并发回收阶段运行的时间长短取。</p>
<h4 id="6-初始引用更新（Initial-Update-Reference）"><a href="#6-初始引用更新（Initial-Update-Reference）" class="headerlink" title="6. 初始引用更新（Initial Update Reference）"></a>6. 初始引用更新（Initial Update Reference）</h4><p>​    （A）并发回收阶段复制对象结束后，把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。</p>
<p>​    （B）此阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。</p>
<p>​    （B）初始引用更新时间很短，会产生一个非常短暂的停顿。</p>
<h4 id="7-并发引用更新（Concurrent-Update-Reference）"><a href="#7-并发引用更新（Concurrent-Update-Reference）" class="headerlink" title="7. 并发引用更新（Concurrent Update Reference）"></a>7. 并发引用更新（Concurrent Update Reference）</h4><p>​    （A）<strong>重要的并发过程之一。</strong></p>
<p>​    （B）真正开始进行引用更新操作，与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。    </p>
<p>​    （C）并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。</p>
<h4 id="8-最终引用更新（Final-Update-Reference）"><a href="#8-最终引用更新（Final-Update-Reference）" class="headerlink" title="8. 最终引用更新（Final Update Reference）"></a>8. 最终引用更新（Final Update Reference）</h4><p>​    （A）解决了堆中的引用更新后，还要修正存在于GCRoots中的引用。</p>
<p>​    （B）此阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。</p>
<h4 id="9-并发清理（Concurrent-Cleanup）"><a href="#9-并发清理（Concurrent-Cleanup）" class="headerlink" title="9. 并发清理（Concurrent Cleanup）"></a>9. 并发清理（Concurrent Cleanup）</h4><p>经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</p>
<p> Shenandoah收集器的重要的三个并发过程：</p>
<ol>
<li>并发标记</li>
<li>并发回收</li>
<li>并发引用更新</li>
</ol>
<p>Shenandoah收集器的工作流程图：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-shen-andoah-do-job.png" alt="Shenandoah收集器的工作过程"></p>
<p>图片来源：<a href="https://shipilev.net/talks/devoxx-Nov2017-shenandoah.pdf" target="_blank" rel="noopener">《Shenandoah GC Part I: The Garbage Collector That Could》</a></p>
<p>说明：</p>
<p>黄色区域代表的是被选入回收集的Region。</p>
<p>绿色部分就代表还存活的对象。</p>
<p>蓝色区域就是用户线程可以用来分配对象的内存Region。</p>
<h3 id="四、GC收集器比较"><a href="#四、GC收集器比较" class="headerlink" title="四、GC收集器比较"></a>四、GC收集器比较</h3><h4 id="1、Shenandoah-与其他收集器并发比较"><a href="#1、Shenandoah-与其他收集器并发比较" class="headerlink" title="1、Shenandoah 与其他收集器并发比较"></a>1、Shenandoah 与其他收集器并发比较</h4><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-shen-andoah.png" alt="Shenandoah与其他垃圾收集器比较"></p>
<p>图片来源：<a href="https://shipilev.net/talks/devoxx-Nov2017-shenandoah.pdf" target="_blank" rel="noopener">《Shenandoah GC Part I: The Garbage Collector That Could》</a></p>
<p>黄色：表示必须挂起用户线程</p>
<p>绿色：表示收集器线程与用户线程并发执行。</p>
<p>结论：</p>
<p>（1）CMS和G1之前的全部收集器，其工作的所有步骤都会产生“Stop TheWorld”式的停顿；</p>
<p>（2）CMS和G1分别使用增量更新和原始快照(SATB)技术，实现了标记阶段的并发，不会因管理的堆内存变大，要标记的对象变多而导致停顿时间随之增长。但是对于标记阶段之后的处理，仍未得到妥善解决。</p>
<p>（3）CMS使用标记-清除算法，虽然避免了整理阶段收集器带来的停顿，但是清除算法不论如何优化改进，在设计原理上避免不了空间碎片的产生，随着空间碎片不断淤积最终依然逃不过“Stop The World”的命运。</p>
<p>（4）G1虽然可以按更小的粒度进行回收，从而抑制整理阶段出现时间过长的停顿，也有暂停。</p>
<p>（5）Shenandoah只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上是固定的，与堆的容量、堆中对象的数量没有正比例关系。</p>
<h4 id="2、Shenandoah-与G1比较"><a href="#2、Shenandoah-与G1比较" class="headerlink" title="2、Shenandoah 与G1比较"></a>2、Shenandoah 与G1比较</h4><table>
    <th>
        <td width="46%">Shenandoah</td>
        <td width="46%">G1（Garbage First）</td>
    </th>
    <tr>
    <td rowspan="3">不同</td>
    <td >Shenandoah（目前）是默认不使用分代收集的,不会有专门的新生代Region或者老年代Region的存在，没有实现分代。
     </td>
    <td >G1仍然保留新生代和老年代概况，只是变成Region区组成的逻辑连续的动态集合。
     </td>
  </tr>
<tr>
    <td >使用“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系。</td>
    <td >使用记忆集（Rember Set）避免全堆作为GC Roots扫描,每个Region都维护有自己的记忆集。</td>
  </tr>
<tr>
    <td >Shenandoah通过读屏障和被称为“Brooks Pointers”的转发指针实现并发回收,支持与用户线程并发。 </td>
    <td >G1的回收阶段是可以多线程并行的，但却不能与用户线程并发。 </td>
  </tr>
<tr>
    <td>相同</td>
    <td colspan="2">（1）都是基于Region的堆内存布局，都有用于存放大对象的Humongous Region<br/>（2）并发回收思路高度一致，<br/>（3）默认的回收策略都是优先处理回收价值最大的Region<br/>（4） 都采用标记-整理，标记-复制算法回收。<br/></td>
   </tr>
</table>




<h3 id="四、相关概念"><a href="#四、相关概念" class="headerlink" title="四、相关概念"></a>四、相关概念</h3><p><strong>写屏障</strong>：<br>    在赋值操作前后，加入一些处理（类似针对写操作进行AOP的处理）<br>    目的通常是为了记录对象引用的变动情况</p>
<p><strong>读屏障</strong>：</p>
<p>​   在读值操作前后，加入一些处理（类似针对读操作进行AOP的处理）<br>   目的通常是为了读取对象更新引用后的原有直。</p>
<blockquote>
<p>说明：读写屏障没有找到相关科学定义，写屏障的理解来自网络，读屏障是根据写屏障的理解暂作说明的，如果不当，欢迎指正。</p>
</blockquote>
<p><strong><span id="jump">指针转发</span></strong> Brooks Pointer（Forwarding Pointer / Indirection Pointer）</p>
<p>相关历史简介：</p>
<p>1984年，Brooks提出使用转发指针来实现对象移动与用户程序并发的一种解决方案。</p>
<p>Brooks提出的新方案不需要用到内存保护陷阱，而是在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。这样只要旧对象的内存仍然存在，未被清理掉，虚拟机内存中所有通过旧引用地址访问的代码便仍然可用，都会被自动转发到新对象上继续工作，</p>
<p>指针转发如图：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-shen-andoah-brooks-pointer.jpg" alt="指针转发示意图"></p>
<blockquote>
<p>Brooks形式的转发指针在设计上决定了它是必然会出现多线程竞争问题的，如果收集器线程与用户线程发生的只是并发读取，那无论读到旧对象还是新对象上的字段，返回的结果都应该是一样的，这个场景还可以有一些“偷懒”的处理余地；但如果发生的是并发写入，就一定必须保证写操作只能发生在新复制的对象上，而不是写入旧对象的内存中。以下三件事情并发进行时：</p>
</blockquote>
<p>1）收集器线程复制了新的对象副本；<br>2）用户线程更新对象的某个字段；<br>3）收集器线程更新转发指针的引用值为新副本地址。</p>
<blockquote>
<p>如果不做任何保护措施，让事件2在事件1、事件3之间发生的话，将导致的结果就是用户线程对对象的变更发生在旧对象上，所以这里必须针对转发指针的访问操作采取同步措施，让收集器线程或者用户线程对转发指针的访问只有其中之一能够成功，另外一个必须等待，避免两者交替进行。实际上Shenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性的。</p>
</blockquote>
<blockquote>
<p>CAS：compare and swap，解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>
</blockquote>
<p><strong>转发指针和句柄定位比较</strong>：</p>
<table>
    <th>
        <td>转发指针</td>
        <td>句柄定位</td>
    </th>
    <tr>
        <td rowspan="2">不同</td>
        <td>分散存放在每一个对象头前面</td>
        <td>统一存储在专门的句柄池中</td>
    </tr>
    <tr><td>出现多线程竞争问题</td>
    <td></td>
</tr>
<tr>
    <td>相同</td>
    <td colspan="2">间接性的对象访问方式；对象访问会带来一次额外的转向开销</td>
</tr>
    </table>


<p><strong>内存保护陷阱</strong>扩展了解：</p>
<p>在此之前，实现类似的并发操作，通常是在被移动对象原有的内存上设置保护陷阱（Memory Protection Trap），一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中段，进入预设好的异常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上。虽然确实能够实现对象移动与用户线程并发，但是如果没有操作系统层面的直接支持，这种方案将导致用户态频繁切换到核心态。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM LLGC：ZGC</title>
    <url>/posts/e3d9aed7.html</url>
    <content><![CDATA[<h2 id="jvm低延迟垃圾收集器-ZGC"><a href="#jvm低延迟垃圾收集器-ZGC" class="headerlink" title="jvm低延迟垃圾收集器 ZGC"></a>jvm低延迟垃圾收集器 ZGC</h2><p>EN： JVM Low-Latency Garbage Collector : Z Garbage Collector</p>
<h3 id="一-、ZGC简介"><a href="#一-、ZGC简介" class="headerlink" title="一 、ZGC简介"></a>一 、ZGC简介</h3><p>一款在JDK 11中新加入的具有实验性质[插图]的低延迟垃圾收集器，是由Oracle公司研发的。2018年Oracle创建了JEP 333将ZGC提交给OpenJDK。</p>
<h5 id="主要目标："><a href="#主要目标：" class="headerlink" title="主要目标："></a>主要目标：</h5><p>尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>
<p>演变简史：</p>
<p>Azul VM上的PGC（Pauseless GC） : </p>
<p>​    实现了标记和整理阶段都全程与用户线程并发运行的垃圾收集。</p>
<p>Zing VM上的C4 （Concurrent Continuously Compacting Collector） ：</p>
<p>​     在PGC之上增加了分代收集支持，大幅提升了收集器能够承受的对象分配速度。Azul的C4收集器实现了分代收集后，能够应对的对象分配速率就比不分代的PGC收集器提升了十倍之多。</p>
<p>PGC——》C4——》ZGC</p>
<p>特征简介：</p>
<p>ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。</p>
<h3 id="二-ZGC主要特征："><a href="#二-ZGC主要特征：" class="headerlink" title="二 ZGC主要特征："></a>二 ZGC主要特征：</h3><p>（1）以低延迟为首要目标。</p>
<p>（2）暂不支持分代的，无跨代引用。</p>
<p>（3）基于Region的堆内存布局。</p>
<p>（4）染色指针和读屏障实现并发整理算法。Colored Pointer。</p>
<p>（5）内存多重映射技术。</p>
<p>（6）支持“NUMA-Aware”的内存分配。(NUMA非统一内存访问架构)</p>
<h3 id="三-ZG内存布局"><a href="#三-ZG内存布局" class="headerlink" title="三  ZG内存布局"></a>三  ZG内存布局</h3><p>ZGC在x64硬件平台下的内存布局如图：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-zgc-2.jpg" alt="ZGC的堆内存布局(彩图)"></p>
<p>ZGC的Region / Page / ZPage 称为 Size Groups ,</p>
<p>大致分三种类：</p>
<p>（A）小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</p>
<p>（B）中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</p>
<p>（C）大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配。</p>
<h3 id="四-并发整理实现：染色指针"><a href="#四-并发整理实现：染色指针" class="headerlink" title="四 并发整理实现：染色指针"></a>四 并发整理实现：染色指针</h3><p>染色指针技术（Colored Pointer   、Tag Pointer或者Version Pointer）是ZGC的标志性设计。</p>
<p>染色指针是一种直接将少量额外的信息存储在指针上的技术。在ZGC中使用染色指针直接把标记信息记在引用对象的指针上。</p>
<p>前提条件：内存多重映射（Multi-Mapping）技术。</p>
<p>染色指针带来的不利：</p>
<p>​    染色指针有4TB的内存限制，不能支持32位平台，不能支持压缩指针。</p>
<p>染色指针带来的优势：</p>
<p>​    （1）染色指针可以使某个Region的存活对象被移走之后，该Region立即就能够被释放和重用掉。</p>
<p>​    （2）染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量。只使用了读屏障（染色指针+无分代引用）</p>
<p>​    （3）染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</p>
<h3 id="五-ZGC收集工作过程"><a href="#五-ZGC收集工作过程" class="headerlink" title="五 ZGC收集工作过程"></a>五 ZGC收集工作过程</h3><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-zgc-job.jpg" alt="ZGC收集工作过程"></p>
<p>ZGC收集工作全部四个阶段都是可以并发执行的。仅在两个阶段中间会存在短暂的停顿小阶段。</p>
<h4 id="1-并发标记（Concurrent-Mark）"><a href="#1-并发标记（Concurrent-Mark）" class="headerlink" title="1 并发标记（Concurrent Mark）"></a>1 并发标记（Concurrent Mark）</h4><p>（A）遍历对象图做可达性分析的阶段。（初始标记、最终标记）</p>
<p>（B）标记过程是面向全堆的，有短暂停顿。</p>
<p>（C）ZGC的标记不标记对象，会更新染色指针中的Marked 0、Marked 1标志位。</p>
<h4 id="2-并发预备重分配（Concurrent-Prepare-for-Relocate）"><a href="#2-并发预备重分配（Concurrent-Prepare-for-Relocate）" class="headerlink" title="2 并发预备重分配（Concurrent Prepare for Relocate）"></a>2 并发预备重分配（Concurrent Prepare for Relocate）</h4><p>（A）统计要清理的Region/ size groups, 组成重分配集（Relocation Set）</p>
<p>（B）统计范围是面向全堆的。</p>
<p>（C）在JDK 12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。</p>
<h4 id="3-并发重分配（Concurrent-Relocate）"><a href="#3-并发重分配（Concurrent-Relocate）" class="headerlink" title="3 并发重分配（Concurrent Relocate）"></a>3 并发重分配（Concurrent Relocate）</h4><p>（A）是ZGC执行过程的核心阶段。</p>
<p>（B）把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。</p>
<p>（C）指针自愈（Self-Healing）</p>
<p>因为染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。</p>
<pre><code>Shenandoah转发指针与ZGC染色指针比较：
    Shenandoah的Brooks转发指针每次都要转发。
    ZGC的染色指针可以指针自愈，只转发一次。</code></pre><h4 id="4-并发重映射（Concurrent-Remap）"><a href="#4-并发重映射（Concurrent-Remap）" class="headerlink" title="4 并发重映射（Concurrent Remap）"></a>4 并发重映射（Concurrent Remap）</h4><p>（A）修正整个堆中指向重分配集中旧对象的所有引用。（类似Shenandoah的引用更新）</p>
<p>（B）重映射清理这些旧引用的主要目的是为了不变慢，还可以释放转发表。</p>
<p>（C）并发重映射阶段要做的工作合并到下一次垃圾收集循环中的并发标记阶段里去完成。</p>
<h3 id="六-ZGC优缺点"><a href="#六-ZGC优缺点" class="headerlink" title="六 ZGC优缺点"></a>六 ZGC优缺点</h3><p>1.（与其他收集器相比）优点：</p>
<p>（1）动态的Region布局。</p>
<p>（2）无记忆集，不占大量内存。</p>
<p>（3）无分代，无卡表，无写屏障。（染色指针）</p>
<p>（4）支持“NUMA-Aware”的内存分配。NUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种为多处理器或者多核处理器的计算机所设计的内存架构</p>
<p>2.（与其他收集器相比）缺点：</p>
<p>（1）堆空间较大时，并发收集的周期较长，浮动垃圾多，对象分配速率不会太高。</p>
<p>（2）需要较大的堆（Heap）容量。</p>
<h3 id="七-性能及前景"><a href="#七-性能及前景" class="headerlink" title="七 性能及前景"></a>七 性能及前景</h3><p>目前处于测试阶段。ZGC与Parallel Scavenge、G1三款收集器通过SPECjbb 2015 的测试结果如下：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-zgc-compare1.jpg" alt="ZGC的吞吐量测试"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-zgc-compare2.jpg" alt="ZGC的停顿时间测试"></p>
<p>（1）ZGC的“弱项”吞吐量</p>
<p>在ZGC的“弱项”吞吐量方面，以低延迟为首要目标的ZGC已经达到了以高吞吐量为目标Parallel Scavenge的99%，直接超越了G1。如果将吞吐量测试设定为面向SLA（Service LevelAgreements）应用的“Critical Throughput”的话[插图]，ZGC的表现甚至还反超了ParallelScavenge收集器。</p>
<p>（2）ZGC的强项停顿时间</p>
<p>ZGC的强项停顿时间测试上，它就毫不留情地与Parallel Scavenge、G1拉开了两个数量级的差距。不论是平均停顿，还是95%停顿、99%停顿、99.9%停顿，抑或是最大停顿时间，ZGC均能毫不费劲地控制在十毫秒之内。ZGC的停顿时间测试图中a）是ZGC的柱状条，b）纵坐标从线性尺度调整成对数尺度。</p>
<p>（3）将会成为服务端、大内存、低延迟应用的首选收集器的有力竞争者。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之字节码指令</title>
    <url>/posts/a2ceb3e5.html</url>
    <content><![CDATA[<h2 id="jvm字节码指令"><a href="#jvm字节码指令" class="headerlink" title="jvm字节码指令"></a>jvm字节码指令</h2><blockquote>
<p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。</p>
<p>Java虚拟机采用面向操作数栈，而不是面向寄存器的架构，大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。</p>
</blockquote>
<p>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构。</p>
<blockquote>
<p>放弃了操作数长度对齐[插图]，就意味着可以省略掉大量的填充和间隔符号；用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。这种追求尽可能小数据量、高传输效率的设计是由Java语言设计之初主要面向网络、智能家电的技术背景所决定的，并一直沿用至今。</p>
</blockquote>
<p>如果不考虑异常处理的话，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效正确地工作：</p>
<pre class=" language-txt"><code class="language-txt">do {
    自动计算PC寄存器的值加1;
    根据PC寄存器指示的位置，从字节码流中取出操作码;
    if (字节码存在操作数) 从字节码流中取出操作数;
    执行操作码所定义的操作;
} while (字节码流长度 > 0);</code></pre>
<h3 id="一、字节码与数据类型"><a href="#一、字节码与数据类型" class="headerlink" title="一、字节码与数据类型"></a>一、字节码与数据类型</h3><p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。举个例子，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。也有一些指令的助记符中没有明确指明操作类型的字母，例如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，例如无条件跳转指令goto则是与数据类型无关的指令。</p>
<p>Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持，这种特效称为：“Not Orthogonal”，并非每种数据类型和每一种操作都有对应的指令。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p>
<p>Java虚拟机指令集所支持的数据类型：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-bytecode/jvm-6-bytecode-dataType.jpg" alt="java虚拟机指令集所支持的数据类型"></p>
<p>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。</p>
<p>多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。</p>
<p><a href="ee62cca5.html">《Java虚拟机规范（Java SE 7）》中文版》</a></p>
<h3 id="二、加载和存储指令"><a href="#二、加载和存储指令" class="headerlink" title="二、加载和存储指令"></a>二、加载和存储指令</h3><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括：</p>
<p>将一个局部变量加载到操作栈：</p>
<p><code>iload</code>、<code>iload_&lt;n&gt;</code>、<code>lload</code>、<code>lload_&lt;n&gt;</code>、<code>fload</code>、<code>fload_&lt;n&gt;</code>、<code>dload</code>、<code>dload_&lt;n&gt;</code>、<code>aload</code>、<code>aload_&lt;n&gt;</code></p>
<p>将一个数值从操作数栈存储到局部变量表：</p>
<p><code>istore</code>、<code>istore_&lt;n&gt;</code>、<code>lstore</code>、<code>lstore_&lt;n&gt;</code>、<code>fstore</code>、<code>fstore_&lt;n&gt;</code>、<code>dstore</code>、<code>dstore_&lt;n&gt;</code>、<code>astore</code>、<code>astore_&lt;n&gt;</code></p>
<p>将一个常量加载到操作数栈：<code>bipush</code>、<code>sipush</code>、<code>ldc</code>、<code>ldc_w</code>、<code>ldc2_w</code>、<code>aconst_null</code>、<code>iconst_m1</code>、<code>iconst_&lt;i&gt;</code>，<code>lconst_&lt;l&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code></p>
<p>扩充局部变量表的访问索引的指令：wide</p>
<p>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p>
<p>以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>），这些指令助记符实际上代表了一组指令（例如<code>iload_&lt;n&gt;</code>，它代表了<code>iload_0</code>、<code>iload_1</code>、<code>iload_2</code>和<code>iload_3</code>这几条指令）。</p>
<p>这几组指令都是某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。</p>
<h3 id="三、运算指令"><a href="#三、运算指令" class="headerlink" title="三、运算指令"></a>三、运算指令</h3><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
<p>运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。</p>
<p>运算指令都是用Java虚拟机的算术类型来进行计算，不存在直接支持byte、short、char和boolean类型的算术指令，他们的运算都使用int类型的指令代替。</p>
<p>所有的算术指令包括：</p>
<p>加法指令：<code>iadd</code>、<code>ladd</code>、<code>fadd</code>、<code>dadd</code></p>
<p>减法指令：<code>isub</code>、<code>lsub</code>、<code>fsub</code>、<code>dsub</code></p>
<p>乘法指令：<code>imul</code>、<code>lmul</code>、<code>fmul</code>、<code>dmul</code></p>
<p>除法指令：<code>idiv</code>、<code>ldiv</code>、<code>fdiv</code>、<code>ddiv</code></p>
<p>求余指令：<code>irem</code>、<code>lrem</code>、<code>frem</code>、<code>drem</code></p>
<p>取反指令：<code>ineg</code>、<code>lneg</code>、<code>fneg</code>、<code>dneg</code></p>
<p>位移指令：<code>ishl</code>、<code>ishr</code>、<code>iushr</code>、<code>lshl</code>、<code>lshr</code>、<code>lushr</code></p>
<p>按位或指令：<code>ior</code>、<code>lor</code></p>
<p>按位与指令：<code>iand</code>、<code>land</code></p>
<p>按位异或指令：<code>ixor</code>、<code>lxor</code></p>
<p>局部变量自增指令：<code>iinc</code></p>
<p>比较指令：<code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>lcmp</code></p>
<p>《Java虚拟机规范》规定了在处理整型数据时，只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）中当出现除数为零时会导致虚拟机抛出<code>ArithmeticException</code>异常，其余任何整型数运算场景都不应该抛出运行时异常。</p>
<blockquote>
<p>Java虚拟机必须完全支持IEEE 754中定义的“非正规浮点数值”（Denormalized Floating-Point Number）和“逐级下溢”（Gradual Underflow）的运算规则。这些规则将会使某些数值算法处理起来变得明确，不会出现模棱两可的困境。譬如以上规则要求Java虚拟机在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值；如果有两种可表示的形式与该值一样接近，那将优先选择最低有效位为零的。这种舍入模式也是IEEE 754规范中的默认舍入模式，称为向最接近数舍入模式。而在把浮点数转换为整数时，Java虚拟机使用IEEE 754标准中的向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近，但是不大于原值的数字来作为最精确的舍入结果。</p>
</blockquote>
<p>浮点异常</p>
<blockquote>
<p>Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是Java语言中的异常，不可与IEEE 754规范中的浮点异常互相混淆，IEEE 754的浮点异常是一种运算信号），当一个操作产生溢出时，将会使用有符号的无穷大来表示；如果某个操作结果没有明确的数学定义的话，将会使用<code>NaN</code>（Not a Number）值来表示。所有使用<code>NaN</code>值作为操作数的算术操作，结果都会返回<code>NaN</code>。</p>
</blockquote>
<p>Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是Java语言中的异常，请读者勿与IEEE 754规范中的浮点异常互相混淆，IEEE 754的浮点异常是一种运算信号），当一个操作产生溢出时，将会使用有符号的无穷大来表示；如果某个操作结果没有明确的数学定义的话，将会使用NaN（Not a Number）值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</p>
<h3 id="四、类型转换指令"><a href="#四、类型转换指令" class="headerlink" title="四、类型转换指令"></a>四、类型转换指令</h3><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
<p>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）：</p>
<p>int类型到long、float或者double类型</p>
<p>long类型到float、double类型</p>
<p>float类型到double类型</p>
<p>与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括<code>i2b</code>、<code>i2c</code>、<code>i2s</code>、<code>l2i</code>、<code>f2i</code>、<code>f2l</code>、<code>d2i</code>、<code>d2l</code>和<code>d2f</code>。</p>
<p>窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p>
<p>在将<code>int</code>或<code>long</code>类型窄化转换为整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。对于了解计算机数值存储和表示的程序员来说这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低N字节的首位了。</p>
<p>Java虚拟机将一个浮点值窄化转换为整数类型T（T限于<code>int</code>或<code>long</code>类型之一）的时候，必须遵循以下转换规则：</p>
<p>（a）如果浮点值是<code>NaN</code>，那转换结果就是int或long类型的0。</p>
<p>（b）如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v。如果v在目标类型T（int或long）的表示范围之类，那转换结果就是v；否则，将根据v的符号，转换为T所能表示的最大或者最小正数。</p>
<p>从double类型到float类型做窄化转换的过程与IEEE 754中定义的一致，通过IEEE 754向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。如果转换结果的绝对值太小、无法使用float来表示的话，将返回float类型的正负零；如果转换结果的绝对值太大、无法使用float来表示的话，将返回float类型的正负无穷大。对于double类型的NaN值将按规定转换为float类型的NaN值。</p>
<p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是《Java虚拟机规范》中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</p>
<h3 id="五、对象创建与访问指令"><a href="#五、对象创建与访问指令" class="headerlink" title="五、对象创建与访问指令"></a>五、对象创建与访问指令</h3><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在下一章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p>
<p>（a）创建类实例的指令：<code>new</code></p>
<p>（b）创建数组的指令：<code>newarray</code>、<code>anewarray</code>、<code>multianewarray</code></p>
<p>（c）访问类字段（<code>static</code>字段，或者称为类变量）和实例字段（非<code>static</code>字段，或者称为实例变量）的指令：<code>getfield</code>、<code>putfield</code>、<code>getstatic</code>、<code>putstatic</code></p>
<p>（d）把一个数组元素加载到操作数栈的指令：<code>baload</code>、<code>caload</code>、<code>saload</code>、<code>iaload</code>、<code>laload</code>、<code>faload</code>、<code>daload</code>、<code>aaload</code></p>
<p>（e）将一个操作数栈的值储存到数组元素中的指令：<code>bastore</code>、<code>castore</code>、<code>sastore</code>、<code>iastore</code>、<code>fastore</code>、<code>dastore</code>、<code>aastore</code></p>
<p>（f）取数组长度的指令：<code>arraylength</code></p>
<p>（g）检查类实例类型的指令：<code>instanceof</code>、<code>checkcast</code></p>
<h3 id="六、操作数栈管理指令"><a href="#六、操作数栈管理指令" class="headerlink" title="六、操作数栈管理指令"></a>六、操作数栈管理指令</h3><p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p>
<p>（a）将操作数栈的栈顶一个或两个元素出栈：<code>pop</code>、<code>pop2</code></p>
<p>（b）复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：<code>dup</code>、<code>dup2</code>、<code>dup_x1</code>、<code>dup2_x1</code>、<code>dup_x2</code>、<code>dup2_x2</code></p>
<p>（c）将栈最顶端的两个数值互换：<code>swap</code></p>
<h3 id="七、控制转移指令"><a href="#七、控制转移指令" class="headerlink" title="七、控制转移指令"></a>七、控制转移指令</h3><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令包括：</p>
<p>（a）条件分支：<code>ifeq</code>、<code>iflt</code>、<code>ifle</code>、<code>ifne</code>、<code>ifgt</code>、<code>ifge</code>、<code>ifnull</code>、<code>ifnonnull</code>、<code>if_icmpeq</code>、<code>if_icmpne</code>、<code>if_icmplt</code>、<code>if_icmpgt</code>、<code>if_icmple</code>、<code>if_icmpge</code>、<code>if_acmpeq和if_acmpne</code></p>
<p>（b）复合条件分支：<code>tableswitch</code>、<code>lookupswitch</code></p>
<p>（c）无条件分支：<code>goto</code>、<code>goto_w</code>、<code>jsr</code>、<code>jsr_w</code>、<code>ret</code></p>
<p>Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个数据的值是否null，也有专门的指令用来检测null值。</p>
<blockquote>
<p>对于boolean类型、byte类型、char类型和short类型的条件分支比较操作，都使用int类型的比较指令来完成，而对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp），运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。由于各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便、完善就显得尤为重要，而Java虚拟机提供的int类型的条件分支指令是最为丰富、强大的。</p>
</blockquote>
<h3 id="八、方法调用和返回指令"><a href="#八、方法调用和返回指令" class="headerlink" title="八、方法调用和返回指令"></a>八、方法调用和返回指令</h3><p>指令用于方法调用：</p>
<p>（a）<code>invokevirtual</code>指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</p>
<p>（b）<code>invokeinterface</code>指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</p>
<p>（c）<code>invokespecial</code>指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</p>
<p>（d）<code>invokestatic</code>指令：用于调用类静态方法（static方法）。</p>
<p>（e）<code>invokedynamic</code>指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而<code>invokedynamic</code>指令的分派逻辑是由用户所设定的引导方法决定的。</p>
<p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括<code>ireturn</code>（当返回值是<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>和<code>int</code>类型时使用）、<code>lreturn</code>、<code>freturn</code>、<code>dreturn</code>和<code>areturn</code>，另外还有一条return指令供声明为<code>void</code>的方法、实例初始化方法、类和接口的类初始化方法使用。</p>
<h3 id="九、异常指令"><a href="#九、异常指令" class="headerlink" title="九、异常指令"></a>九、异常指令</h3><p>Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成。</p>
<h3 id="十、同步指令"><a href="#十、同步指令" class="headerlink" title="十、同步指令"></a>十、同步指令</h3><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（<code>Monitor</code>，更常见的是直接将它称为“锁”）来实现的。</p>
<p>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的<code>ACC_SYNCHRONIZED</code>访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p>
<p>同步一段指令集序列通常是由Java语言中的<code>synchronized</code>语句块来表示的，Java虚拟机的指令集中有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持<code>synchronized</code>关键字的语义，正确实现<code>synchronized</code>关键字需要Javac编译器与Java虚拟机两者共同协作支持</p>
<p>java代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">onlyMe</span><span class="token punctuation">(</span>Foo f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对应的字节码清单：</p>
<pre class=" language-txt"><code class="language-txt">Method void onlyMe(Foo)
0 aload_1                         // 将对象f入栈
1 dup                           // 复制栈顶元素（即f的引用）
2 astore_2                        // 将栈顶元素存储到局部变量表变量槽 2中
3 monitorenter                    // 以栈定元素（即f）作为锁，开始同步
4 aload_0                         // 将局部变量槽 0（即this指针）的元素入栈
5 invokevirtual #5                // 调用doSomething()方法
8 aload_2                         // 将局部变量Slow 2的元素（即f）入栈
9 monitorexit                     // 退出同步
10 goto 18                        // 方法正常结束，跳转到18返回
13 astore_3                       // 从这步开始是异常路径，见下面异常表的Taget 13
14 aload_2                        // 将局部变量Slow 2的元素（即f）入栈
15 monitorexit                    // 退出同步
16 aload_3                        // 将局部变量Slow 3的元素（即异常对象）入栈
17 athrow                         // 把异常对象重新抛出给onlyMe()方法的调用者
18 return                         // 方法正常返回

Exception table:
FromTo Target Type
   4    10     13 any
  13    16     13 any</code></pre>
<p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条<code>monitorenter</code>指令都必须有其对应的<code>monitorexit</code>指令，而无论这个方法是正常结束还是异常结束。</p>
<p>为了保证在方法异常完成时<code>monitorenter</code>和<code>monitorexit</code>指令依然可以正确配对执行，编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行<code>monitorexit</code>指令。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>字节码指令</tag>
      </tags>
  </entry>
  <entry>
    <title>java模块化系统</title>
    <url>/posts/49b8efd0.html</url>
    <content><![CDATA[<h2 id="Java模块化系统"><a href="#Java模块化系统" class="headerlink" title="Java模块化系统"></a>Java模块化系统</h2><p>Java模块化系统（Java Platform Module System，JPMS）是在JDK 9中引入的。</p>
<h3 id="1、封装隔离机制"><a href="#1、封装隔离机制" class="headerlink" title="1、封装隔离机制"></a>1、封装隔离机制</h3><p>主要是为了实现可配置的封装隔离机制。</p>
<p>Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。</p>
<p>JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容：</p>
<p>（1）依赖其他模块的列表。</p>
<p>（2）导出的包列表，即其他模块可以使用的列表。</p>
<p>（3）开放的包列表，即其他模块可反射访问模块的列表。</p>
<p>（4）使用的服务列表。</p>
<p>（5）提供服务的实现列表。</p>
<p>可配置的封装隔离机制作用：</p>
<p>（1）解决JDK 9之前基于类路径（ClassPath）来查找依赖的可靠性问题。</p>
<blockquote>
<p>在JDK 9之前前，如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接时才会报出运行的异常。</p>
<p>在JDK 9以后，如果启用了模块化进行封装，模块就可以声明对其他模块的显式依赖，Java虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了大部分由于类型依赖而引发的运行时异常。</p>
</blockquote>
<p>（2）解决原来类路径上跨JAR文件的public类型的可访问性问题。</p>
<blockquote>
<p>JDK 9中的public类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更精细的可访问性控制，必须明确声明其中哪一些public的类型可以被其他哪一些模块访问，这种访问控制也主要是在类加载过程中完成的。</p>
</blockquote>
<h3 id="2、模块的兼容性"><a href="#2、模块的兼容性" class="headerlink" title="2、模块的兼容性"></a>2、模块的兼容性</h3><p>（一）向下兼容</p>
<p>为了实现可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK 9提出了与“类路径”（ClassPath）相对应的“模块路径”（ModulePath）的概念。</p>
<blockquote>
<p>就是一个类库到底是模块还是传统的JAR包，只取决于它存放在哪种路径上。</p>
<p>只要放在类路径上的JAR文件，无论其中是否包含模块化信息（是否包含了module-info.class文件），它都会被当作传统的JAR包来对待；</p>
<p>只要放在模块路径上的JAR文件，即使没有使用JMOD后缀，甚至说其中并不包含module-info.class文件，它也仍然会被当作一个模块来对待。</p>
</blockquote>
<p>传统类路径依赖的Java程序可以不经修改地直接运行在JDK 9及以后的Java版本上，模块化系统提供的运行规则：</p>
<p>（1）JAR文件在类路径的访问规则。</p>
<blockquote>
<p>所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</p>
</blockquote>
<p>（2）模块在模块路径的访问规则</p>
<blockquote>
<p>模块路径下的具名模块（Named Module）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。</p>
</blockquote>
<p>（3）JAR文件在模块路径的访问规则</p>
<blockquote>
<p>如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</p>
</blockquote>
<p>这3条规则保证了即使Java应用依然使用传统的类路径，升级到JDK 9对应用来说几乎不会有任何感觉，项目也不需要专门为了升级JDK版本而去把传统JAR包升级成模块。</p>
<p>（二）模块直接的兼容</p>
<p>模块间的管理和兼容性问题：</p>
<p>当同一个模块发行了多个不同的版本，那只能由开发者在编译打包时人工选择好正确版本的模块来保证依赖的正确性。</p>
<p>暂不支持在模块定义中加入版本号来管理和约束依赖，本身也不支持多版本号的概念和版本选择功能。</p>
<p>但是查看模块列表（<code>java--list-modules</code>）时可以看到版本信息。</p>
<p>编译时使用“javac–module-version”可以用来指定模块版本。</p>
<p><code>java.lang.module.ModuleDescriptor.Version</code>接口可以在运行时获取到模块的版本号。</p>
<h3 id="3、模块化下的类加载器"><a href="#3、模块化下的类加载器" class="headerlink" title="3、模块化下的类加载器"></a>3、模块化下的类加载器</h3><p>为了保证兼容性，JDK 9类加载依旧使用三层类加载器架构以及双亲委派模型。</p>
<p>（一）模块类加载器变动</p>
<p>但模块化下的类加载器有变化：</p>
<p>（1）扩展类加载器（Extension Class Loader）被平台类加载器（Platform ClassLoader）取代。</p>
<p>取消 <code>&lt;JAVA_HOME&gt;\lib\ext</code>目录、<code>&lt;JAVA_HOME&gt;\jre</code>目录，可以借助模块以组合构建出程序运行所需的JRE,如只使用java.base模块中的类型，可以构建需要的包：</p>
<pre class=" language-bash"><code class="language-bash">jlink -p <span class="token variable">$JAVA_HOME</span>/jmods --add-modules java.base --output jre</code></pre>
<p>（2）平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader。</p>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader，在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</p>
<blockquote>
<p>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p>
</blockquote>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-module/jdk-9-before.jpg" alt="JDK9之前的类加载器继承结构"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-module/jdk-9-after.jpg" alt="JDK9之后的类加载器继承结构"></p>
<p>（3）JDK 9中类加载的委派关系也发生了变动。</p>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，也许这可以算是对双亲委派的第四次破坏。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-module/jdk-9-classLoad.jpg" alt="JDK9后的类加载器委派关系"></p>
<p>（二）类加载器负责模块</p>
<p>三个类加载器负责各自加载的模块:</p>
<p>（a）启动类加载器负责加载的模块：</p>
<pre class=" language-txt"><code class="language-txt">java.base                        java.security.sasl
java.datatransfer                java.xml
java.desktop                     jdk.httpserver
java.instrument                  jdk.internal.vm.ci
java.logging                     jdk.management
java.management                  jdk.management.agent
java.management.rmi              jdk.naming.rmi
java.naming                      jdk.net
java.prefs                       jdk.sctp
java.rmi                         jdk.unsupported</code></pre>
<p>（b）平台类加载器负责加载的模块：</p>
<pre class=" language-txt"><code class="language-txt">java.activation*                jdk.accessibility
java.compiler*                  jdk.charsets
java.corba*                     jdk.crypto.cryptoki
java.scripting                  jdk.crypto.ec
java.se                         jdk.dynalink
java.se.ee                      jdk.incubator.httpclient
java.security.jgss              jdk.internal.vm.compiler*
java.smartcardio                jdk.jsobject
java.sql                        jdk.localedata
java.sql.rowset                 jdk.naming.dns
java.transaction*               jdk.scripting.nashorn
java.xml.bind*                  jdk.security.auth
java.xml.crypto                 jdk.security.jgss
java.xml.ws*                    jdk.xml.dom
java.xml.ws.annotation*         jdk.zipfs</code></pre>
<p>（c）应用程序类加载器负责加载的模块：</p>
<pre class=" language-txt"><code class="language-txt">jdk.aot                         jdk.jdeps
jdk.attach                      jdk.jdi
jdk.compiler                    jdk.jdwp.agent
jdk.editpad                     jdk.jlink
jdk.hotspot.agent               jdk.jshell
jdk.internal.ed                 jdk.jstatd
jdk.internal.jvmstat            jdk.pack
jdk.internal.le                 jdk.policytool
jdk.internal.opt                jdk.rmic
jdk.jartool                     jdk.scripting.nashorn.shell
jdk.javadoc                     jdk.xml.bind*
jdk.jcmd                        jdk.xml.ws*
jdk.jconsole</code></pre>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>模块化系统</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之垃圾收集器</title>
    <url>/posts/d01dbbb1.html</url>
    <content><![CDATA[<h2 id="jvm-垃圾收集器"><a href="#jvm-垃圾收集器" class="headerlink" title="jvm 垃圾收集器"></a>jvm 垃圾收集器</h2><h2 id="一-关于垃圾收集器"><a href="#一-关于垃圾收集器" class="headerlink" title="一 关于垃圾收集器"></a>一 关于垃圾收集器</h2><blockquote>
<p>垃圾收集器是垃圾回收算法（标记-清除算法、标记-复制算法、标记-整理算法、半复制算法）的具体实现，不同商家、不同版本的JVM所提供的垃圾收集器可能会有很在差别，本文主要介绍HotSpot虚拟机中的垃圾收集器。</p>
</blockquote>
<p>相关术语</p>
<h3 id="1-并行与并发"><a href="#1-并行与并发" class="headerlink" title="1. 并行与并发"></a>1. 并行与并发</h3><table>
<thead>
<tr>
<th>并行（Parallel）</th>
<th>并发（Concurrent）</th>
</tr>
</thead>
<tbody><tr>
<td>指多条垃圾收集线程同一时间并行协同工作，此时用户线程仍然处于等待状态；如ParNew、Parallel Scavenge、Parallel Old；</td>
<td>指用户线程与垃圾收集线程同时都在执行（但不一定是并行的，可能会交替执行）；用户程序在继续运行，未被冻结，程序仍然能响应服务请求。垃圾收集程序线程占用系统资源。如CMS、G1（也有并行）；</td>
</tr>
</tbody></table>
<h3 id="2-部分收集和整堆收集"><a href="#2-部分收集和整堆收集" class="headerlink" title="2. 部分收集和整堆收集"></a>2. 部分收集和整堆收集</h3><p>（1）部分收集（Partial GC）：</p>
<p>​    指目标不是完整收集整个Java堆的垃圾收集。主要三种：</p>
<p>​    A. 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。<br>​    B. 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。</p>
<p>​    C. 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。    </p>
<p>（2）整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p>
<blockquote>
<p><strong>注意</strong>：“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，请按资料上下文区分到底是指老年代的收集还是整堆收集。因为有的Major GC表示老年代GC有的表示整堆GC。</p>
</blockquote>
<h3 id="3-收集器的指标"><a href="#3-收集器的指标" class="headerlink" title="3. 收集器的指标"></a>3. 收集器的指标</h3><p>收集器的指标一般体现在设计它的目的上，如：Parallel Scavenge收集器首要目标是吞吐量。</p>
<p>主要权衡指标有三个：</p>
<p>（A）低延迟</p>
<p>（B）吞吐量</p>
<p>（C）较小的内存占用</p>
<h2 id="二-Hotspot七种垃圾收集器"><a href="#二-Hotspot七种垃圾收集器" class="headerlink" title="二 Hotspot七种垃圾收集器"></a>二 Hotspot七种垃圾收集器</h2><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gcr-1.jpg" alt="常见的七种垃圾收集器"><br>（图片来自《深入理解java虚拟机:jvm高级特性与最佳实践 》第三版。JVM系列黑白图均来自电子书，彩图来自网络）</p>
<p>图中是七种作用于不同分代的收集器。<br>如果两个收集器之间存在连线，就说明它们可以搭配使用。<br>图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。<br>其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</p>
<p>整理成表格如下：</p>
<table>
<thead>
<tr>
<th>收集区域</th>
<th>收集器</th>
</tr>
</thead>
<tbody><tr>
<td>新生代收集器</td>
<td>Serial、ParNew、Parallel Scavenge</td>
</tr>
<tr>
<td>老年代收集器</td>
<td>Serial Old、Parallel Old、CMS</td>
</tr>
<tr>
<td>整堆收集器</td>
<td>G1</td>
</tr>
</tbody></table>
<h3 id="1、Serial-收集器"><a href="#1、Serial-收集器" class="headerlink" title="1、Serial 收集器"></a>1、Serial 收集器</h3><p>Serial 串口，串行的意思。</p>
<blockquote>
<p>Serial收集器是一个单线程工作的收集器。是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效。（高效是指与其他收集器的单线程相比）</p>
</blockquote>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>​    （1）针对新生代的收集器。<br>    （2）只会使用一个处理器或一条收集线程去完成垃圾收集工作，进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-5-gc-serial.jpg" alt="Serial收集器运行示意图"></p>
<h3 id="2、ParNew-收集器"><a href="#2、ParNew-收集器" class="headerlink" title="2、ParNew 收集器"></a>2、ParNew 收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本。其余的行为包括Serial收集器可用的所有控制参数（例如：<code>-XX：SurvivorRatio</code>、<code>-XX：PretenureSizeThreshold</code>、<code>-XX：HandlePromotionFailure</code>等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。二者共用许多代码。</p>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><p>​    （1）新生代收集器</p>
<p>​    （2）支持多线程并行收集。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-5-gc-ParNew.jpg" alt="ParNew/Serial Old收集器运行示意图"></p>
<p>ParNew收集器是激活CMS后（使用-XX：+UseConcMarkSweepGC选项）的默认新生代收集器，也可以使用-XX：+/-UseParNewGC选项来强制指定或者禁用它。</p>
<h3 id="3、Parallel-Scavenge-收集器"><a href="#3、Parallel-Scavenge-收集器" class="headerlink" title="3、Parallel Scavenge 收集器"></a>3、Parallel Scavenge 收集器</h3><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。早期只能和Serial Old搭配。不能和CMS搭配。</p>
<p>目标：</p>
<p>希望达到一个可控制的吞吐量（Throughput）。</p>
<p>Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。</p>
<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><p>（1）新生代收集器，基于标记-复制算法实现</p>
<p>（2）能够多线程并行收集</p>
<p>（3）停顿-吞吐量的自适应的调节策略。可以设定目标让收集器自行调节。</p>
<p>（4）支持NUMA(非统一内存访问架构)内存分配</p>
<p>运行示意图：</p>
<p>![Parallel Scavenge / Parallel Old收集器运行示意图](/images/jvm-images/jvm-5-gc-Parallel-Scavenge-or-Parallel Old.jpg)</p>
<blockquote>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX：GCTimeRatio</code>参数。</p>
</blockquote>
<blockquote>
<p><code>-XX：MaxGCPauseMillis</code>参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。</p>
</blockquote>
<blockquote>
<p><code>-XX：GCTimeRatio</code>参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间。</p>
</blockquote>
<p>停顿-吞吐量的自适应的调节策略：</p>
<blockquote>
<p>Parallel Scavenge收集器还有一个参数<code>-XX：+UseAdaptiveSizePolicy</code>值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（<code>-XX：SurvivorRatio</code>）、晋升老年代对象大小（<code>-XX：PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）.</p>
</blockquote>
<blockquote>
<p>把基本的内存数据设置好（如<code>-Xmx</code>设置最大堆），然后使用<code>-XX：MaxGCPauseMillis</code>参数（更关注最大停顿时间）或<code>-XX：GCTimeRatio</code>（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。</p>
</blockquote>
<h3 id="4、Serial-Old-收集器"><a href="#4、Serial-Old-收集器" class="headerlink" title="4、Serial Old  收集器"></a>4、Serial Old  收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>
<h4 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h4><p>（1）老年代收集器，</p>
<p>（2）单线程收集器，</p>
<p>（3）使用标记-整理算法。</p>
<p>使用环境：</p>
<p>客户端：主要供客户端模式下的HotSpot虚拟机使用。</p>
<p>服务端：（A）在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用；</p>
<p>​    （B）作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent ModeFailure时使用。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-5-gc-serial.jpg" alt="Serial/ Serial old 收集器运行示意图"></p>
<h3 id="5、Parallel-Old-收集器"><a href="#5、Parallel-Old-收集器" class="headerlink" title="5、Parallel Old 收集器"></a>5、Parallel Old 收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器是直到JDK 6时才开始提供的。</p>
<h4 id="特点：-4"><a href="#特点：-4" class="headerlink" title="特点："></a>特点：</h4><p>同Parallel Scavenge收集器。</p>
<p>“吞吐量优先”收集器：</p>
<blockquote>
<p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。     </p>
</blockquote>
<p>![Parallel Scavenge / Parallel Old收集器运行示意图](/images/jvm-images/jvm-5-gc-Parallel-Scavenge-or-Parallel Old.jpg)</p>
<h3 id="6、CMS-收集器"><a href="#6、CMS-收集器" class="headerlink" title="6、CMS  收集器"></a>6、CMS  收集器</h3><p>CMS : Concurrent Mark Sweep</p>
<p>官方文档称之为：“并发低停顿收集器”（Concurrent Low Pause Collector）</p>
<h4 id="特点：-5"><a href="#特点：-5" class="headerlink" title="特点："></a>特点：</h4><p>​    （1）以获取最短回收停顿时间为目标。</p>
<p>​    （2）基于标记-清除算法实现。</p>
<blockquote>
<p>关注服务的响应速度，希望系统停顿时间尽可能短,如B/S系统应用服务端，适合CMS收集器。</p>
</blockquote>
<p>CMS堆内存布局</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-5-gc-cms.png" alt="Concurrent Mark Sweep收集器运行示意图"></p>
<h5 id="CMS收集器工作过程："><a href="#CMS收集器工作过程：" class="headerlink" title="CMS收集器工作过程："></a>CMS收集器工作过程：</h5><p>运行示意图如下</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-5-gc-cms-workflow.jpg" alt="Concurrent Mark Sweep收集器运行示意图"></p>
<p>1）初始标记（CMS initial mark）</p>
<p>​    （A）标记一下GC Roots能直接关联到的对象，速度很快。</p>
<p>​    （B）有短暂停顿</p>
<p>2）并发标记（CMS concurrent mark）</p>
<p>​    （A）从GC Roots的直接关联对象开始遍历整个对象图的过程。</p>
<p>​    （B）该过程耗时较长，用户线程可以与垃圾收集线程一起并发运行</p>
<p>3）重新标记（CMS remark）</p>
<p>​    （A）修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</p>
<p>​    （B）有停顿，比初始标记停顿时间稍长，比并发标记阶段的时间短。</p>
<p>4）并发清除（CMS concurrent sweep）</p>
<p>​    （A）清理删除掉标记阶段判断的已经死亡的对象。</p>
<p>​    （B）不需要移动存活对象，可以与用户线程同时并发执行。</p>
<h4 id="CMS收集器优缺点："><a href="#CMS收集器优缺点：" class="headerlink" title="CMS收集器优缺点："></a>CMS收集器优缺点：</h4><p>优点：</p>
<p>​    并发收集、低停顿</p>
<p>缺点：</p>
<p>​    （1）对处理器资源非常敏感，并发阶段线程运行占用资源。</p>
<p>​    （2）无法处理并发标记和并发清理阶段产生的“浮动垃圾”（Floating Garbage）。有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。</p>
<p>​    （3）“标记-清除”算法实现带来的空间碎片问题。</p>
<blockquote>
<p><strong>浮动垃圾</strong>：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”</p>
</blockquote>
<p>因为浮动垃圾带来的问题怎么办？</p>
<blockquote>
<p>CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数<code>-XX：CMSInitiatingOccu-pancyFraction</code>的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。所以参数<code>-XX：CMSInitiatingOccupancyFraction</code>设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。</p>
</blockquote>
<h3 id="7、G1垃圾收集器"><a href="#7、G1垃圾收集器" class="headerlink" title="7、G1垃圾收集器"></a>7、G1垃圾收集器</h3><p>G1 : Garbage First</p>
<blockquote>
<p>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p>
<p>从JDK 6 Update 14开始就有Early Access版本的G1收集器供开发人员实验和试用，但由此开始G1收集器的“实验状态”（Experimental）持续了数年时间，直至JDK 7Update 4，Oracle才认为它达到足够成熟的商用程度，移除了“Experimental”的标识；到了JDK 8 Update 40的时候，G1提供并发的类卸载的支持，补全了其计划功能的最后一块拼图。这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”（Fully-FeaturedGarbage Collector）。</p>
<p>JDK9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。</p>
</blockquote>
<p>设计思路：</p>
<p>​    追求能够应付应用的内存分配速率（Allocation Rate），而不追求一次把整个Java堆全部清理干净。</p>
<blockquote>
<p>应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。这种新的收集器设计思路从工程实现上看是从G1开始兴起的。</p>
<p>G1是收集器技术发展的一个里程碑。也是jdk11的默认垃圾收集器。</p>
</blockquote>
<h4 id="特点：-6"><a href="#特点：-6" class="headerlink" title="特点："></a>特点：</h4><p>​    （1）面向服务端应用的垃圾收集器。</p>
<p>​    （2）基于Region的堆内存布局。</p>
<p>​    （3）使用Mixed GC模式，不再按“代”进行回收。（Region布局支持）</p>
<p>​    （4）遵循分代收集理论设计，新生代和老年代不再是固定大小与数理，只要求是逻辑连续的动态集合。</p>
<p>​    （5）回收策略是优先处理回收价值最大的Region</p>
<h4 id="内存布局图："><a href="#内存布局图：" class="headerlink" title="内存布局图："></a>内存布局图：</h4><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-5-gc-G1.png" alt="G1收集器堆内存布局"></p>
<blockquote>
<p>G1不再是固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。</p>
<p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数<code>-XX：G1HeapRegionSize</code>设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的<code>Humongous Region</code>之中，G1的大多数行为都把<code>Humongous Region</code>作为老年代的一部分来进行看待</p>
</blockquote>
<h4 id="G1收集器实现思路："><a href="#G1收集器实现思路：" class="headerlink" title="G1收集器实现思路："></a>G1收集器实现思路：</h4><p>（1）基于Region的堆内存布局,把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。</p>
<p>（2)将堆分成多个独立Region后，使用记忆集避免全堆作为GC Roots扫描，每个Region都维护有自己的记忆集，记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。</p>
<blockquote>
<p>G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。</p>
</blockquote>
<p>（3）在并发标记阶段，通过原始快照（SATB）算法来实现用户线程改变对象引用关系时，不打破原本的对象图结构。</p>
<p>（4）在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。</p>
<p>可预测的“停顿时间模型”（Pause Prediction Model）:</p>
<blockquote>
<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数<code>-XX：MaxGCPauseMillis</code>指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
</blockquote>
<blockquote>
<p>G1收集器的停顿预测模型是以衰减均值（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“最近的”平均状态。换句话说，Region的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</p>
</blockquote>
<p><code>-XX：MaxGCPauseMillis</code>-用户指定期望的停顿时间：</p>
<blockquote>
<p>用户指定期望的停顿时间是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。不过，这里设置的“期望值”必须是符合实际的，不能异想天开，毕竟G1是要冻结用户线程来复制对象的，这个停顿时间再怎么低也得有个限度。它默认的停顿目标为两百毫秒，一般来说，回收阶段占到几十到一百甚至接近两百毫秒都很正常，但如果我们把停顿时间调得非常低，譬如设置为二十毫秒，很可能出现的结果就是由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积。很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间，但应用运行时间一长就不行了，最终占满堆引发Full GC反而降低性能，所以通常把望期停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。</p>
</blockquote>
<h4 id="G1工作流程："><a href="#G1工作流程：" class="headerlink" title="G1工作流程："></a>G1工作流程：</h4><p>流程图如下：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-5-gc-G1-workflow.jpg" alt="G1收集器堆内存布局"></p>
<p>1、初始标记（Initial Marking）：<br>（A）只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</p>
<p>（B）该阶段需要停顿线程，但耗时很短。</p>
<blockquote>
<p>初始标记是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p>
</blockquote>
<p>2、并发标记（Concurrent Marking）：<br>（A）从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。</p>
<p>（B）这阶段耗时较长，可与用户程序并发执行。</p>
<p>（C）当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p>
<p>3、最终标记（Final Marking）</p>
<p>（A）对用户线程做另一个短暂的暂停，处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</p>
<p>4、筛选回收（Live Data Counting and Evacuation）</p>
<p>（A）负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。</p>
<p>（B）操作涉及存活对象的移动，必须暂停用户线程。</p>
<p>（C）筛选回收由多条收集器线程并行完成的。</p>
<h4 id="G1与CMS比较"><a href="#G1与CMS比较" class="headerlink" title="G1与CMS比较"></a>G1与CMS比较</h4><table>
<th><td width="50%">G1</td><td width="50%">CMS</td></th>
<tr><td rowspan="6">不同</td> <td>G1基于Region布局，实现分代。</td><td>CMS传统的分代布局。</td></tr>
<tr><td>G1可以设置最大停顿,关注点在吞吐量和延迟之间自行平衡或定制适应。</td><td>CMS以最小停顿为关注点。</td></tr>
<tr><td>G1按收益动态确定回收集。</td><td>CMS传统的按代回收。</td></tr>
<tr><td>G1整体基于“标记-整理”算法、局部（两个Region之间）基于“标记-复制”算法，运作期间不会产生内存空间碎片，利于程序长时间运行。</td><td>CMS基于“标记-清除”算法，产生空间碎片，导致Full GC ,用户线程挂起。</td></tr>
<tr><td>G1垃圾收集产生的内存占用（Footprint）和程序运行时的额外执行负载（Overload）。
    <br>【内存占用】：G1要维护堆中每个Region都有一份卡表。
    <br>【执行负载】：G1使用写前屏障来跟踪并发时的指针变化情况,实现原始快照搜索（SATB）算法;使用写后屏障来来更新维护结构更复杂的卡表，类似于消息队列的结构，是异步操作。</td><td>CMS的内存占用（Footprint）和执行负载（Overload）相对低些。
        <br>【内存占用】：CMS只维护新生代与老年代之间唯一的一份卡表。
        <br>【执行负载】：CMS用写后屏障来更新维护卡表，是同步操作。
<tr><td>G1相对适合大内存应用。</td><td>CMS相对适合小内存应用。临界（6G~8G）</td></tr>
<tr><td>相同</td> <td colspan="2">（1）都非常关注停顿时间的控制。<br>（2）都使用传统的分代理论。<br>（3）都使用卡表来处理跨代指针问题。</td></tr>
</table>




<h2 id="三-低延迟垃圾收集器"><a href="#三-低延迟垃圾收集器" class="headerlink" title="三 低延迟垃圾收集器"></a>三 低延迟垃圾收集器</h2><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-images/jvm-gc-LLGC.jpg" alt="各款收集器的并发情况"></p>
<p>其中 <strong>Shenandoah</strong> 和 <strong>ZGC</strong> ，这两款目前仍处于实验状态的收集器，被官方命名为“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time GarbageCollector）。</p>
<h3 id="1、Shenandoah收集器"><a href="#1、Shenandoah收集器" class="headerlink" title="1、Shenandoah收集器"></a>1、Shenandoah收集器</h3><h4 id="主要目标："><a href="#主要目标：" class="headerlink" title="主要目标："></a>主要目标：</h4><blockquote>
<p>实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。</p>
</blockquote>
<p>特点：</p>
<p>（1）基于Region的堆内存布局</p>
<p>（2）回收策略优先处理回收价值最大的Region</p>
<p>（3）支持并发的整理算法。</p>
<h4 id="三个重要的并发阶段："><a href="#三个重要的并发阶段：" class="headerlink" title="三个重要的并发阶段："></a>三个重要的并发阶段：</h4><p>并发标记、并发回收、并发引用更新。</p>
<p>具体更详细的学习笔记：<a href="f8161112.html">《jvm垃圾收集器Shenandoah》</a></p>
<h3 id="2、ZGC收集器"><a href="#2、ZGC收集器" class="headerlink" title="2、ZGC收集器"></a>2、<code>ZGC</code>收集器</h3><h4 id="主要目标：-1"><a href="#主要目标：-1" class="headerlink" title="主要目标："></a>主要目标：</h4><blockquote>
<p>尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>
</blockquote>
<h4 id="ZGC主要特征："><a href="#ZGC主要特征：" class="headerlink" title="ZGC主要特征："></a>ZGC主要特征：</h4><p>（1）以低延迟为首要目标。</p>
<p>（2）暂不支持分代的。</p>
<p>（3）基于Region的堆内存布局。</p>
<p>（4）染色指针实现并发整理算法。Colored Pointer。</p>
<p>（5）内存多重映射技术。</p>
<p>（6）支持“NUMA-Aware”的内存分配。(NUMA非统一内存访问架构)</p>
<p>具体更详细的学习笔记：<a href="e3d9aed7.html">《jvm垃圾收集器ZGC》</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm字节码执行引擎</title>
    <url>/posts/f6ba63a2.html</url>
    <content><![CDATA[<h2 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h2><blockquote>
<p>在《Java虚拟机规范》中制定了Java虚拟机字节码执行引擎的概念模型,概念模型成为各大发行商的Java虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择[插图]，也可能两者兼备，还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。</p>
</blockquote>
<p>从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</p>
<h3 id="一、运行时栈帧结构"><a href="#一、运行时栈帧结构" class="headerlink" title="一、运行时栈帧结构"></a>一、运行时栈帧结构</h3><p>Java虚拟机以方法作为最基本的执行单元。</p>
<p>“栈帧”（Stack Frame）是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p>
<p>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。</p>
<p>每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。</p>
<blockquote>
<p>在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈已经被分析计算出来，并且写入到方法表的Code属性之中。一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p>
</blockquote>
<p>以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。</p>
<p>但对于JVM执行引擎看来，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current StackFrame），与这个栈帧所关联的方法被称为“当前方法”（CurrentMethod）。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<p>在概念模型上，典型的栈帧结构大概长这样：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-bytecode/jvm-8-bc-exec-eng-stack-frame.jpg" alt="栈帧的概念结构"></p>
<h4 id="1、局部变量表"><a href="#1、局部变量表" class="headerlink" title="1、局部变量表"></a>1、局部变量表</h4><p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。</p>
<blockquote>
<p>局部变量表的容量以变量槽（Variable Slot）为最小单位，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储，它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化，保证了即使在64位虚拟机中使用了64位的物理内存空间去实现一个变量槽，虚拟机仍要使用对齐和补白的手段让变量槽在外观上看起来与32位虚拟机中的一致。</p>
</blockquote>
<p>reference类型表示对一个对象实例的引用，通过这个引用做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息。</p>
<p>returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转。（现在全部改用异常表。）</p>
<blockquote>
<p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中的某一个，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。</p>
</blockquote>
<p>方法执行时的局部变量表：</p>
<p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
<p>局部变量表中的变量槽重用:</p>
<p>局部变量表中的变量槽是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。</p>
<p>（a）节省栈帧空间</p>
<p>（b）共用一部分数据，无须进行额外的参数复制传递</p>
<p>（c）影响垃圾收集。（可以在必要的地方，给不用的对象赋null）</p>
<h4 id="2、-操作数栈"><a href="#2、-操作数栈" class="headerlink" title="2、 操作数栈"></a>2、 操作数栈</h4><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。</p>
<p>同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</p>
<p>Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p>
<p>方法执行时的操作数栈：</p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。</p>
<blockquote>
<p>如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新入栈。</p>
</blockquote>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。</p>
<p>两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。（实际大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。）</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-bytecode/jvm-8-bc-exec-eng-chongdie.jpg" alt="两个栈帧之间的数据共享"></p>
<p>Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。</p>
<h4 id="3、动态连接"><a href="#3、动态连接" class="headerlink" title="3、动态连接"></a>3、动态连接</h4><p>每个栈帧都包含一个指向运行时常量池[插图]中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p>
<p>Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。</p>
<h4 id="4、方法返回地址"><a href="#4、方法返回地址" class="headerlink" title="4、方法返回地址"></a>4、方法返回地址</h4><p>当一个方法开始执行后，只有两种方式退出这个方法。</p>
<p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”（Normal MethodInvocation Completion）。</p>
<p>另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为“异常调用完成（Abrupt Method Invocation Completion）”。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p>
<blockquote>
<p>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说，方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。</p>
</blockquote>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p>
<p>恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，</p>
<p>调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<h3 id="二、方法调用"><a href="#二、方法调用" class="headerlink" title="二、方法调用"></a>二、方法调用</h3><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法）。</p>
<p>Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（意思是不是方法的直接引用）。</p>
<blockquote>
<p>利：给Java带来了更强大的动态扩展能力。</p>
<p>弊：使得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
</blockquote>
<h4 id="1、解析"><a href="#1、解析" class="headerlink" title="1、解析"></a>1、解析</h4><p>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。(即：调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析（Resolution）。)</p>
<p>Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>调用不同类型的方法，字节码指令集里设计了不同的指令。在Java虚拟机支持以下5条方法调用字节码指令，分别是：</p>
<p>（1）<code>invokestatic</code>。用于调用静态方法。</p>
<p>（2）<code>invokespecial</code>。用于调用实例构造器<code>&lt;init&gt;()</code>方法、私有方法和父类中的方法。</p>
<p>（3）<code>invokevirtual</code>。用于调用所有的虚方法。</p>
<p>（4）<code>invokeinterface</code>。用于调用接口方法，会在运行时再确定一个实现该接口的对象。</p>
<p>（5<code>）invokedynamic</code>。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而<code>invokedynamic</code>指令的分派逻辑是由用户设定的引导方法来决定的。</p>
<p>能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”（Non-Virtual Method）,除此之外的其他方法就被称为“虚方法”（Virtual Method）。</p>
<p>Java中的非虚方法除了使用invokestatic、invokespecial调用的方法之外还有一种，就是被final修饰的实例方法。</p>
<blockquote>
<p>在《Java语言规范》中明确定义了被final修饰的方法是一种非虚方法。</p>
</blockquote>
<p>解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。而另一种主要的方法调用形式：分派（Dispatch）调用则要复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派[插图]。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。</p>
<h4 id="2、分派"><a href="#2、分派" class="headerlink" title="2、分派"></a>2、分派</h4><blockquote>
<p>《Java虚拟机规范》和《Java语言规范》里的说法都是“MethodOverload Resolution”</p>
</blockquote>
<p>（1）静态分派</p>
<p>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>polymorphic<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 方法静态分派演示
 * @author zzm
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticDispatch</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Human guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello,guy!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Man guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello,gentleman!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Woman guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello,lady!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Human man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Human woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        StaticDispatch sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>man<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>woman<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果</p>
<pre class=" language-txt"><code class="language-txt">hello,guy!
hello,guy!</code></pre>
<p>重载方法匹配优先级</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>polymorphic<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Overload</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello Object"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello int"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">long</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello long"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Character arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello Character"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">char</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello char"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello char ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Serializable arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello Serializable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果</p>
<pre class=" language-txt"><code class="language-txt">hello char</code></pre>
<p>（2）动态分派</p>
<p>动态分派的实现过程，与方法重写（Override）有着很密切的关联。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>polymorphic<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 方法动态分派演示
 * @author zzm
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDispatch</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"man say hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"woman say hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Human man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Human woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        woman<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果</p>
<pre class=" language-txt"><code class="language-txt">man say hello
woman say hello
woman say hello</code></pre>
<p>对应字节码清单：</p>
<pre class=" language-txt"><code class="language-txt">
</code></pre>
<p>根据《Java虚拟机规范》，invokevirtual指令的运行时解析过程[插图]大致分为以下几步：</p>
<p>1）找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</p>
<p>2）如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</p>
<p>3）否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</p>
<p>4）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p>
<p>Java语言中方法重写的本质:</p>
<p><code>invokevirtual</code>指令执行的第一步就是在运行期确定接收者的实际类型，两次调用中的<code>invokevirtual</code>指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本。这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>
<p>字段没有多态性：</p>
<blockquote>
<p>在Java里面只有虚方法存在，字段永远不可能是虚的，换句话说，字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。当子类声明了与父类同名的字段时，虽然在子类的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段。</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>polymorphic<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 字段不参与多态
 * @author zzm
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldHasNoPolymorphic</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            money <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am Father, i have $"</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            money <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am Son,  i have $"</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Father gay <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This gay has $"</span> <span class="token operator">+</span> gay<span class="token punctuation">.</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果</p>
<pre class=" language-txt"><code class="language-txt">I am Son, i have $0
I am Son, i have $4
This gay has $2</code></pre>
<p>因为Son类在创建的时候，首先隐式调用了Father的构造函数，而Father构造函数中对<code>showMeTheMoney()</code>的调用是一次虚方法调用，实际执行的版本是<code>Son::showMeTheMoney()</code>方法，所以输出的是<code>“I am Son”</code>，这点经过前面的分析相信读者是没有疑问的了。而这时候虽然父类的money字段已经被初始化成2了，但<code>Son::showMeTheMoney()</code>方法中访问的却是子类的money字段，这时候结果自然还是0，因为它要到子类的构造函数执行时才会被初始化。<code>main()</code>的最后一句通过静态类型访问到了父类中的money，输出了2。</p>
<h4 id="3、单分派与多分派"><a href="#3、单分派与多分派" class="headerlink" title="3、单分派与多分派"></a>3、单分派与多分派</h4><p>《Java与模式》定义方法的接收者与方法的参数统称为方法的宗量。</p>
<p>根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 单分派、多分派演示
 * @author zzm
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dispatch</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">QQ</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">_360</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span>QQ arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"father choose qq"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span>_360 arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"father choose 360"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span>QQ arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"son choose qq"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span>_360 arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"son choose 360"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Father father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Father son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        father<span class="token punctuation">.</span><span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">_360</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        son<span class="token punctuation">.</span><span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">QQ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果</p>
<pre class=" language-txt"><code class="language-txt">father choose 360
son choose qq</code></pre>
<p>在main()里调用了两次<code>hardChoice()</code>方法，这两次<code>hardChoice()</code>方法的选择结果在程序输出中已经显示得很清楚了。我们关注的首先是编译阶段中编译器的选择过程，也就是静态分派的过程。这时候选择目标方法的依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是360。这次选择结果的最终产物是产生了两条<code>invokevirtual</code>指令，两条指令的参数分别为常量池中指向<code>Father::hardChoice(360)</code>及<code>Father::hardChoice(QQ)</code>方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p>
<p>运行阶段中虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoice(new QQ())”这行代码时，更准确地说，是在执行这行代码所对应的invokevirtual指令时，由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时候参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的接受者的实际类型是Father还是Son。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p>
<blockquote>
<p>结论：Java语言是一门静态多分派、动态单分派的语言。</p>
</blockquote>
<h4 id="4、虚拟机动态分派的实现"><a href="#4、虚拟机动态分派的实现" class="headerlink" title="4、虚拟机动态分派的实现"></a>4、虚拟机动态分派的实现</h4><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法，因此，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表（<code>Virtual MethodTable</code>，也称为vtable，与此对应的，在<code>invokeinterface</code>执行时也会用到接口方法表——<code>Interface MethodTable</code>，简称itable），使用虚方法表索引来代替元数据查找以提高性能。</p>
<p>虚方法表结构:</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-bytecode/jvm-8-bc-exec-eng-table.jpg" alt="方法表结构"></p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p>
<p>Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。</p>
<p>为了程序实现方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕。</p>
<blockquote>
<p>查虚方法表是分派调用的一种优化手段，由于Java对象里面的方法默认（即不使用final修饰）就是虚方法，虚拟机除了使用虚方法表之外，为了进一步提高性能，还会使用类型继承关系分析（Class HierarchyAnalysis，CHA）、守护内联（Guarded Inlining）、内联缓存（Inline Cache）等多种非稳定的激进优化来争取更大的性能空间。</p>
</blockquote>
<h3 id="三、动态类型语言支持"><a href="#三、动态类型语言支持" class="headerlink" title="三、动态类型语言支持"></a>三、动态类型语言支持</h3><blockquote>
<p>JDK 7的发布的字节码首位新成员——invokedynamic指令。这条新增加的指令是JDK 7的项目目标：实现动态类型语言（Dynamically TypedLanguage）支持而进行的改进之一，也是为JDK 8里可以顺利实现Lambda表达式而做的技术储备。</p>
</blockquote>
<h4 id="1、动态类型语言"><a href="#1、动态类型语言" class="headerlink" title="1、动态类型语言"></a>1、动态类型语言</h4><p>什么是动态类型语言？</p>
<p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、Groovy、JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl，等等。</p>
<p>在编译期就进行类型检查过程的语言，譬如C++和Java等就是最常用的静态类型语言。</p>
<p>编译时类型检查，运行时检查。</p>
<p>运行时异常（<code>RunTimeException</code>、），连接时异常（<code>NoClassDefFoundError</code>）</p>
<h4 id="2、Java与动态类型"><a href="#2、Java与动态类型" class="headerlink" title="2、Java与动态类型"></a>2、Java与动态类型</h4>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>字节码执行引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之类加载机制</title>
    <url>/posts/22096143.html</url>
    <content><![CDATA[<h2 id="jvm类加载机制"><a href="#jvm类加载机制" class="headerlink" title="jvm类加载机制"></a>jvm类加载机制</h2><p>什么是类加载机制？</p>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
</blockquote>
<h3 id="一、类的生命周期"><a href="#一、类的生命周期" class="headerlink" title="一、类的生命周期"></a>一、类的生命周期</h3><p>个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-clazz-load/jvm-class-load-life.jpg" alt="类的生命周期"></p>
<p>其中验证、准备、解析三个部分统称为连接（Linking）。</p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p>
<p>《Java虚拟机规范》严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<p>1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：</p>
<p>​    （a）使用new关键字实例化对象的时候。</p>
<p>​    （b）读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</p>
<p>​    （c）调用一个类型的静态方法的时候。</p>
<p>2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</p>
<p>3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
<p>6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
<p>这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p>
<p>另外的几种情况：</p>
<p>示例一：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zzy<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>clazzload<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 被动使用类字段演示一：
 * 通过子类引用父类的静态字段，不会导致子类初始化
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zzy<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>clazzload<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zzy<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>clazzload<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/**
 * 非主动使用类字段演示
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>输出结果 </p>
<pre class=" language-txt"><code class="language-txt">SuperClass init!
123</code></pre>
<p>输出“SuperClass init！”,没有输出子类的初始化。</p>
<p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<p>若要触发子类的加载和验证阶段，对于HotSpot虚拟机来说，可通过-XX：+TraceClassLoading参数观察到此操作是会导致子类加载的。</p>
<p>示例二：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zzy<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>clazzload<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 被动使用类字段演示二：
 * 通过数组定义来引用类，不会触发此类的初始化
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>
     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//System.out.println(SubClass.value);</span>

         SuperClass<span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行之后发现没有输出“SuperClass init！”</p>
<p>这段代码里面触发了另一个名为“[Lcom.zzy.demo.clazzload.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。</p>
<blockquote>
<p>这个类代表了一个元素类型为com.zzy.demo.clazzload.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里。Java语言中对数组的访问要比C/C++相对安全，很大程度上就是因为这个类包装了数组元素的访问[插图]，而C/C++中则是直接翻译为对数组指针的移动。在Java语言里，当检查到发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常，避免了直接造成非法内存访问。</p>
</blockquote>
<p>示例三：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zzy<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>clazzload<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 被动使用类字段演示三：
 * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的
   类的初始化
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConstClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String HELLOWORLD <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zzy<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>clazzload<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/**
 * 非主动使用类字段演示
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ConstClass<span class="token punctuation">.</span>HELLOWORLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>上述代码运行之后，也没有输出“ConstClass init！”，这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”直接存储在NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class文件后就已不存在任何联系了。</p>
<p>接口初始化：</p>
<p>接口的加载过程与类加载过程稍有不同，接口也有初始化过程，这点与类是一致的。</p>
<p>上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成<code>&quot;&lt;&quot;clinit&gt;()&quot;</code>类构造器，用于初始化接口中所定义的成员变量。</p>
<p>接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<h3 id="二、类加载过程"><a href="#二、类加载过程" class="headerlink" title="二、类加载过程"></a>二、类加载过程</h3><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1 加载"></a>1 加载</h4><p>“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，Java虚拟机需要完成以下三件事情：</p>
<p>1）通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<p>数组类加载：</p>
<p>数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：</p>
<p>（1）如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。</p>
<p>（2）如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。</p>
<p>（3）数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</p>
<p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区。方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>
<blockquote>
<p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
</blockquote>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2 验证"></a>2 验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<p>1）文件格式验证</p>
<p>第一阶段的主要目的：</p>
<p>​    是为保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</p>
<p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<p>（a）是否以魔数0xCAFEBABE开头。</p>
<p>（b）主、次版本号是否在当前Java虚拟机接受范围之内。</p>
<p>（c）常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</p>
<p>（d）指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</p>
<p>（e）CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</p>
<p>（f）Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</p>
<p>（g）……等等等等</p>
<p>验证点还远不止这些。</p>
<p>2）元数据验证</p>
<p>第二阶段的主要目的：</p>
<p>​    对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</p>
<p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：</p>
<p>（a）这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</p>
<p>（b）这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</p>
<p>（c）如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</p>
<p>（d）类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</p>
<p>（e）……等等等等</p>
<p>3）字节码验证</p>
<p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的：</p>
<p>​    通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p>在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p>
<p>（a）保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</p>
<p>（b）保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</p>
<p>（c）保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</p>
<p>（d）……等等等等</p>
<blockquote>
<p>JDK 6的HotSpot虚拟机中提供了-XX：-UseSplitVerifier选项来关闭掉这项优化，或者使用参数<code>-XX：+FailOverToOldVerifier</code>要求在类型校验失败的时候退回到旧的类型推导方式进行校验。而到了JDK 7之后，尽管虚拟机中仍然保留着类型推导验证器的代码，但是对于主版本号大于50（对应JDK 6）的Class文件，使用类型检查来完成数据流分析校验则是唯一的选择，不允许再退回到原来的类型推导的校验方式。</p>
</blockquote>
<p>4）符号引用验证</p>
<p>符号引用验证的主要目的:</p>
<p>​    确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>的子类异常，典型的如：<code>java.lang.IllegalAccessError</code>、<code>java.lang.NoSuchFieldError</code>、<code>java.lang.NoSuchMethodError</code>等。</p>
<p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用[插图]的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p>
<p>符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p>本阶段通常需要校验下列内容：</p>
<p>（a）符号引用中通过字符串描述的全限定名是否能找到对应的类。</p>
<p>（b）在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</p>
<p>（c）符号引用中的类、字段、方法的可访问性（<code>private</code>、<code>protected</code>、<code>public</code>、<code>&lt;package&gt;</code>）是否可被当前类访问。</p>
<p>（d）……等等等等</p>
<blockquote>
<p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3 准备"></a>3 准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。</p>
<p>在JDK 7及之前，HotSpot使用永久代来实现方法区时，这些变量所使用的内存都应当在方法区中进行分配。</p>
<p>在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中。</p>
<p>注意：</p>
<p>（1）准备阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>（2）初始值“通常情况”下是数据类型的零值。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span></code></pre>
<p>那变量value在准备阶段过后的初始值为0而不是1234，因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-clazz-load/jvm-class-load-initvalue.jpg" alt="基本数据类型的零值"></p>
<p>（3）“特殊情况”下：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据Con-stantValue的设置将value赋值为123。</p>
<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4 解析"></a>4 解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>什么是符号引用？</p>
<blockquote>
<p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
<p>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</p>
<p>各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p>
<p>符号引用以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。</p>
</blockquote>
<p>什么是直接引用？</p>
<blockquote>
<p>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</p>
<p>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
</blockquote>
<p>解析阶段要求：</p>
<blockquote>
<p>解析阶段要求在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p>
<p>虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
</blockquote>
<p>类似地，对方法或者字段的访问，也会在解析阶段中对它们的可访问性（public、protected、private、<package>）进行检查。</p>
<p>符号引用请求基本准则：一次成功，次次成功；一次失败，次次失败。</p>
<blockquote>
<p>对同一个符号引用进行多次解析请求是很常见的事情，除<code>invokedynamic</code>指令以外，虚拟机实现可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；同样地，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。</p>
<p>因为invokedynamic指令的目的本来就是用于动态语言支持，它对应的引用称为“动态调用点限定符（Dynamically-Computed Call Site Specifier）”，这里“动态”的含义是指必须等到程序实际运行到这条指令时，解析动作才能进行。相对地，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就提前进行解析。</p>
</blockquote>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池的</p>
<p><code>CONSTANT_Class_info</code>(类)、</p>
<p><code>CON-STANT_Fieldref_info</code>（字段）、</p>
<p><code>CONSTANT_Methodref_info</code>（方法）、</p>
<p><code>CONSTANT_InterfaceMethodref_info</code>（接口方法）、<code>CONSTANT_MethodType_info</code>、<code>CONSTANT_MethodHandle_info</code>、<code>CONSTANT_Dyna-mic_info</code>和<code>CONSTANT_InvokeDynamic_info</code> 8种常量类型。</p>
<p>前4种常量类型解析<a href="/images/jvm-clazz-load/jiexi-details.txt">jiexi_Details.txt</a></p>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5 初始化"></a>5 初始化</h4><p>类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p>
<p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>是Javac编译器的自动生成物。</p>
<p>（1）<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p>
<p>（2）<code>&lt;clinit&gt;()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在Java虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是java.lang.Object。</p>
<p> 由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下代码清单中，字段B的值将会是2而不是1。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zzy<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>clazzload<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> B <span class="token operator">=</span> A<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>（3）<code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
<p>（4）接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
<p>（5）Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行完毕<code>&lt;clinit&gt;()</code>方法。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，那就可能造成多个进程阻塞[插图]，在实际应用中这种阻塞往往是很隐蔽的。下面的代码清单演示了这种场景</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DeadLoopClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果不加上这个if语句，编译器将提示“Initializer does not complete normally”</span>
           并拒绝编译
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"init DeadLoopClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Runnable script <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            DeadLoopClass dlc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeadLoopClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" run over"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果如下，一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待：</p>
<pre class=" language-txt"><code class="language-txt">Thread[Thread-0,5,main]start
Thread[Thread-1,5,main]start
Thread[Thread-0,5,main]init DeadLoopClass</code></pre>
<h3 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h3><h4 id="1、类的比较"><a href="#1、类的比较" class="headerlink" title="1、类的比较"></a>1、类的比较</h4><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>“相等”：包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zzy<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>clazzload<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/**
 * 类加载器与instanceof关键字演示
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>

        ClassLoader myLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    String fileName <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".class"</span><span class="token punctuation">;</span>
                    InputStream is <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>is<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        Object obj <span class="token operator">=</span> myLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"com.zzy.demo.clazzload.ClassLoaderTest"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">com<span class="token punctuation">.</span>zzy<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>clazzload<span class="token punctuation">.</span>ClassLoaderTest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果:</p>
<pre class=" language-txt"><code class="language-txt">class com.zzy.demo.clazzload.ClassLoaderTest
false</code></pre>
<p>因为Java虚拟机中同时存在了两个ClassLoaderTest类，一个是由虚拟机的应用程序类加载器所加载的，另外一个是由我们自定义的类加载器加载的，虽然它们都来自同一个Class文件，但在Java虚拟机中仍然是两个互相独立的类，做对象所属类型检查时的结果自然为false。</p>
<h4 id="2、双亲委派模型"><a href="#2、双亲委派模型" class="headerlink" title="2、双亲委派模型"></a>2、双亲委派模型</h4><p>自JDK 1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。</p>
<p>3个系统提供的类加载器：</p>
<p>（1）启动类加载器（Bootstrap Class Loader）</p>
<p>负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</p>
<p>启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</p>
<p>ClassLoader.getClassLoader()方法的代码片段：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
Returns the class loader for the class.  Some implementations may use null to represent the bootstrap class loader. This method will return  null in such implementations if this class was loaded by the bootstrap class loader.
*/</span>
<span class="token keyword">public</span> ClassLoader <span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ClassLoader cl <span class="token operator">=</span> <span class="token function">getClassLoader0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cl <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    SecurityManager sm <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ClassLoader ccl <span class="token operator">=</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getCallerClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ccl <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> ccl <span class="token operator">!=</span> cl <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>cl<span class="token punctuation">.</span><span class="token function">isAncestor</span><span class="token punctuation">(</span>ccl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sm<span class="token punctuation">.</span><span class="token function">checkPermission</span><span class="token punctuation">(</span>SecurityConstants<span class="token punctuation">.</span>GET_CLASSLOADER_PERMISSION<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> cl<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>（2）扩展类加载器（Extension Class Loader）</p>
<p>这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</p>
<p>开发中可以直接在程序中使用扩展类加载器来加载Class文件。</p>
<p>（3）应用程序类加载器（Application Class Loader）</p>
<p>这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。</p>
<p>它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。</p>
<p>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-clazz-load/jvm-class-load-classLoader.jpg" alt="类加载器双亲委派模型"></p>
<p>JDK 9之前的Java应用都是由这三种类加载器互相配合来完成加载的，如果用户认为有必要，还可以加入自定义的类加载器来进行拓展，典型的如增加除了磁盘位置之外的Class文件来源，或者通过类加载器实现类的隔离、重载等功能。</p>
<p>图中类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation Model）”。</p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程：</p>
<blockquote>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
</blockquote>
<p>双亲委派模型的实现:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 首先，检查请求的类是否已经被加载过了</span>
    Class <span class="token class-name">c</span> <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果父类加载器抛出ClassNotFoundException</span>
            <span class="token comment" spellcheck="true">// 说明父类加载器无法完成加载请求</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 在父类加载器无法加载时</span>
            <span class="token comment" spellcheck="true">// 再调用本身的findClass方法来进行类加载</span>
            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这段代码的逻辑：</p>
<p>先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p>
<h4 id="3、破坏双亲委派模型"><a href="#3、破坏双亲委派模型" class="headerlink" title="3、破坏双亲委派模型"></a>3、破坏双亲委派模型</h4><p>双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<p>第一次：</p>
<p>发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。</p>
<p>类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。</p>
<p>按照上面loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<p>第二次：</p>
<p>是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p>
<p>一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service ProviderInterface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</p>
<p>Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p>第三次：</p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。说白了就是希望Java应用程序能像我们的电脑外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用关机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是大型系统或企业级软件开发者具有很大的吸引力。</p>
<blockquote>
<p>早在2008年，在Java社区关于模块化规范的第一场战役里，由Sun/Oracle公司所提出的JSR-294[插图]、JSR-277[插图]规范提案就曾败给以IBM公司主导的JSR-291（即OSGi R4.2）提案。尽管Sun/Oracle并不甘心就此失去Java模块化的主导权，随即又再拿出Jigsaw项目迎战，但此时OSGi已经站稳脚跟，成为业界“事实上”的Java模块化标准[插图]。曾经在很长一段时间内，IBM凭借着OSGi广泛应用基础让Jigsaw吃尽苦头，其影响一直持续到Jigsaw随JDK 9面世才算告一段落。而且即使Jigsaw现在已经是Java的标准功能了，它仍需小心翼翼地避开OSGi运行期动态热部署上的优势，仅局限于静态地解决模块间封装隔离和访问控制的问题</p>
</blockquote>
<p>OSGi是如何通过类加载器实现热部署？</p>
<p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br>1）将以<code>java.*</code>开头的类，委派给父类加载器加载。<br>2）否则，将委派列表名单内的类，委派给父类加载器加载。<br>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。<br>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br>7）否则，类查找失败。</p>
<p>上面的查找顺序中只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之分配与回收策略</title>
    <url>/posts/96a9f88d.html</url>
    <content><![CDATA[<h2 id="JVM内存分配与回收策略"><a href="#JVM内存分配与回收策略" class="headerlink" title="JVM内存分配与回收策略"></a>JVM内存分配与回收策略</h2><p>Java的自动内存管理，最根本的目标是自动化解决两个问题：自动给对象分配内存和自动回收分配给对象的内存。</p>
<h3 id="一、对象内存分配"><a href="#一、对象内存分配" class="headerlink" title="一、对象内存分配"></a>一、对象内存分配</h3><p>从概念上讲，应该都是在堆上分配（而实际上也有可能经过即时编译后被拆散为标量类型并间接地在栈上分配）。</p>
<blockquote>
<p>在经典的分代收集器中，新生对象一般会分配在新生代。特殊情况下回直接分配在老年代，如对象大小超过阈值。</p>
</blockquote>
<h4 id="1、对象优先在新生代Eden区分配。"><a href="#1、对象优先在新生代Eden区分配。" class="headerlink" title="1、对象优先在新生代Eden区分配。"></a>1、对象优先在新生代Eden区分配。</h4><p>当Eden区没有足够空间分配时，JVM发起一次新生代回收Minor GC。</p>
<p>HotSpot虚拟机收集器日志参数：<code>-XX：+PrintGCDetails</code></p>
<blockquote>
<p>该参数使JVM发生垃圾收集行为时打印内存回收日志，并在进程退出时输出当前的内存各个区域分配情况。在实际的问题排查中，收集器日志常会打印到文件后通过工具进行分析。</p>
</blockquote>
<p><code>-XX：Survivor-Ratio=8</code></p>
<p>设置新生代中Eden区与一个Survivor区的空间比例是8∶1</p>
<p>如果新生代大小 -Xmn=10M,那么Eden区大小为8192K，2个Survivor取均为1024K，新生代实际总可用空间8192K+1024K=9216KB。</p>
<p><code>-verbose :gc</code>在输出设备上显示虚拟机运行GC信息。   </p>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testAllocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">,</span> allocation4<span class="token punctuation">;</span>
    allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 出现一次Minor GC</span>
 <span class="token punctuation">}</span></code></pre>
<p>结果</p>
<pre><code>[GC [DefNew: 6651K-&gt;148K(9216K), 0.0070106 secs] 6651K-&gt;6292K(19456K), 0.0070426 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
    def new generation   total 9216K, used 4326K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
        from space 1024K,  14% used [0x032d0000, 0x032f5370, 0x033d0000)
        to   space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)
    tenured generation   total 10240K, used 6144K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  60% used [0x033d0000, 0x039d0030, 0x039d0200, 0x03dd0000)
    compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
            the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)
No shared spaces configured.</code></pre><h4 id="2、大对象直接进入老年代"><a href="#2、大对象直接进入老年代" class="headerlink" title="2、大对象直接进入老年代"></a>2、大对象直接进入老年代</h4><p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组或集合。</p>
<p>写程序应该避免大对象，因为分配空间时容易导致明明还有空间却提前出发垃圾收集，获取足够的连续空间来分配大对象。另外复制大对象，也需要大量的内存复制开销。</p>
<p><code>-XX：PretenureSizeThreshold</code></p>
<p>该参数用来指定大于该设置值的对象直接在老年代分配。该参数只对Serial和ParNew两款新生代收集器有效</p>
<blockquote>
<p>目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</p>
</blockquote>
<p>必须使用此参数进行调优，可考虑ParNew加CMS的收集器组合。</p>
<p>示例</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
 * -XX:PretenureSizeThreshold=3145728
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testPretenureSizeThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation<span class="token punctuation">;</span>
    allocation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//直接分配在老年代中</span>
<span class="token punctuation">}</span></code></pre>
<p>执行结果</p>
<pre><code>Heap
    def new generation   total 9216K, used 671K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,   8% used [0x029d0000, 0x02a77e98, 0x031d0000)
        from space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)
        to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)
    tenured generation   total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  40% used [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000)
    compacting perm gen  total 12288K, used 2107K [0x03dd0000, 0x049d0000, 0x07dd0000)
            the space 12288K,  17% used [0x03dd0000, 0x03fdefd0, 0x03fdf000, 0x049d0000)
No shared spaces configured.</code></pre><h4 id="3、长期存活的对象将进入老年代"><a href="#3、长期存活的对象将进入老年代" class="headerlink" title="3、长期存活的对象将进入老年代"></a>3、长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。</p>
<blockquote>
<p>对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。</p>
</blockquote>
<p><code>-XX：MaxTenuringThreshold</code>：</p>
<p>该参数可以用来设置对象晋升老年代的年龄阈值。</p>
<p>示例</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:Survivor-
   Ratio=8 -XX:MaxTenuringThreshold=1
 * -XX:+PrintTenuringDistribution
 */</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testTenuringThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">;</span>
    allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 什么时候进入老年代决定于XX:MaxTenuring-</span>
                                                   Threshold设置
    allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> null<span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>以-XX：MaxTenuringThreshold=1参数来运行的结果：</p>
<pre><code>[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 1 (max 1)
- age   1:     414664 bytes,     414664 total
: 4859K-&gt;404K(9216K), 0.0065012 secs] 4859K-&gt;4500K(19456K), 0.0065283 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 1 (max 1)
: 4500K-&gt;0K(9216K), 0.0009253 secs] 8596K-&gt;4500K(19456K), 0.0009458 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
    def new generation   total 9216K, used 4178K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
        from space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)
        to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)
    tenured generation   total 10240K, used 4500K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  43% used [0x033d0000, 0x03835348, 0x03835400, 0x03dd0000)
    com\pacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
            the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)
No shared spaces configured.</code></pre><p>以-XX：MaxTenuringThreshold=15参数来运行的结果：</p>
<pre><code>[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 15 (max 15)
- age   1:     414664 bytes,     414664 total
: 4859K-&gt;404K(9216K), 0.0049637 secs] 4859K-&gt;4500K(19456K), 0.0049932 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 15 (max 15)
- age   2:     414520 bytes,     414520 total
: 4500K-&gt;404K(9216K), 0.0008091 secs] 8596K-&gt;4500K(19456K), 0.0008305 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
    def new generation   total 9216K, used 4582K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
        from space 1024K,  39% used [0x031d0000, 0x03235338, 0x032d0000)
        to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)
    tenured generation   total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  40% used [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000)
    compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
            the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)
No shared spaces configured.</code></pre><h4 id="4、动态对象年龄判断"><a href="#4、动态对象年龄判断" class="headerlink" title="4、动态对象年龄判断"></a>4、动态对象年龄判断</h4><p>HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到<code>-XX：MaxTenuringThreshold</code>中要求的年龄。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
   -XX:MaxTenuringThreshold=15
 * -XX:+PrintTenuringDistribution
 */</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testTenuringThreshold2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">,</span> allocation4<span class="token punctuation">;</span>
    allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// allocation1+allocation2大于survivo空间一半</span>
    allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> null<span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果：</p>
<pre><code>[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 1 (max 15)
- age   1:     676824 bytes,     676824 total
: 5115K-&gt;660K(9216K), 0.0050136 secs] 5115K-&gt;4756K(19456K), 0.0050443 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]
[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 15 (max 15)
: 4756K-&gt;0K(9216K), 0.0010571 secs] 8852K-&gt;4756K(19456K), 0.0011009 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
    def new generation   total 9216K, used 4178K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
        from space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)
        to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)
    tenured generation   total 10240K, used 4756K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  46% used [0x033d0000, 0x038753e8, 0x03875400, 0x03dd0000)
    compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
        the space 12288K,  17% used [0x03dd0000, 0x03fe09a0, 0x03fe0a00, 0x049d0000)
No shared spaces configured.</code></pre><h4 id="5、空间分配担保"><a href="#5、空间分配担保" class="headerlink" title="5、空间分配担保"></a>5、空间分配担保</h4><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败（HandlePromotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。</p>
<p>关于“冒险”的解释：</p>
<blockquote>
<p>新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况——最极端的情况就是内存回收后新生代中所有对象都存活，需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代，这与生活中贷款担保类似。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的，所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。取历史平均值来比较其实仍然是一种赌概率的解决办法，也就是说假如某次Minor GC存活后的对象突增，远远高于历史平均值的话，依然会导致担保失败。如果出现了担保失败，那就只好老老实实地重新发起一次Full GC，这样停顿时间就很长了。虽然担保失败时绕的圈子是最大的，但通常情况下都还是会将-XX：HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * VM参数：-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:-Handle-
   PromotionFailure
 */</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testHandlePromotion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">,</span> allocation4<span class="token punctuation">,</span> allocation5<span class="token punctuation">,</span> alloca<span class="token operator">-</span>tion6<span class="token punctuation">,</span> allocation7<span class="token punctuation">;</span>
    allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation1 <span class="token operator">=</span> null<span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> null<span class="token punctuation">;</span>
    allocation5 <span class="token operator">=</span> null<span class="token punctuation">;</span>
    allocation6 <span class="token operator">=</span> null<span class="token punctuation">;</span>
    allocation7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>以-XX：HandlePromotionFailure=false参数来运行的结果：</p>
<pre><code>[GC [DefNew: 6651K-&gt;148K(9216K), 0.0078936 secs] 6651K-&gt;4244K(19456K), 0.0079192 secs] [Times: user=0.00 sys=0.02, real=0.02 secs]
[GC [DefNew: 6378K-&gt;6378K(9216K), 0.0000206 secs][Tenured: 4096K-&gt;4244K(10240K), 0.0042901 secs] 10474K-&gt;4244K(19456K), [Perm : 2104K-&gt;2104K(12288K)], 0.0043613 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></pre><p>以-XX：HandlePromotionFailure=true参数来运行的结果：</p>
<pre><code>[GC [DefNew: 6651K-&gt;148K(9216K), 0.0054913 secs] 6651K-&gt;4244K(19456K), 0.0055327 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
[GC [DefNew: 6378K-&gt;148K(9216K), 0.0006584 secs] 10474K-&gt;4244K(19456K), 0.0006857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></pre><p><code>-XX：HandlePromotionFailure</code>参数在实际虚拟机中已经不会再使用它。JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm监控调优工具</title>
    <url>/posts/ed0fd586.html</url>
    <content><![CDATA[<h2 id="JVM常用工具"><a href="#JVM常用工具" class="headerlink" title="JVM常用工具"></a>JVM常用工具</h2><p>之所以要使用JVM工具当然是为了定位系统问题。常见的可依赖的数据包括但不限于异常堆栈、虚拟机运行日志、垃圾收集日志、线程快照（threadump/javacore文件）、堆转储快照（heapdump/ hprof文件）等。</p>
<h3 id="一、基础故障处理工具"><a href="#一、基础故障处理工具" class="headerlink" title="一、基础故障处理工具"></a>一、基础故障处理工具</h3><p>主要分三类：</p>
<p>（a）商业授权工具。</p>
<blockquote>
<p>主要是JMC（Java Mission Control）及它要使用到的JFR（Java Flight Recorder）。</p>
</blockquote>
<p>（b）正式支持工具.</p>
<blockquote>
<p>这一类工具属于被长期支持的工具，不同平台、不同版本的JDK之间，这类工具可能会略有差异，但是不会出现某一个工具突然消失的情况。</p>
</blockquote>
<p>（c）实验性工具。</p>
<blockquote>
<p>这一类工具在它们的使用说明中被声明为”没有技术支持，并且是实验性质的”（Unsupported and Experimental）产品，日后可能会转正，也可能会在某个JDK版本中无声无息地消失。但事实上它们通常都非常稳定而且功能强大，也能在处理应用程序性能问题、定位故障时发挥很大的作用。</p>
</blockquote>
<p>JDK5需要手动开启JMX:”<code>-Dcom.sun.management.jmxremote</code>“开启JMX管理功能。</p>
<h4 id="1、jps"><a href="#1、jps" class="headerlink" title="1、jps"></a>1、jps</h4><p>jps（JVMProcess Status Tool）是虚拟机进程状况工具。</p>
<blockquote>
<p>可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。</p>
<p>可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，参数hostid为RMI注册表中注册的主机名。</p>
</blockquote>
<p>特点：功能单一，使用频率最高</p>
<p>命令格式：</p>
<pre><code>jps [ options ] [ hostid ]</code></pre><p>如：jsp -l</p>
<p>options主要有4个</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-q</td>
<td>只输出LVMID，省略主类名称</td>
</tr>
<tr>
<td align="center">-m</td>
<td>输出虚拟机进程启动时传递给主类main() 函数的参数</td>
</tr>
<tr>
<td align="center">-l</td>
<td>输出主类的全名，如果进程执行的jar包，则输出jar全路径</td>
</tr>
<tr>
<td align="center">-v</td>
<td>输出虚拟机进程启动时的JVM参数</td>
</tr>
</tbody></table>
<h4 id="2、jstat"><a href="#2、jstat" class="headerlink" title="2、jstat"></a>2、jstat</h4><p>jstat（JVM Statistics Monitoring Tool）是虚拟机统计信息监视工具。</p>
<blockquote>
<p>用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程[插图]虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。</p>
</blockquote>
<p>jstat命令格式为：</p>
<pre class=" language-bash"><code class="language-bash">jstat <span class="token punctuation">[</span> option vmid <span class="token punctuation">[</span> interval<span class="token punctuation">[</span>s<span class="token operator">|</span>ms<span class="token punctuation">]</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">]</span></code></pre>
<p>如果是本地虚拟机进程，VMID与LVMID是一致的；如果是远程虚拟机进程，那VMID的格式应当是：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>protocal:<span class="token punctuation">]</span><span class="token punctuation">[</span>//<span class="token punctuation">]</span>lvmid<span class="token punctuation">[</span>@hostname<span class="token punctuation">[</span>:port<span class="token punctuation">]</span>/servername<span class="token punctuation">]</span></code></pre>
<p>参数interval和count代表查询间隔和次数，如果省略这2个参数，说明只查询一次。</p>
<p>假设需要每250毫秒查询一次进程10164垃圾收集状况，一共查询20次，那命令应当是：</p>
<pre class=" language-bash"><code class="language-bash">jstat -gc 10164 250 20</code></pre>
<p>选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-options-jstat.jpg" alt="jstat主要选项"></p>
<p> jstat执行样例：</p>
<pre><code>jstat -gcutil 2764
S0      S1      E       O        P        YGC    YGCT     FGC    FGCT     GCT
0.00    0.00    6.20    41.42    47.20    16     0.105    3      0.472    0.577</code></pre><p>新生代Eden区（E，表示Eden）使用了6.2%的空间，2个Survivor区（S0、S1，表示Survivor0、Survivor1）里面都是空的，老年代（O，表示Old）和永久代（P，表示Permanent）则分别使用了41.42%和47.20%的空间。程序运行以来共发生MinorGC（YGC，表示Young GC）16次，总耗时0.105秒；发生FullGC（FGC，表示Full GC）3次，总耗时（FGCT，表示Full GC Time）为0.472秒；所有GC总耗时（GCT，表示GC Time）为0.577秒。</p>
<p>如果使用时遇到这样单个字母要认识。</p>
<h4 id="3、jinfo"><a href="#3、jinfo" class="headerlink" title="3、jinfo"></a>3、jinfo</h4><p>jinfo（Configuration Info for Java）的是Java配置信息工具。</p>
<p>作用是实时查看和调整虚拟机各项参数。</p>
<p><code>jps  -v</code>可以查看虚拟机启动时显式指定的参数列表。</p>
<p><code>jinfo  -flag</code>可以查看虚拟机未被显式指定的参数的系统默认值。若jdk6以上版本也可以使用<code>-XX：+PrintFlagsFinal</code>查看参数默认值。</p>
<p><code>jinfo  -sysprops</code>可以把虚拟机进程的System.getProperties()的内容打印出来。这个命令在JDK 5时期已经随着Linux版的JDK发布，当时只提供了信息查询的功能，JDK 6之后，jinfo在Windows和Linux平台都有提供，并且加入了在运行期修改部分参数值的能力（可以使用-flag[+|-]name或者-flag name=value在运行期修改一部分运行期可写的虚拟机参数值）。</p>
<p>在JDK 6中，jinfo对于Windows平台功能仍然有较大限制，只提供了最基本的-flag选项。</p>
<p>命令格式：</p>
<pre class=" language-bash"><code class="language-bash">jinfo  <span class="token punctuation">[</span> option <span class="token punctuation">]</span> pid</code></pre>
<p>执行样例：查询CMSInitiatingOccupancyFraction参数值:</p>
<pre class=" language-bash"><code class="language-bash">jinfo -flag CMSInitiatingOccupancyFraction 1444
-XX:CMSInitiatingOccupancyFraction<span class="token operator">=</span>85</code></pre>
<h4 id="4、jmap"><a href="#4、jmap" class="headerlink" title="4、jmap"></a>4、jmap</h4><p>jmap—Java内存映像工具。</p>
<p>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件），还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。</p>
<p>如果不使用jmap命令呢?</p>
<p>（a）使用<code>-XX：+HeapDumpOnOutOfMemoryError</code>参，可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件。</p>
<p>（b）通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件。</p>
<p>（c）在Linux系统下通过<code>Kill  -3</code>命令发送进程退出信号”恐吓”一下虚拟机，也能顺利拿到堆转储快照。</p>
<blockquote>
<p>jmap有部分功能在Windows平台下是受限的，除了生成堆转储快照的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统中都可以使用之外，其余选项都只能在Linux/Solaris中使用。</p>
</blockquote>
<p>jmap命令格式：</p>
<pre class=" language-bash"><code class="language-bash">jmap <span class="token punctuation">[</span> option <span class="token punctuation">]</span> vmid</code></pre>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-options-jmap.jpg" alt="jmap主要选项"></p>
<p>使用jmap生成一个正在运行的Eclipse的堆转储快照文件，12109是通过jps命令查询到的LVMID。</p>
<pre class=" language-bash"><code class="language-bash">jmap -dump:format<span class="token operator">=</span>b,file<span class="token operator">=</span>eclipse.bin 12109
Dumping heap to D:\eclipse.bin <span class="token punctuation">..</span>.
Heap dump <span class="token function">file</span> created</code></pre>
<h4 id="5、jhat"><a href="#5、jhat" class="headerlink" title="5、jhat"></a>5、jhat</h4><p>jhat虚拟机堆转储快照分析工具。</p>
<p>JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。</p>
<blockquote>
<p>分析工作是一个耗时而且极为耗费硬件资源的过程，一般不直接在应用服务器上这么搞。</p>
<p>jhat的分析功能相对来说比较简陋，与VisualVM，以及专业用于分析堆转Eclipse Memory Analyzer、IBM HeapAnalyzer等相比。</p>
</blockquote>
<p>使用jhat分析dump文件：</p>
<pre class=" language-bash"><code class="language-bash">jhat eclipse.bin
Reading from eclipse.bin<span class="token punctuation">..</span>.
Dump <span class="token function">file</span> created Fri Nov 19 22:07:21 CST 2010
Snapshot read, resolving<span class="token punctuation">..</span>.
Resolving 1225951 objects<span class="token punctuation">..</span>.
Chasing references, <span class="token function">expect</span> 245 dots<span class="token punctuation">..</span><span class="token punctuation">..</span>
Eliminating duplicate references<span class="token punctuation">..</span>.
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.</code></pre>
<p>分析结果默认以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的”Heap Histogram”（与<code>jmap -histo</code>功能一样）与OQL页签的功能，前者可以找到内存中总容量最大的对象，OQL是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计。关于OQL<a href=""> 《JVM的对象查询OQL》</a></p>
<h4 id="6、jstack"><a href="#6、jstack" class="headerlink" title="6、jstack"></a>6、jstack</h4><p>jstack：Java堆栈跟踪工具。</p>
<p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。</p>
<p>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p>
<p>生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p>
<p>jstack命令格式：</p>
<pre><code>jstack  [ option ] vmid</code></pre><p> jstack工具主要选项:</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-F</td>
<td align="left">当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="left">除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="left">如果遇到本地方法的话，可以显示C/C++的堆栈</td>
</tr>
</tbody></table>
<blockquote>
<p>从JDK 5起，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。</p>
</blockquote>
<p>查看线程状况的JSP页面：</p>
<pre class=" language-html"><code class="language-html">&lt;%@ page import="java.util.Map"%>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>服务器线程信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span>
    <span class="token attr-name">for</span> <span class="token attr-name">(Map.Entry&lt;Thread,</span> <span class="token attr-name">StackTraceElement[]</span><span class="token punctuation">></span></span> stackTrace : Thread.getAllStack-Traces().entrySet()) {
        Thread thread = (Thread) stackTrace.getKey();
        StackTraceElement[] stack = (StackTraceElement[]) stackTrace.getValue();
        if (thread.equals(Thread.currentThread())) {
            continue;
        }
        out.print("\n线程：" + thread.getName() + "\n");
        for (StackTraceElement element : stack) {
            out.print("\t"+element+"\n");
        }
    }
%>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<h4 id="7、其他"><a href="#7、其他" class="headerlink" title="7、其他"></a>7、其他</h4><p> 基础工具：</p>
<p>用于支持基本的程序创建和运行。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-list.jpg" alt="基础工具"></p>
<p>安全：</p>
<p>用于程序签名、设置安全测试等。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-anquan.jpg" alt="安全工具"></p>
<p>国际化：</p>
<p>用于创建本地语言文件。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">native2ascii</td>
<td>本地编码到ASCII编码的转换器（Native-to-ASCII Converter）用于”任意受支持的字符编码”和与之对应的”ASCII编码和Unicode转义”之间的相互转换。</td>
</tr>
</tbody></table>
<p>远程方法调用：</p>
<p>用于跨Web或网络的服务交互。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-rmi.jpg" alt="远程方法调用工具"></p>
<p>Java IDL与RMI-IIOP：在JDK 11中结束了十余年的CORBA支持，这些工具不再提供。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-idl.jpg" alt="Java IDL与RMI-IIOP"></p>
<p>部署工具：用于程序打包、发布和部署。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-deploy.jpg" alt="Java IDL与RMI-IIOP"></p>
<p>Java Web Start：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">javaws</td>
<td align="center">启动Java Web Start并设置各种选项的工具。jdk11已移除。</td>
</tr>
</tbody></table>
<p>性能监控和故障处理：</p>
<p>用于监控分析Java虚拟机运行信息，排查问题。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-contrl.jpg" alt="性能监控和故障处理"></p>
<p>WebService工具：</p>
<p>与CORBA一起在JDK 11中被移除。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-webservice.jpg" alt="WebService工具"></p>
<p>REPL和脚本工具:</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-repl.jpg" alt="REPL和脚本工具"></p>
<h3 id="二、可视化故障处理工具"><a href="#二、可视化故障处理工具" class="headerlink" title="二、可视化故障处理工具"></a>二、可视化故障处理工具</h3><p>JDK中除了附带大量的命令行工具外，还提供了几个功能集成度更高的可视化工具，可以使用这些可视化工具以更加便捷的方式进行进程故障诊断和调试工作。</p>
<p>这类工具主要包括JConsole、JHSDB、VisualVM和JMC四个。</p>
<p>JConsole、JHSDB是jdk正式成员，无须独立下载，使用完全免费。</p>
<p>VisualVM 已不是JDK中的正式成员，但仍是可以免费下载、使用。</p>
<p>Java Mission Control ： JMC需要与HotSpot内部的”飞行记录仪”（Java Flight Recorder，JFR）配合才能工作，而在JDK 11以前，JFR的开启必须解锁OracleJDK的商业特性支持（使用JCMD的VM.unlock_commercial_features或启动时加入-XX：+UnlockCommercialFeatures参数），在生产环境中仍然是需要付费使用。</p>
<h4 id="1、JHSDB"><a href="#1、JHSDB" class="headerlink" title="1、JHSDB"></a>1、JHSDB</h4><p>JHSDB基于服务性代理的调试工具。</p>
<p>JDK中提供了JCMD和JHSDB两个集成式的多功能工具箱，整合基础处理工具，更强大。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-compare.jpg" alt="JCMD、JHSDB和基础工具的对比"></p>
<p>工具的命令模式基本相似。使用时借助<code>help</code>选项使用。</p>
<p>JHSDB是一款基于服务性代理（Serviceability Agent，SA）实现的进程外调试工具。</p>
<p>原理：</p>
<blockquote>
<p>服务性代理是HotSpot虚拟机中一组用于映射Java虚拟机运行信息的、主要基于Java语言（含少量JNI代码）实现的API集合。服务性代理以HotSpot内部的数据结构为参照物进行设计，把这些C++的数据抽象出Java模型对象，相当于HotSpot的C++代码的一个镜像。通过服务性代理的API，可以在一个独立的Java虚拟机的进程里分析其他HotSpot虚拟机的内部数据，或者从HotSpot虚拟机进程内存中dump出来的转储快照里还原出它的运行状态细节。服务性代理的工作原理跟Linux上的GDB或者Windows上的Windbg是相似的。</p>
</blockquote>
<p>（JHSDB本身对压缩指针的支持存在很多缺陷，建议用64位系统的实验时禁用压缩指针）</p>
<pre><code>-Xmx10m -XX:+UseSerialGC 
-XX:-UseCompressedOops</code></pre><p>程序执行后通过jsp查询到测试查询进程ID：</p>
<pre><code>jps -l  //查看进程id
jhsdb hsdb --pid 10987 //打开图形化界面</code></pre><p>Tools-&gt;Heap Parameters 可以看到堆的相关参数。</p>
<p>Heap Parameters窗口中清楚列出了新生代的Eden、S1、S2和老年代的容量（单位为字节）以及它们的虚拟内存地址起止范围。</p>
<p>使用JDK默认的G1的话，得到的信息应该类似如下所示</p>
<pre><code>Heap Parameters:
garbage-first heap [0x00007f32c7800000, 0x00007f32c8200000] region size 1024K</code></pre><p>Windows-&gt;Console窗口，使用scanoops命令在Java堆的新生代（从Eden起始地址到To Survivor结束地址）范围内查找ObjectHolder的实例。</p>
<pre class=" language-txt"><code class="language-txt">hsdb>scanoops 0x00007f32c7800000 0x00007f32c7b50000 JHSDB_TestCase$ObjectHolder
0x00007f32c7a7c458 JHSDB_TestCase$ObjectHolder
0x00007f32c7a7c480 JHSDB_TestCase$ObjectHolder
0x00007f32c7a7c490 JHSDB_TestCase$ObjectHolder</code></pre>
<p>一般可以通过观察起始地址，判断实例对象分配在哪个区。</p>
<p>Tools-&gt;Inspector功能可以确认一下虚拟内存地址中存放的对象。</p>
<p>Inspector为我们展示了对象头和指向对象元数据的指针，里面包括了Java类型的名字、继承关系、实现接口关系，字段信息、方法信息、运行时常量池的指针、内嵌的虚方法表（vtable）以及接口方法表（itable）等。</p>
<p>Tools-&gt;Compute Reverse Ptrs 可以根据堆中对象实例地址找出引用它们的指针。</p>
<p>命令行也可以实现该功能：<code>revptrs 0x0007f32cdf785</code> </p>
<p>（revptrs命令并不支持查找栈上的指针引用）</p>
<blockquote>
<p>JDK 7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，存储于Java堆之中。</p>
</blockquote>
<p>Java Thread窗口选中main线程后点击Stack Memory按钮查看该线程的栈内存。</p>
<p>线程信息、栈帧信息、以及JHSDB自动生成的注释信息。</p>
<h4 id="2、-JConsole"><a href="#2、-JConsole" class="headerlink" title="2、 JConsole"></a>2、 JConsole</h4><p> JConsole：Java监视与管理控制台。</p>
<p>JConsole（Java Monitoring and Management Console）是一款基于JMX（Java Manage-ment Extensions）的可视化监视、管理工具。它的主要功能是通过JMX的MBean（Managed Bean）对系统进行信息收集和参数动态调整。</p>
<blockquote>
<p>JMX是一种开放性的技术，不仅可以用在虚拟机本身的管理上，还可以运行于虚拟机之上的软件中，典型的如中间件大多也基于JMX来实现管理与监控。虚拟机对JMX MBean的访问也是完全开放的，可以使用代码调用API、支持JMX协议的管理控制台，或者其他符合JMX规范的软件进行访问。</p>
</blockquote>
<p>（1）启动JConsole</p>
<p>通过JDK/bin目录下的jconsole.exe启动JCon-sole后，会自动搜索出本机运行的所有虚拟机进程，而不需要用户自己使用jps来查询。图片就不放了。</p>
<p>双击选择其中一个进程便可进入主界面开始监控。JMX支持跨服务器的管理，也可以使用下面的”远程进程”功能来连接远程服务器，对远程虚拟机进行监控。</p>
<p>进入JConsole主界面，可以看到主界面里共包括”概述””内存””线程””类””VM摘要””MBean”六个页签，”概述”页签里显示的是整个虚拟机主要运行数据的概览信息，包括”堆内存使用情况””线程””类””CPU使用情况”四项信息的曲线图。</p>
<p>（2）内存监控</p>
<p>“内存”页签的作用相当于可视化的jstat命令，用于监视被收集器管理的虚拟机内存（被收集器直接管理的Java堆和被间接管理的方法区）的变化趋势。</p>
<p>运行测试可以设置一下虚拟机参数（也可以不设置）</p>
<p><code>-Xms100m  -Xmx100m -XX:+UseSerialGC</code></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 内存占位符对象，一个OOMObject大约占64KB
 */</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fillHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>OOMObject<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>OOMObject<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 稍作延时，令监视曲线的变化更加明显</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    <span class="token function">fillHeap</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这段代码的作用是以64KB/50ms的速度向Java堆中填充数据，一共填充1000次，使用JConsole的”内存”页签进行监视，观察曲线和柱状指示图的变化。</p>
<p>程序运行后，在”内存”页签中应该可以看到内存池Eden区的运行趋势呈现折线状。</p>
<p>虚拟机启动参数只限制了Java堆为100MB，但没有明确使用-Xmn参数指定新生代大小，在没有设置-XX：SurvivorRadio参数时，Eden与Survivor空间比例的默认值为8∶1。</p>
<p>一般默认情况下，新生代约占堆内存的的1/3，老年代约占2/3。</p>
<p>可以从页签的信息上得到验证。</p>
<p>System.gc()；不保证一定进行回收。</p>
<h4 id="3、线程监控"><a href="#3、线程监控" class="headerlink" title="3、线程监控"></a>3、线程监控</h4><p>“线程”页签的功能就相当于可视化的jstack命令。</p>
<p>遇到线程停顿的时候可以使用这个页签的功能进行分析。。</p>
<pre><code>/**
 * 线程死循环演示
 */
public static void createBusyThread() {
Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        while (true)   // 第41行
            ;
    }
}, &quot;testBusyThread&quot;);
thread.start();
}

/**
 * 线程锁等待演示
 */
public static void createLockThread(final Object lock) {
Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (lock) {
            try {
                lock.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, &quot;testLockThread&quot;);
thread.start();
}

public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    br.readLine();
    createBusyThread();
    br.readLine();
    Object obj = new Object();
    createLockThread(obj);
}</code></pre><p>程序运行后，首先在”线程”页签中选择main线程。</p>
<blockquote>
<p>堆栈追踪显示BufferedReader的readBytes()方法正在等待System.in的键盘输入，这时候线程为Runnable状态，Runnable状态的线程仍会被分配运行时间，但readBytes()方法检查到流没有更新就会立刻归还执行令牌给操作系统，这种等待只消耗很小的处理器资源。</p>
</blockquote>
<p>监控testBusyThread线程。testBusyThread线程一直在执行空循环，从堆栈追踪中看到一直在MonitoringTest.java代码的41行停留，41行的代码为while(true)。这时候线程为Runnable状态，而且没有归还线程执行令牌的动作，所以会在空循环耗尽操作系统分配给它的执行时间，直到线程切换为止，这种等待会消耗大量的处理器资源。</p>
<p>未完。。。。</p>
<h4 id="4、VisualVM"><a href="#4、VisualVM" class="headerlink" title="4、VisualVM"></a>4、VisualVM</h4><p>VisualVM：多合-故障处理工具。</p>
<p>VisualVM（All-in-One Java Troubleshooting Tool）是功能最强大的运行监视和故障处理程序之一，曾经在很长一段时间内是Oracle官方主力发展的虚拟机故障处理工具。</p>
<p>它除了常规的运行监视、故障处理外，还将提供其他方面的能力，譬如性能分析（Profiling）。VisualVM的性能分析功能比起JProfiler、YourKit等专业且收费的Profiling工具都不遑多让。</p>
<p>它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。</p>
<p>（1）VisualVM兼容范围与插件安装</p>
<p>VisualVM基于NetBeans平台开发工具，所以一开始它就具备了通过插件扩展功能的能力，有了插件扩展支持，VisualVM可以做到：</p>
<p>​    （a）显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</p>
<p>​    （b）监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息（jstat、jstack）。</p>
<p>​    （c）dump以及分析堆转储快照（jmap、jhat）。</p>
<p>​    （d）方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</p>
<p>​    （e）离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。</p>
<p>​    （f）其他插件带来的无限可能性。</p>
<p>VisualVM在JDK 6 Update 7中首次发布，但并不意味着它只能监控运行于JDK 6上的程序，它具备很优秀的向下兼容性，甚至能向下兼容至2003年发布的JDK 1.4.2版本。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-jvisVM.jpg" alt="VisualVM主要功能兼容性列表"></p>
<p>VisualVM的插件安装：</p>
<p>（A）手工进行安装</p>
<p>VisualVM的插件可以手工进行安装，在网站[插图]上下载nbm包后，点击”工具-&gt;插件-&gt;已下载”菜单，然后在弹出对话框中指定nbm包路径便可完成安装。独立安装的插件存储在VisualVM的根目录，譬如JDK 9之前自带的VisulalVM，插件安装后是放在JDK_HOME/lib/visualvm中的。</p>
<p>（B）自动安装</p>
<p>VisualVM的自动安装功能已可找到大多数所需的插件，在有网络连接的环境下，点击”工具-&gt;插件菜单”，在页签的”可用插件”及”已安装”中列举了当前版本VisualVM可以使用的全部插件，选中插件后在右边窗口会显示这个插件的基本信息，如开发者、版本、功能描述等。</p>
<p>VisualVM中”概述””监视””线程””MBeans”的功能与Jconsole相似。</p>
<p>（2）生成、浏览堆转储快照</p>
<p>在VisualVM中生成堆转储快照文件有两种方式，</p>
<p>​    a）在”应用程序”窗口中右键单击应用程序节点，然后选择”堆Dump”。</p>
<p>​    b）在”应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在”监视”标签中单击”堆Dump”。</p>
<p>生成堆转储快照文件之后，应用程序页签会在该堆的应用程序下增加一个以[heap-dump]开头的子节点，并且在主页签中打开该转储快照。</p>
<blockquote>
<p>如果需要把堆转储快照保存或发送出去，就应在heapdump节点上右键选择”另存为”菜单，否则当VisualVM关闭时，生成的堆转储快照文件会被当作临时文件自动清理掉。要打开一个由已经存在的堆转储快照文件，通过文件菜单中的”装入”功能，选择文件即可。</p>
</blockquote>
<p>堆页签中的”摘要”面板可以看到应用程序dump时的运行时参数、System.getPro-perties()的内容、线程堆栈等信息；</p>
<p>“类”面板则是以类为统计口径统计类的实例数量、容量信息；</p>
<p>“实例”面板不能直接使用，因为VisualVM在此时还无法确定用户想查看哪个类的实例，所以需要通过”类”面板进入，在”类”中选择一个需要查看的类，然后双击即可在”实例”里面看到此类的其中500个实例的具体属性信息；</p>
<p>“OQL控制台”面板则是运行OQL查询语句的，同jhat中介绍的OQL功能一样。</p>
<p>（3）分析程序性能</p>
<p>在Profiler页签中，VisualVM提供了程序运行期间方法级的处理器执行时间分析以及内存分析。做Profiling分析肯定会对程序运行性能有比较大的影响，所以一般不在生产环境使用这项功能，或者改用JMC来完成，JMC的Profiling能力更强，对应用的影响非常轻微。</p>
<p>要开始性能分析，先选择”CPU”和”内存”按钮中的一个，然后切换到应用程序中对程序进行操作，VisualVM会记录这段时间中应用程序执行过的所有方法。如果是进行处理器执行时间分析，将会统计每个方法的执行次数、执行耗时；如果是内存分析，则会统计每个方法关联的对象数以及这些对象所占的空间。等要分析的操作执行结束后，点击”停止”按钮结束监控过程。</p>
<blockquote>
<p>在JDK 5之后，在客户端模式下的虚拟机加入并且自动开启了类共享——这是一个在多虚拟机进程共享rt.jar中类数据以提高加载速度和节省内存的优化，而根据相关Bug报告的反映，VisualVM的Profiler功能会因为类共享而导致被监视的应用程序崩溃，所进行Profiling前，最好在被监视程序中使用-Xshare：off参数来关闭类共享优化。</p>
</blockquote>
<p>（4）BTrace动态日志跟踪</p>
<p>BTrace是一个很神奇的VisualVM插件，它本身也是一个可运行的独立程序。</p>
<p>BTrace的作用是在不中断目标程序运行的前提下，通过HotSpot虚拟机的Instrument功能[插图]动态加入原本并不存在的调试代码。这项功能对实际生产中的程序很有意义：如当程序出现问题时，排查错误的一些必要信息时（譬如方法参数、返回值等），在开发时并没有打印到日志之中以至于不得不停掉服务时，都可以通过调试增量来加入日志代码以解决问题。</p>
<p>在VisualVM中安装了BTrace插件后，在应用程序面板中右击要调试的程序，会出现”Trace Application…”菜单，点击将进入BTrace面板。</p>
<p>BTrace的功能演示：产生两个1000以内的随机整数，输出这两个数字相加的结果</p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BTraceTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        BTraceTest test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BTraceTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        BufferedReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这段程序已经上线运行，而我们现在又有了新的需求，想要知道程序中生成的两个随机数是什么，但程序并没有在执行过程中输出这一点。此时，在VisualVM中打开该程序的监视，在BTrace页签填充TracingScript的内容，输入调试代码，即可在不中断程序运行的情况下做到这一点。</p>
<pre><code>/* BTrace Script Template */
import com.sun.btrace.annotations.*;
import static com.sun.btrace.BTraceUtils.*;

@BTrace
public class TracingScript {
        @OnMethod(
    clazz=&quot;org.fenixsoft.monitoring.BTraceTest&quot;,
    method=&quot;add&quot;,
    location=@Location(Kind.RETURN)
)

public static void func(@Self org.fenixsoft.monitoring.BTraceTest instance,int a, int b,@Return int result) {
    println(&quot;调用堆栈:&quot;);
    jstack();
    println(strcat(&quot;方法参数A:&quot;,str(a)));
    println(strcat(&quot;方法参数B:&quot;,str(b)));
    println(strcat(&quot;方法结果:&quot;,str(result)));
}
}</code></pre><p>点击Start按钮后稍等片刻，编译完成后，Output面板中会出现”BTracecode successfuly deployed”的字样。当程序运行时将会在Output面板输出调试信息。</p>
<p>BTrace的用途很广泛，打印调用堆栈、参数、返回值只是它最基础的使用形式，使用BTrace进行性能监视、定位连接泄漏、内存泄漏、解决多线程竞争问题等。</p>
<p>BTrace能够实现动态修改程序行为，是因为它是基于Java虚拟机的Instrument开发的。Instrument是Java虚拟机工具接口（Java VirtualMachine Tool Interface，JVMTI）的重要组件，提供了一套代理（Agent）机制，使得第三方工具程序可以以代理的方式访问和修改Java虚拟机内部的数据。</p>
<blockquote>
<p>阿里巴巴开源的诊断工具Arthas也通过Instrument实现了与BTrace类似的功能。</p>
</blockquote>
<p>4、Java Mission Control</p>
<p>Java Mission Control：可持续在线的监控工具。</p>
<p>Oracle Java SE Advanced &amp; Suite[插图]与普通OracleJava SE在功能上的主要差别是前者包含了一系列的监控、管理工具，譬如用于企业JRE定制管理的AMC（Java Advanced ManagementConsole）控制台、JUT（Java Usage Tracker）跟踪系统，用于持续收集数据的JFR（Java Flight Recorder）飞行记录仪和用于监控Java虚拟机的JMC（Java Mission Control）。这些功能全部都是需要商业授权才能在生产环境中使用，但根据Oracle Binary Code协议，在个人开发环境中，允许免费使用JMC和JFR。</p>
<p>JFR特点：</p>
<p>（1）JFR是一套内建在HotSpot虚拟机里面的监控和基于事件的信息搜集框架，与其他的监控工具（如JProfiling）相比，它具有”可持续在线”（Always-On）的特性。</p>
<p>（2）JFR在生产环境中对吞吐量的影响一般不会高于1%（甚至号称是Zero Performance Overhead）。</p>
<p>（3）JFR监控过程的开始、停止都是完全可动态的，即不需要重启应用。</p>
<p>（4）JFR的监控对应用也是完全透明的，即不需要对应用程序的源码做任何修改，或者基于特定的代理来运行。</p>
<p>JMC：</p>
<p>（1）Eclipse RCP作为基础框架。</p>
<p>（2）可下载独立程序，也可以作为Eclipse插件安装。</p>
<p>（3）JMC与虚拟机之间同样采取JMX协议进行通信，作为JMX控制台显示来自虚拟机MBean提供的数据。</p>
<p>（4）JMC还可以作为JFR的分析工具，展示来自JFR的数据。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-tools/jvm-tools-jmc.jpg" alt="JMC主界面"></p>
<p>打开界面之后，双击”飞行记录器”，将会出现”启动飞行记录”窗口。</p>
<p>飞行记录报告里包含以下几类信息：</p>
<p>（a）一般信息：关于虚拟机、操作系统和记录的一般信息。</p>
<p>（b）内存：关于内存管理和垃圾收集的信息。</p>
<p>（c）代码：关于方法、异常错误、编译和类加载的信息。</p>
<p>（d）线程：关于应用程序中线程和锁的信息。</p>
<p>（e）I/O：关于文件和套接字输入、输出的信息。</p>
<p>（f）系统：关于正在运行Java虚拟机的系统、进程和环境变量的信息。</p>
<p>（g）事件：关于记录中的事件类型的信息，可以根据线程或堆栈跟踪，按照日志或图形的格式查看。</p>
<p>JFR工作过程：</p>
<p>JFR开启一系列事件的录制动作，当某个事件发生时，这个事件的所有上下文数据将会以循环日志的形式被保存至内存或者指定的某个文件当中，循环日志相当于数据流被保留在一个环形缓存中，所以只有最近发生的事件的数据才是可用的。JMC从虚拟机内存或者文件中读取并展示这些事件数据，并通过这些数据进行性能分析。</p>
<blockquote>
<p>JFR提供的数据质量通常也要比其他工具通过代理形式采样获得或者从MBean中取得的数据高得多。以垃圾搜集为例，HotSpot的MBean中一般有各个分代大小、收集次数、时间、占用率等数据（根据收集器不同有所差别），这些都属于”结果”类的信息，而JFR中还可以看到内存中这段时间分配了哪些对象、哪些在TLAB中（或外部）分配、分配速率和压力大小如何、分配归属的线程、收集时对象分代晋升的情况等，这些就是属于”过程”类的信息，对排查问题的价值是难以估量的。</p>
</blockquote>
<h3 id="三、HotSpot虚拟机插件及工具"><a href="#三、HotSpot虚拟机插件及工具" class="headerlink" title="三、HotSpot虚拟机插件及工具"></a>三、HotSpot虚拟机插件及工具</h3><p>虚拟机的插件和辅助工具存放在HotSpot源码hotspot/src/share/tools目录下：</p>
<p>主要有：</p>
<p>（1）Ideal Graph Visualizer</p>
<p>用于可视化展示C2即时编译器是如何将字节码转化为理想图，然后转化为机器码的。</p>
<p>（2）Client Compiler Visualizer</p>
<p>用于查看C1即时编译器生成高级中间表示（HIR），转换成低级中间表示（LIR）和做物理寄存器分配的过程。</p>
<p>（3）MakeDeps</p>
<p>帮助处理HotSpot的编译依赖的工具。</p>
<p>（4）Project Creator</p>
<p>帮忙生成Visual Studio的.project文件的工具。</p>
<p>（5）LogCompilation</p>
<p>将-XX：+LogCompilation输出的日志整理成更容易阅读的格式的工具。</p>
<p>（6）HSDIS</p>
<p>即时编译器的反汇编插件。HSDIS可以用于JIT生成代码反汇编</p>
<p>HSDIS是一个被官方推荐的HotSpot虚拟机即时编译代码的反汇编插件，它包含在HotSpot虚拟机的源码当中，在OpenJDK的网站[插图]也可以找到单独的源码下载。</p>
<p>HSDIS插件的作用是让HotSpot的-XX：+PrintAssembly指令调用它来把即时编译器动态生成的本地代码还原为汇编代码输出，同时还会自动产生大量非常有价值的注释，这样可以通过输出的汇编代码来从最本质的角度分析问题。</p>
<blockquote>
<p>需要自己下载编译好的插件，直接放到JDK_HOME/jre/bin/server目录（JDK 9以下）或JDK_HOME/lib/amd64/server（JDK 9或以上）中即可使用。如果没有找到所采用操作系统的对应编译成品，那就自己用源码编译一遍（网上能找到各种操作系统下的编译教程）。</p>
<p>使用SlowDebug或者FastDebug版的HotSpot，可以直接通过-XX：+PrintAssembly指令使用的插件；</p>
<p>如果使用Product版的HotSpot，则还要额外加入一个-XX：+UnlockDiagnosticVMOptions参数才可以工作。</p>
</blockquote>
<p>相关示例涉及汇编语言，参考《深入理解Java虚拟机第三版》第四章4.4节。</p>
<p>JITWatch 是HSDIS经常搭配使用的可视化的编译日志分析工具，为便于在JITWatch中读取，可使用以下参数把日志输出到logfile文件。</p>
<pre class=" language-txt"><code class="language-txt">-XX:+UnlockDiagnosticVMOptions
-XX:+TraceClassLoading
-XX:+LogCompilation
-XX:LogFile=/tmp/logfile.log
-XX:+PrintAssembly
-XX:+TraceClassLoading</code></pre>
<p>在JITWatch中加载日志后，就可以看到执行期间使用过的各种对象类型和对应调用过的方法了，选择想要查看的类和方法，即可查看对应的Java源代码、字节码和即时编译器生成的汇编代码。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>监控调优工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之对象查询OQL</title>
    <url>/posts/2197a49e.html</url>
    <content><![CDATA[<h2 id="jvm之对象查询OQL"><a href="#jvm之对象查询OQL" class="headerlink" title="jvm之对象查询OQL"></a>jvm之对象查询OQL</h2><h3 id="一、SELECT子句"><a href="#一、SELECT子句" class="headerlink" title="一、SELECT子句"></a>一、SELECT子句</h3><p>SELECT子句用于确定查询语句需要从堆转储快照中选择什么内容。如果需要显示堆转储快照中的对象，并且浏览这些对象的引用关系，可以使用<code>&quot;*&quot;</code>，这与传统<code>SQL</code> 语句中的习惯是一致的，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</code></pre>
<h4 id="1-选择特定的显示列"><a href="#1-选择特定的显示列" class="headerlink" title="1.选择特定的显示列"></a>1.选择特定的显示列</h4><p>查询也可以选择特定的需要显示的字段，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> toString<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>count<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token keyword">value</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s</code></pre>
<p>查询可以通过“@”符号来使用Java对象的内存属性访问器。MAT提供了一系列的内置函数来获取与分析相关的信息，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> toString<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token variable">@userdHeapSize</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token variable">@retainedHeapSize</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s</code></pre>
<p>2、使用列别名</p>
<p>可以使用AS关键字来对选择的列进行命名。如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>
toString<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">as</span> val<span class="token punctuation">,</span> 
s<span class="token punctuation">.</span><span class="token variable">@userdHeapSize</span> <span class="token keyword">as</span> <span class="token string">"shallw Size"</span><span class="token punctuation">,</span> 
s<span class="token punctuation">.</span><span class="token variable">@retainedHeapSize</span> <span class="token keyword">as</span> <span class="token string">"restained Seize"</span>
<span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s</code></pre>
<p>可以使用AS RETAINED SET关键字来获得与选择对象相关联的对象集合，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">AS</span> RETAINED  <span class="token keyword">SET</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</code></pre>
<h4 id="3-拼合成为一个对象列表选择项目"><a href="#3-拼合成为一个对象列表选择项目" class="headerlink" title="3.拼合成为一个对象列表选择项目"></a>3.拼合成为一个对象列表选择项目</h4><p>可以使用OBJECTS关键字把SELECT子句中查找出来的数据项目转换为对象，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> OBJECTS dominators<span class="token punctuation">(</span>s<span class="token punctuation">)</span>  <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s</code></pre>
<p><code>dominators()</code>函数将会返回一个对象数组，所以如果没有OBJECTS关键字，上面的查询将返回一组二维的对象数组的列表。通过使用关键字OBJECTS，迫使<code>OQL</code>把查询结果缩减为一维的对象列表。</p>
<h4 id="4-排除重复对象"><a href="#4-排除重复对象" class="headerlink" title="4.排除重复对象"></a>4.排除重复对象</h4><p>使用DISTINCT关键字可以排除结果集中的重复对象，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  <span class="token keyword">DISTINCT</span>  classof<span class="token punctuation">(</span>s<span class="token punctuation">)</span>  <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s</code></pre>
<p><code>classof()</code>函数的作用是返回对象所属的Java类。</p>
<h3 id="二、FROM-子句"><a href="#二、FROM-子句" class="headerlink" title="二、FROM 子句"></a>二、FROM 子句</h3><h4 id="1-FROM子句"><a href="#1-FROM子句" class="headerlink" title="1.FROM子句"></a>1.FROM子句</h4><p>指定需要查询的类OQL查询需要在FROM子句定义的查询范围内进行操作。FROM子句可以接受的查询范围有下列几种描述方式：</p>
<p>（1）通过类名进行查询，如：</p>
<pre><code>SELECT  *  FROM java.lang.String </code></pre><p>（2）通过正则表达式匹配一组类名进行查询，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  <span class="token operator">*</span>  <span class="token keyword">FROM</span> <span class="token string">"java\.lang\..*"</span> </code></pre>
<p>（3）通过类对象在堆转储快照中的地址进行查询，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  <span class="token operator">*</span>  <span class="token keyword">FROM</span> <span class="token number">0xe12a20</span> </code></pre>
<p>（4）通过对象在堆转储快照中的ID进行查询，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  <span class="token operator">*</span>  <span class="token keyword">FROM</span> <span class="token number">4872</span> </code></pre>
<p>（5）在子查询中的结果集中进行查询，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  <span class="token operator">*</span>  <span class="token keyword">FROM</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span>  <span class="token operator">*</span>  <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Class <span class="token number">c</span> <span class="token keyword">WHERE</span> <span class="token number">c</span> implements <span class="token operator">or</span> g<span class="token punctuation">.</span>eclipse<span class="token punctuation">.</span>mat<span class="token punctuation">.</span><span class="token keyword">snapshot</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span>IClass<span class="token punctuation">)</span> </code></pre>
<p>上面的查询返回堆转储快照中所有实现了<code>org.eclipse.mat.snapshot.model.IClass</code>接口的类。下面的这句查询语句使用属性访问器达到了同样的效果，它直接调用了ISnapshot对象的方法：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> $<span class="token keyword">snapshot</span><span class="token punctuation">.</span>getClass<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h4 id="2-包含子类"><a href="#2-包含子类" class="headerlink" title="2.包含子类"></a>2.包含子类</h4><p>使用<code>INSTANCEOF</code>关键字把指定类的子类列入查询结果集之中，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INSTANCEOF  java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>Reference</code></pre>
<p>这个查询的结果集中将会包含WeakReference、SoftReference和PhantomReference类型的对象，因为它们都继承自java.lang.ref.Reference。下面这句查询语句也有相同的结果：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> $<span class="token keyword">snapshot</span><span class="token punctuation">.</span>getClassesByName<span class="token punctuation">(</span><span class="token string">"java.lang.ref.Reference"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span></code></pre>
<h4 id="3-禁止查询类实例"><a href="#3-禁止查询类实例" class="headerlink" title="3.禁止查询类实例"></a>3.禁止查询类实例</h4><p>在FROM子句中使用OBJECTS关键字可以禁止<code>OQL</code>把查询的范围解释为对象实例，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> OBJECTS java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String </code></pre>
<p>这个查询的结果不是返回快照中所有的字符串，而是只有一个对象，也就是与<code>java.lang.String</code>类对应的Class对象。</p>
<p>三、WHERE 子句</p>
<p>1、范围操作与关系操作</p>
<p>常见的范围有：  <code>&gt;=</code> ，<code>&lt;=</code>，<code>&gt;</code>，<code>&lt;</code>，<code>[NOT] LIKE</code>，<code>[ NOT ] IN</code></p>
<p>WHERE子句用于指定搜索的条件，即从查询结果中删除不需要的数据，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> s<span class="token punctuation">.</span>count <span class="token operator">>=</span> <span class="token number">100</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> totring<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">LIKE</span> <span class="token string">".*service"</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> s<span class="token punctuation">.</span><span class="token keyword">value</span> <span class="token operator">NOT</span> <span class="token operator">IN</span> dominators<span class="token punctuation">(</span>s<span class="token punctuation">)</span></code></pre>
<p>2、 等于操作（ <code>=</code>  ，<code>!=</code>）</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> totring<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"sayService"</span></code></pre>
<p>3、条件与操作（<code>AND</code>）</p>
<p>and操作：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> s<span class="token punctuation">.</span>count <span class="token operator">>=</span> <span class="token number">100</span> <span class="token operator">AND</span> s<span class="token punctuation">.</span><span class="token variable">@retainedHeapSize</span> <span class="token operator">></span> s<span class="token punctuation">.</span><span class="token variable">@usedHeapSize</span></code></pre>
<p>4、条件或 操作（<code>OR</code>）</p>
<p>条件或 操作可以应用于表达式、常量文本和子查询。如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> s<span class="token punctuation">.</span>count <span class="token operator">>=</span> <span class="token number">100</span>  <span class="token operator">OR</span> s<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">.</span><span class="token variable">@length</span> <span class="token operator">></span> <span class="token number">500</span></code></pre>
<p>5、文字表达式</p>
<p>文字表达式保存布尔值、字符串、整型、长整型和null，如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">>=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span> 
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> toString<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"hello World!"</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> dominators<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> s<span class="token punctuation">.</span><span class="token variable">@retainedHeapSize</span> <span class="token operator">></span> 1024L
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">WHERE</span> s<span class="token punctuation">.</span><span class="token variable">@GCRootInfo</span> <span class="token operator">!=</span> <span class="token boolean">null</span></code></pre>
<h3 id="四、属性访问器"><a href="#四、属性访问器" class="headerlink" title="四、属性访问器"></a>四、属性访问器</h3><p>1、访问堆转储快照中对象的字段对象的内存属性可以通过传统的“点表示法”进行访问，格式为：</p>
<pre class=" language-txt"><code class="language-txt">[ <alias>.] <field>.<field>.<field>...</code></pre>
<p>2、访问Java Bean属性</p>
<pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span> <span class="token operator">&lt;</span>alias<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">]</span> @<span class="token operator">&lt;</span>attribute<span class="token operator">></span> </code></pre>
<p>使用@符号，<code>OQL</code>可以访问底层Java对象的内存属性。下表列出了一些常用的Java属性。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-oql.jpg" alt="常用的Java属性"></p>
<p>3、调用<code>OQL</code> Java方法</p>
<pre class=" language-txt"><code class="language-txt">[ <alias>.] @<method>([<expression>, <expression>]) </code></pre>
<p>加“()”会将MAT解释为一个<code>OQL</code> Java方法调用。这个方法的调用是通过反射执行的。常见的<code>OQL</code>Java方法如下：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-oql-2.jpg" alt="常见的OQL Java方法"></p>
<p>4、OQL的内建函数</p>
<pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">function</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>parameter<span class="token operator">></span><span class="token punctuation">)</span></code></pre>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-oql-3.jpg" alt="常用内建函数"></p>
<h3 id="五、OQL语言的BNF范式"><a href="#五、OQL语言的BNF范式" class="headerlink" title="五、OQL语言的BNF范式"></a>五、OQL语言的BNF范式</h3><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-oql-bnf-1.jpg" alt="常用内建函数"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-oql-bnf-2.jpg" alt="常用内建函数"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>OQL</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm字节码指令表</title>
    <url>/posts/ee62cca5.html</url>
    <content><![CDATA[<h2 id="JVM字节码指令表"><a href="#JVM字节码指令表" class="headerlink" title="JVM字节码指令表"></a>JVM字节码指令表</h2><h3 id="java虚拟机字节码指令表"><a href="#java虚拟机字节码指令表" class="headerlink" title="java虚拟机字节码指令表"></a>java虚拟机字节码指令表</h3><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-code-byte-1.jpg" alt="java虚拟机字节码指令表1"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-code-byte-2.jpg" alt="java虚拟机字节码指令表2"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-code-byte-3.jpg" alt="java虚拟机字节码指令表3"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-code-byte-4.jpg" alt="java虚拟机字节码指令表4"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-code-byte-5.jpg" alt="java虚拟机字节码指令表5"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-code-byte-6.jpg" alt="java虚拟机字节码指令表6"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-code-byte-7.jpg" alt="java虚拟机字节码指令表7"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>字节码指令表</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm之类文件结构</title>
    <url>/posts/6698cab3.html</url>
    <content><![CDATA[<h2 id="jvm类文件结构"><a href="#jvm类文件结构" class="headerlink" title="jvm类文件结构"></a>jvm类文件结构</h2><p>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（ByteCode）。</p>
<blockquote>
<p>Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与”Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。</p>
<p>Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。</p>
</blockquote>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class.jpg" alt="java虚拟机的语言无关性"></p>
<h2 id="一、Class类文件的结构"><a href="#一、Class类文件的结构" class="headerlink" title="一、Class类文件的结构"></a>一、Class类文件的结构</h2><h4 id="1、class文件的主要结构"><a href="#1、class文件的主要结构" class="headerlink" title="1、class文件的主要结构"></a>1、class文件的主要结构</h4><p>通常来说，任何一个Class文件都对应着唯一的一个类或接口的定义信息。类或接口并不一定都得定义在文件里（比如类或接口也可以动态生成，直接送入类加载器中）。</p>
<blockquote>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[插图]的方式分割成若干个8个字节进行存储。</p>
</blockquote>
<p>《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：”无符号数”和”表”。</p>
<p>（1）无符号数：</p>
<p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
<p>（2）表</p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表的命名都习惯性地以<code>&quot;_info&quot;</code>结尾。</p>
<p>表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，表的数据项按严格顺序排列构成的。</p>
<p>class文件格式数据项如图：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-2.jpg" alt="class文件格式"></p>
<p>无符号数或表中，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的”集合”。</p>
<p><strong>特别说明</strong></p>
<blockquote>
<p>Class的结构没有任何分隔符号，所以上图的数据项中，无论是顺序还是数量，甚至于数据存储的字节序（ByteOrdering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变。</p>
</blockquote>
<h4 id="2、魔数与Class文件的版本"><a href="#2、魔数与Class文件的版本" class="headerlink" title="2、魔数与Class文件的版本"></a>2、魔数与Class文件的版本</h4><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p>
<p>java的Class文件的魔数值固定为<code>0xCAFEBABE</code>。</p>
<p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。</p>
<blockquote>
<p>Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</blockquote>
<p>当我学到这里我算是明白以前在项目过程中，遇到用高版本编译，低版本运行报错的真正原因了。</p>
<p>如：JDK 1.1能支持版本号为45.0～45.65535的Class文件，无法执行版本号为46.0以上的Class文件，而JDK 1.2则能支持45.0～46.65535的Class文件。目前最新的JDK版本为13，可生成的Class文件主版本号最大值为57.0。</p>
<p>比如来个经典的HelloWorld文件，加个变量和方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">.</span>com<span class="token punctuation">.</span>xiaocai<span class="token punctuation">.</span>klass<span class="token punctuation">.</span>test<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>用WinHex打开HelloWorld.class文件：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo1.png" alt="HelloWorld.class文件版本示例"></p>
<p>可以清楚地看见开头4个字节的十六进制表示是0xCAFEBABE，代表次版本号的第5个和第6个字节值为0x0000，而主版本号的值为0x0033，也即是十进制的51，对应的jdk7，可以被jdk7及以上版本虚拟机执行。</p>
<p>主流JDK版本编译器输出的默认的和可支持的Class文件版本号。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-verson.jpg" alt="jdk与class文件版本对照"></p>
<p>注：从JDK 9开始，Javac编译器不再支持使用-source参数编译版本号小于1.5的源码。</p>
<p>次版本号，从JDK 1.2以后，直到JDK 12之前次版本号均未使用，全部固定为零。JDK 12开始，重新启用次版本号，将它用于标识”技术预览版”功能特性的支持。如果Class文件中使用了该版本JDK尚未列入正式特性清单中的预览功能，则必须把次版本号标识为65535，以便Java虚拟机在加载类文件时能够区分出来。</p>
<h4 id="3、常量池"><a href="#3、常量池" class="headerlink" title="3、常量池"></a>3、常量池</h4><p>紧接着主、次版本号之后的是常量池入口。常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</p>
<p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。这个容量计数是从1而不是0开始的，如图HelloWorld类文件截图：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo2.png" alt="HelloWorld.class里的常量池"></p>
<p>常量池容量（偏移地址：0x00000008）为十六进制数0x0028，即十进制的40，这就代表常量池中有40项常量，索引值范围为1～40。</p>
<blockquote>
<p>索引值第0项常量空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始。</p>
</blockquote>
<p>常量池中主要存放两大类常量：字面量（Literal） 和 符号引用（Symbolic References） 。</p>
<p>（1）字面量（Literal）</p>
<p>如文本字符串、被声明为final的常量值等</p>
<p>（2）符号引用（Symbolic References） :</p>
<p>主要有以下几类：</p>
<p>​    （a）被模块导出或者开放的包（Package）</p>
<p>​    （b）类和接口的全限定名（Fully Qualified Name）</p>
<p>​    （c）字段的名称和描述符（Descriptor）</p>
<p>​    （d）方法的名称和描述符</p>
<p>​    （e）方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</p>
<p>​    （f）动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-ComputedConstant）</p>
<blockquote>
<p>虚拟机加载Class文件的时候进行动态连接，所以在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
</blockquote>
<p>常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量[插图]，为了支持Java模块化系统（Jigsaw），又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量，所以截至JDK 13，常量表中分别有17种不同类型的常量。</p>
<p>17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位（tag），代表着当前常量属于哪种常量类型。如图：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-clc.jpg" alt="17种常量类型"></p>
<p>这17种常量类型各自有着完全独立的数据结构。</p>
<p>依旧以Helloworld.class为例：</p>
<p>标志位（偏移地址：0x0000000A）是0x07，查上表标志是7对应的常量类型是CONSTANT_Class_info，代表一个类或者接口的符号引用。</p>
<p>CONSTANT_Class_info的结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>ul</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
</tbody></table>
<p>tag是标志位，它用于区分常量类型；</p>
<p>name_index是常量池的索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名。</p>
<p>依旧以Helloworld.class为例</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo3.png" alt="HelloWorld类常量池结构"></p>
<p>name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量，图中第二项常量标志位（地址：0x0000000D）是0x01。查常量池表，可以确定是一个CONSTANT_Utf8_info类型的常量。</p>
<p>CONSTANT_Utf8_info型常量的结构:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>ul</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody></table>
<blockquote>
<p>length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。UTF-8缩略编码与普通UTF-8编码的区别是：从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’开始到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</p>
</blockquote>
<p>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。Java程序中如果定义了超过64KB英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</p>
<p>在helloworld的例中</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo4.png" alt="常量池UTF-8字符串结构"></p>
<p>这个字符串的length值（偏移地址：0x0000000E）为0x0026，也就是长38个字节，往后38个字节正好都在1～127的ASCII码范围以内，内容为”test.com.xiaocai.klass.test.HelloWorld”，转换部分后续再补上。</p>
<p>//十六进制转换待补充</p>
<p>在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。</p>
<p>直接使用javap工具的-verbose参数输出的TestClass.class文件字节码内容。</p>
<p>命令如下：</p>
<pre><code>javap -verbose HelloWorld.class </code></pre><p>由于文件长我写到txt里，全部内容如下，暂且称之为字节码清单：</p>
<pre class=" language-txt"><code class="language-txt">Classfile /E:/ide-tools/apache-tomcat-7.0.90-eclispe-pmis/webapps/pmis/WEB-INF/classes/test/com/xiaocai/klass/test/HelloWorld.class
  Last modified 2020-6-9; size 691 bytes
  MD5 checksum 549d707e6692d2c884983e3ad0873405
  Compiled from "HelloWorld.java"
public class test.com.xiaocai.klass.test.HelloWorld
  SourceFile: "HelloWorld.java"
  minor version: 0
  major version: 51
  flags: ACC_PUBLIC, ACC_SUPER

Constant pool:
   #1 = Class              #2             //  test/com/xiaocai/klass/test/HelloWorld
   #2 = Utf8               test/com/xiaocai/klass/test/HelloWorld
   #3 = Class              #4             //  java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Utf8               m
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Methodref          #3.#11         //  java/lang/Object."<init>":()V
  #11 = NameAndType        #7:#8          //  "<init>":()V
  #12 = Utf8               LineNumberTable
  #13 = Utf8               LocalVariableTable
  #14 = Utf8               this
  #15 = Utf8               Ltest/com/xiaocai/klass/test/HelloWorld;
  #16 = Utf8               add
  #17 = Utf8               ()I
  #18 = Fieldref           #1.#19         //  test/com/xiaocai/klass/test/HelloWorld.m:I
  #19 = NameAndType        #5:#6          //  m:I
  #20 = Utf8               main
  #21 = Utf8               ([Ljava/lang/String;)V
  #22 = Fieldref           #23.#25        //  java/lang/System.out:Ljava/io/PrintStream;
  #23 = Class              #24            //  java/lang/System
  #24 = Utf8               java/lang/System
  #25 = NameAndType        #26:#27        //  out:Ljava/io/PrintStream;
  #26 = Utf8               out
  #27 = Utf8               Ljava/io/PrintStream;
  #28 = String             #29            //  Hello World!
  #29 = Utf8               Hello World!
  #30 = Methodref          #31.#33        //  java/io/PrintStream.println:(Ljava/lang/String;)V
  #31 = Class              #32            //  java/io/PrintStream
  #32 = Utf8               java/io/PrintStream
  #33 = NameAndType        #34:#35        //  println:(Ljava/lang/String;)V
  #34 = Utf8               println
  #35 = Utf8               (Ljava/lang/String;)V
  #36 = Utf8               args
  #37 = Utf8               [Ljava/lang/String;
  #38 = Utf8               SourceFile
  #39 = Utf8               HelloWorld.java
{
  public test.com.xiaocai.klass.test.HelloWorld();
    flags: ACC_PUBLIC

    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokespecial #10                 // Method java/lang/Object."<init>":()V
         4: return        
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   Ltest/com/xiaocai/klass/test/HelloWorld;

  public int add();
    flags: ACC_PUBLIC

    Code:
      stack=2, locals=1, args_size=1
         0: aload_0       
         1: getfield      #18                 // Field m:I
         4: iconst_1      
         5: iadd          
         6: ireturn       
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       7     0  this   Ltest/com/xiaocai/klass/test/HelloWorld;

  public static void main(java.lang.String[]);
    flags: ACC_PUBLIC, ACC_STATIC

    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #22                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #28                 // String Hello World!
         5: invokevirtual #30                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return        
      LineNumberTable:
        line 13: 0
        line 15: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       9     0  args   [Ljava/lang/String;
}</code></pre>
<p>根据清单可以看出常量池中有39项常量，索引值范围为1～39，对应着十六进制的0x0028，也就是十进制的40。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo0.jpg" alt="常量池中的17种数据类型的结构总表1"></p>
<p>字节码清单中第1、2项常量的计算结果与我们手工计算的结果完全一致。</p>
<blockquote>
<p>还有一些常量如”I”、”V”、”<init>“、”LineNumberTable”、”LocalVariableTable”等都是 编译器自己生成的，会被字段表（field_info）、方法表（method_info）、属性表（attribute_info）所引用。它们将会被用来描述一些不方便使用”固定字节”进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么。</p>
</blockquote>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-changlangchi-1.jpg" alt="常量池中的17种数据类型的结构总表1"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-changlangchi-2.jpg" alt="常量池中的17种数据类型的结构总表2"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-changlangchi-3.jpg" alt="常量池中的17种数据类型的结构总表3"></p>
<h4 id="4、访问标志"><a href="#4、访问标志" class="headerlink" title="4、访问标志"></a>4、访问标志</h4><p>常量池结束之后，紧接着的2个字节代表访问标志（access_flags）。</p>
<p>访问标志用于识别一些类或者接口层次的访问信息。包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。</p>
<p>访问标志相关说明如下表：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-accessflag.jpg" alt="访问标志说明表"></p>
<p>access_flags中一共有16个标志位可以使用，当前只定义了其中9个，没有使用到的标志位要求一律为零。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo5.png" alt="HelloWorld.class访问标志"></p>
<p>HelloWorld类是个普通类，不是接口、枚举、注解或者模块，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的<code>ACC_PUBLIC</code>、<code>ACC_SUPER</code>标志应当为真，而<code>ACC_FINAL</code>、<code>ACC_INTERFACE</code>、<code>ACC_ABSTRACT</code>、<code>ACC_SYNTHETIC</code>、<code>ACC_ANNOTATION</code>、<code>ACC_ENUM</code>、<code>ACC_MODULE</code>这七个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。</p>
<h4 id="5、类索引、父类索引与接口索引集合"><a href="#5、类索引、父类索引与接口索引集合" class="headerlink" title="5、类索引、父类索引与接口索引集合"></a>5、类索引、父类索引与接口索引集合</h4><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。</p>
<p>类索引用于确定这个类的全限定名。</p>
<p>父类索引用于确定这个类的父类的全限定名。</p>
<blockquote>
<p>由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。</p>
</blockquote>
<p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>
<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-ref-find.jpg" alt="类索引查找过程"></p>
<p>对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo6.png" alt="HelloWorld.class类索引、父类索引、接口索引集合"></p>
<p>从偏移地址0x000000D6开始的3个u2类型的值分别为0x0001、0x0003、0x0000，也就是类索引为1，父类索引为3，接口索引集合大小为0。</p>
<p>对于前面的字节码清单中：</p>
<pre class=" language-txt"><code class="language-txt">   #1 = Class              #2             //  test/com/xiaocai/klass/test/HelloWorld
   #2 = Utf8               test/com/xiaocai/klass/test/HelloWorld
   #3 = Class              #4             //  java/lang/Object
   #4 = Utf8               java/lang/Object</code></pre>
<h4 id="6、字段表集合"><a href="#6、字段表集合" class="headerlink" title="6、字段表集合"></a>6、字段表集合</h4><p>字段表（field_info）用于描述接口或者类中声明的变量。</p>
<p>Java语言中的”字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<blockquote>
<p>字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。</p>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
</blockquote>
<p>字段表结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attribute_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attribute_count</td>
</tr>
</tbody></table>
<p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型。</p>
<p>字段访问标志如下图：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-field-accflag.jpg" alt="字段访问标志表"></p>
<p>语法规则的约束，</p>
<p>ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一；</p>
<p>ACC_FINAL、ACC_VOLATILE不能同时选择。</p>
<p>接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志。</p>
<p>字段表中跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p>
<p>相关概念：</p>
<blockquote>
<p><strong>全限定名</strong>：</p>
<p>如：test/com/xiaocai/klass/test/HelloWorld 就是HelloWorld的全限定名。把包路径的<code>&quot;.&quot;</code>换成<code>&quot;/&quot;</code>，使用时最后一般会加入一个”；”号表示全限定名结束。</p>
<p><strong>简单名称</strong>（name_index）：</p>
<p>就是指没有类型和参数修饰的方法或者字段名称，这个类中的add()方法和m字段的简单名称分别就是”add”和”m”。</p>
<p><strong>方法和字段的描述符</strong>（descriptor_index）：</p>
<p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。</p>
</blockquote>
<p>关于描述符标识字符含义如下图：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-field-desc-index.jpg" alt="描述符标识字符含义"></p>
<p>对于数组类型，每一维度将使用一个前置的<code>&quot;[&quot;</code>字符来描述，如一个定义为<code>&quot;java.lang.String[][]&quot;</code>类型的二维数组将被记录成<code>&quot;[[Ljava/lang/String；&quot;</code>，一个整型数组<code>&quot;int[]&quot;</code>将被记录成<code>&quot;[I&quot;</code>。</p>
<blockquote>
<p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>&quot;()&quot;</code>之内。如方法<code>void inc()</code>的描述符为<code>&quot;()V&quot;</code>，方法<code>java.lang.StringtoString()</code>的描述符为<code>&quot;()Ljava/lang/String；&quot;</code>，方法<code>int indexOf(char[]source，intsourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，intfromIndex)</code>的描述符为<code>&quot;([CII[CIII)I&quot;</code>。</p>
</blockquote>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo7.png" alt="HelloWorld.calss字段表"></p>
<p>字段表集合从地址0x000001DC开始，第一个u2类型的数据为容量计数器fields_count，如上图所示，其值为0x0001，说明这个类只有一个字段表数据。</p>
<p>接下来紧跟着容量计数器的是access_flags标志，值为0x0002，代表private修饰符的ACC_PRIVATE标志位为真（ACC_PRIVATE标志的值为0x0002），其他修饰符为假。代表字段名称的name_index的值为0x0005，从列出的字节码清单常量表中可查得第五项常量是一个CONSTANT_Utf8_info类型的字符串，其值为”m”，代表字段描述符的descriptor_index的值为0x0006，指向常量池的字符串”I”。根据这些信息，我们可以推断出原代码定义的字段为”private int m；”。</p>
<blockquote>
<p>字段表所包含的固定数据项目到descriptor_index为止就全部结束，在descrip-tor_index之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。对于本例中的字段m，它的属性表计数器为0（也就是地址0x000001E4开始，值为0x0000），也就是没有需要额外描述的信息，但是，如果将字段m的声明改为”final static int m=123；”，那就可能会存在一项名称为ConstantValue的属性，其值指向常量123。</p>
</blockquote>
<h4 id="7、方法表集合"><a href="#7、方法表集合" class="headerlink" title="7、方法表集合"></a>7、方法表集合</h4><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</p>
<p>方法表与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p>
<p>方法表结构：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-method-1.jpg" alt="方法表结构"></p>
<p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。</p>
<p>方法访问标志及取值：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-method-accflag.jpg" alt="方法访问标志及取值表"></p>
<p>在字节码清单中，add方法对应的字节码内容，存放在方法属性表集合中一个名为”Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目。</p>
<p>Helloworld为例：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo8.png" alt="HelloWorld.class方法表结构"></p>
<pre class=" language-txt"><code class="language-txt">0x0003 ----> methods_count
0x0001 ----> access_flags
0x0007 ----> name_index
0x0008 ----> descriptor_index
0x0001 ----> attributs_count
0x0009 ----> attribute_name_index</code></pre>
<p>方法表集合的入口地址为0x000001E6，第一个u2类型的数据（即计数器容量）的值为0x0003，代表集合中有3个方法，这3个方法为编译器添加的实例构造器<code>&lt;init&gt;</code>和源码中定义的方法add()、主方法main()。</p>
<p>第一个方法的访问标志值为0x0001，也就是只有ACC_PUBLIC标志为真，名称索引值为0x0007，查字节码清单的常量池得方法名为<code>&quot;&lt;init&gt;&quot;</code>，对应字节码清单片段如下<code>#7</code>（也可以看上面列出的字节码清单）：</p>
<pre><code>#7 = Utf8               &lt;init&gt;
#8 = Utf8               ()V
#9 = Utf8               Code</code></pre><p>描述符索引值为0x0008，对应常量为”()V”，属性表计数器attributes_count的值为0x0001，表示此方法的属性表集合有1项属性，属性名称的索引值为0x0009，对应常量为”Code”，说明此属性是方法的字节码描述。</p>
<blockquote>
<p>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器<code>&quot;&lt;clinit&gt;()&quot;</code>方法和实例构造器<code>&quot;&lt;init&gt;()&quot;</code>方法</p>
</blockquote>
<p>Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。</p>
<blockquote>
<p>Java代码的方法特征签名只包括方法名称、参数顺序及参数类型。</p>
<p>字节码的特征签名除了包括方法名称、参数顺序及参数类型，还包括方法返回值以及受查异常表。</p>
</blockquote>
<p>特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</p>
<h4 id="8、属性表集合"><a href="#8、属性表集合" class="headerlink" title="8、属性表集合"></a>8、属性表集合</h4><p>属性表（attribute_info）</p>
<p>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p>
<p>特点：不要求严格的顺序，不能与已有属性名称重复</p>
<p>虚拟机规范预定义的属性：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-attr1.jpg" alt="虚拟机规范预定义的属性"></p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-attr2.jpg" alt="虚拟机规范预定义的属性"></p>
<p>每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足结j基本的属性表结构：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td align="center">u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td align="center">u1</td>
<td>info</td>
<td>attribute_length</td>
</tr>
</tbody></table>
<h5 id="1）-Code属性"><a href="#1）-Code属性" class="headerlink" title="1） Code属性"></a>1） Code属性</h5><p>Java程序方法体中的代码经过Javac编译器处理之后，变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，应该满足Code属性表基本结构：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-attr-code.jpg" alt="Code属性表基本结构"></p>
<p>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为”Code”，它代表了该属性的属性名称。</p>
<p>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。</p>
<p>max_stack代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。</p>
<p>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。</p>
<blockquote>
<p>对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。方法参数（包括实例方法中的隐藏参数”this”）、显式异常处理程序的参数（Exception Handler Parameter，就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。注意，并不是在方法中用了多少个局部变量，就把这些局部变量所占变量槽数量之和作为max_locals的值，操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</p>
</blockquote>
<p>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。</p>
<blockquote>
<p>字节码指令中，每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令。</p>
<p>目前，《Java虚拟机规范》已经定义了其中约200条编码值对应的指令含义，编码与指令之间的对应关系可查<a href="ee62cca5.html">《虚拟机字节码指令表》</a></p>
</blockquote>
<p>注意：</p>
<p>code_length，虽然它是一个u4类型的长度值，理论上最大值可以达到2的32次幂，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译。</p>
<p>Code属性是Class文件中最重要的一个属性。如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。</p>
<p>以HelloWorld.class为例：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo9.png" alt="Code属性表基本结构"></p>
<pre class=" language-txt"><code class="language-txt">0x0001 ----->操作数栈  max_stack
0x0001 ----->本地变量表 max_lcoals
0x0005 ----> 字节码区域长度 code_lenth
2A B7 000A B1 </code></pre>
<p>操作数栈的最大深度和本地变量表的容量都为0x0001，字节码区域所占空间的长度为0x0005。</p>
<blockquote>
<p>虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的5个字节，并根据字节码指令表翻译出所对应的字节码指令。翻译”2A B7000A B1”的过程为：</p>
<p>（1）读入2A，查字节码指令表得0x2A对应的指令为aload_0，这个指令的含义是将第0个变量槽中为reference类型的本地变量推送到操作数栈顶。</p>
<p>（2）读入B7，查字节码指令表得0xB7对应的指令为invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的符号引用。</p>
<p>（3）读入000A，这是invokespecial指令的参数，代表一个符号引用，查常量池得0x000A对应的常量为实例构造器<code>&quot;&lt;init&gt;()&quot;</code>方法的符号引用。</p>
<p>（4）读入B1，查字节码指令表得0xB1对应的指令为return，含义是从方法的返回，并且返回值为void。这条指令执行后，当前方法正常结束。</p>
</blockquote>
<p>在边看边印证过程中，我一开始没理解”查常量池得0x000A对应的常量”应该怎么查，突然发现0x000A对应的十进制是10，也就是常量池的第10个即：</p>
<p>#10 = Methodref          #3.#11         //  java/lang/Object.<code>&quot;&lt;init&gt;&quot;</code>:()V</p>
<p>仔细看这一行，其实就是实例构造器<code>&quot;&lt;init&gt;()&quot;</code>方法的符号引用。</p>
<p>字节码的执行过程中的数据交换、方法调用等操作都是基于栈（操作数栈）。</p>
<p>字节码清单中：</p>
<pre><code>//常量池省略....
{
  public test.com.xiaocai.klass.test.HelloWorld();
    flags: ACC_PUBLIC

    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return        
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   Ltest/com/xiaocai/klass/test/HelloWorld;

  public int add();
    flags: ACC_PUBLIC

    Code:
      stack=2, locals=1, args_size=1
         0: aload_0       
         1: getfield      #18                 // Field m:I
         4: iconst_1      
         5: iadd          
         6: ireturn       
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       7     0  this   Ltest/com/xiaocai/klass/test/HelloWorld;

  public static void main(java.lang.String[]);
    flags: ACC_PUBLIC, ACC_STATIC

    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #22                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #28                 // String Hello World!
         5: invokevirtual #30                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return        
      LineNumberTable:
        line 13: 0
        line 15: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       9     0  args   [Ljava/lang/String;
}</code></pre><p>“Args_size”的值为1的原因是因为this 关键字的访问机制。</p>
<blockquote>
<p>在任何实例方法里面，都可以通过”this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从1开始计算。</p>
<p>这个处理只对实例方法有效，如果代码中的add()方法被声明为static，那Args_size就不会等于1而是等于0。</p>
</blockquote>
<p>在字节码指令之后的是这个方法的显式异常处理表（简称异常表）集合，异常表对于Code属性来说并不是必须存在的。</p>
<p>如果存在异常表，那它的格式应如表6-16所示，包含四个字段：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>start_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>end_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>handler_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>catch_typr</td>
<td>1</td>
</tr>
</tbody></table>
<p>这些字段的含义为：</p>
<p>如果当字节码从第start_pc行到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。</p>
<blockquote>
<p>异常表实际上是Java代码的一部分，尽管字节码中有最初为处理异常而设计的跳转指令，但《Java虚拟机规范》中明确要求Java语言的编译器应当选择使用异常表而不是通过跳转指令来实现Java异常及finally处理机制</p>
</blockquote>
<p>定义try-catch-finally的源文件长这样：</p>
<pre><code>package test.com.xiaocai.klass.test;

public class TestCp {

    public int getNumber() {
        int x;
        try {
            x = 1;
            return x;
        } catch (Exception e) {
            x = 2;
            return x;
        } finally {
            x = 3;
        }
    }
}</code></pre><p>异常字节码清单：</p>
<pre class=" language-txt"><code class="language-txt">// 头部信息省略
{
  public test.com.xiaocai.klass.test.TestCp();
    flags: ACC_PUBLIC

    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokespecial #8                  // Method java/lang/Object."<init>":()V
         4: return        
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   Ltest/com/xiaocai/klass/test/TestCp;

  public int getNumber();
    flags: ACC_PUBLIC

    Code:
      stack=1, locals=5, args_size=1
         0: iconst_1      //try 里的x=1
         1: istore_1      
         2: iload_1       //保存x到returnValue x=1
         3: istore        4
         5: iconst_3      
         6: istore_1      
         7: iload         4 //将returnValue中的值放到栈顶，准备给 ireturn 返回
         9: ireturn       
        10: astore_2       //给catch中的定义的Exception e赋值，存储在变量槽2中
        11: iconst_2       //catch 里的x=2
        12: istore_1      
        13: iload_1       //保存x到returnValue中，此时x=2
        14: istore        4
        16: iconst_3       //finally 里的x=3
        17: istore_1      
        18: iload         4  //将returnValue中的值放到栈顶，准备给 ireturn 返回
        20: ireturn       
        21: astore_3      //如果出现了不属于java.lang.Exception及其子类的异常会走到这里
        22: iconst_3      //finaly快中的x=3
        23: istore_1      
        24: aload_3       //将异常放到栈顶
        25: athrow        //抛出异常
      Exception table:
         from    to  target type
             0     5    10   Class java/lang/Exception
             0     5    21   any
            10    16    21   any
     // 其他字节码省略
}</code></pre>
<p>完整字节码清单文件：<a href="/images/jvm-class/TestCp.TXT">TestCp.TXT</a></p>
<p>字节码清单中异常表<code>Exception table</code>对应三条可能出现的代码执行路径。</p>
<p>（a）如果try语句块中出现属于Exception或其子类的异常，转到catch语句块处理；</p>
<p>（b）如果try语句块中出现不属于Exception或其子类的异常，转到finally语句块处理；</p>
<p>（c）如果catch语句块中出现任何异常，转到finally语句块处理。</p>
<blockquote>
<p>字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且将此时x的值复制一份副本到最后一个本地变量表的变量槽中。</p>
<p>这个变量槽里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为方法返回值使用。假如给变量起个名字：returnValue。</p>
<p>如果这时候没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后将之前保存在returnValue中的整数1读入到操作栈顶，最后ireturn指令会以int形式返回操作栈顶中的值，方法结束。</p>
<p>如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是将2赋值给变量x，然后将变量x此时的值赋给returnValue，最后再将变量x的值改为3。方法返回前同样将returnValue中保留的整数2读到了操作栈顶。从第21行开始的代码，作用是将变量x的值赋为3，并将栈顶的异常抛出，方法结束。</p>
</blockquote>
<h5 id="2）-Exceptions属性"><a href="#2）-Exceptions属性" class="headerlink" title="2） Exceptions属性"></a>2） Exceptions属性</h5><p>Exceptions属性是在方法表中与Code属性平级的一项属性。</p>
<p>Exceptions属性的作用是列举出方法中可能抛出的受查异常（CheckedExcepitons），也就是方法描述时在throws关键字后面列举的异常。</p>
<p>Exceptions属性结构：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-Exceptions.jpg" alt="Exceptions属性结构"></p>
<p>number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示；exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p>
<h5 id="3）LineNumberTable属性"><a href="#3）LineNumberTable属性" class="headerlink" title="3）LineNumberTable属性"></a>3）LineNumberTable属性</h5><p>LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：lines选项来取消或要求生成这项信息。</p>
<p>如果选择不生成LineNumberTable属性，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</p>
<p>LineNumberTable属性结构：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-lineNumTable.jpg" alt="LineNumberTable属性结构"></p>
<p>line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包含start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。</p>
<h5 id="4）LocalVariableTable"><a href="#4）LocalVariableTable" class="headerlink" title="4）LocalVariableTable"></a>4）LocalVariableTable</h5><p>LocalVariableTable及LocalVariableTypeTable属性。</p>
<p>LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。</p>
<p>如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p>
<p>LocalVariableTable属性的结构：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-LocalVarTable.jpg" alt="LocalVariableTable属性结构"></p>
<p>其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，local_variable_info结构如下：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-LocalVarInfo.jpg" alt="LocalVariableTable属性结构"></p>
<p>start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</p>
<p>name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</p>
<p>index是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时（double和long），它占用的变量槽为index和index+1两个。</p>
<blockquote>
<p>在JDK 5引入泛型之后，LocalVariableTable属性增加了一个”姐妹属性”——LocalVariableTypeTable。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）。对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉[插图]，描述符就不能准确描述泛型类型了。因此出现了LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。</p>
</blockquote>
<h5 id="5）SourceFile"><a href="#5）SourceFile" class="headerlink" title="5）SourceFile"></a>5）SourceFile</h5><p>SourceFile及SourceDebugExtension属性。</p>
<p>SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性是一个定长的属性。</p>
<p>这个属性也是可选的，可以使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</p>
<p>SourceFile属性结构：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-sourceFile.jpg" alt="SourceFile属性结构"></p>
<p>sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。</p>
<blockquote>
<p>在JDK 5时，新增了SourceDebugExtension属性用于存储额外的代码调试信息。典型的场景是在进行JSP文件调试时，无法通过Java堆栈来定位到JSP文件的行号。JSR 45提案为这些非Java语言编写，却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制，使用SourceDebugExtension属性就可以用于存储这个标准所新加入的调试信息，譬如让程序员能够快速从异常堆栈中定位出原始JSP中出现问题的行号。</p>
</blockquote>
<p>SourceDebugExtension属性结构：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-SourceDebugExtension.jpg" alt="SourceFile属性结构"></p>
<p>其中debug_extension存储的就是额外的调试信息，是一组通过变长UTF-8格式来表示的字符串。一个类中最多只允许存在一个SourceDebugExtension属性。</p>
<p>6）ConstantValue属性</p>
<p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。</p>
<p>对非static类型的变量（也就是实例变量）的赋值是在实例构造器<code>&lt;init&gt;()</code>方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器<code>&lt;clinit&gt;()</code>方法中或者使用ConstantValue属性。</p>
<blockquote>
<p>目前Oracle公司实现的Javac编译器的选择是，如果同时使用final和static来修饰一个变量（本质是”常量”），并且这个变量的数据类型是基本类型或者java.lang.String的话，就将会生成ConstantValue属性来进行初始化；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<code>&lt;clinit&gt;()</code>方法中进行初始化。</p>
</blockquote>
<p>《Java虚拟机规范》中并没有强制要求final修饰字段必须设置ACC_FINAL标志，要求有ConstantValue属性的字段必须设置ACC_STATIC标志而已，对final关键字的要求是Javac编译器自己加入的限制。</p>
<p>ConstantValue属性结构：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-ConstantValue.jpg" alt="ConstantValue属性结构"></p>
<p>ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2。constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。</p>
<h5 id="7）InnerClasses属性"><a href="#7）InnerClasses属性" class="headerlink" title="7）InnerClasses属性"></a>7）InnerClasses属性</h5><p>InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-InnerClasses.jpg" alt="InnerClasses属性结构"></p>
<p>数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一个inner_classes_info表进行描述。</p>
<p> inner_classes_info表的结构：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-inner_classes_info.jpg" alt="inner_classes_info表结构"></p>
<p>inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。</p>
<p>inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，这项值为0。</p>
<p>inner_class_access_flags是内部类的访问标志，类似于类的access_flags，它的取值范围如表：</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-inner_class_access_flags.jpg" alt="inner_class_access_flags表结构"></p>
<h5 id="8）Deprecated及Synthetic属性"><a href="#8）Deprecated及Synthetic属性" class="headerlink" title="8）Deprecated及Synthetic属性"></a>8）Deprecated及Synthetic属性</h5><p><code>Deprecated</code>和<code>Synthetic</code>两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。<code>Deprecated</code>属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用<code>&quot;@deprecated&quot;</code>注解进行设置。</p>
<p>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的<code>ACC_SYNTHETIC</code>标志位。编译器通过生成一些在源代码中不存在的<code>Synthetic</code>方法、字段甚至是整个类的方式，实现了越权访问（越过<code>private</code>修饰器）或其他绕开了语言限制的功能，这可以算是一种早期优化的技巧，其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法（Bridge Method）。</p>
<p>所有由不属于用户代码产生的类、方法及字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位中的一项，唯一的例外是实例构造器<code>&quot;&lt;init&gt;()&quot;</code>方法和类构造器<code>&quot;&lt;clinit&gt;()&quot;</code>方法。</p>
<p>Deprecated和Synthetic属性的结构:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
</tbody></table>
<p>其中attribute_length数据项的值必须为0x00000000，因为没有任何属性值需要设置。</p>
<h5 id="9-StackMapTable属性"><a href="#9-StackMapTable属性" class="headerlink" title="9)StackMapTable属性"></a>9)StackMapTable属性</h5><p>StackMapTable属性在JDK 6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code属性的属性表中。</p>
<p>StackMapTable属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p>
<p>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。</p>
<p>StackMapTable属性结构:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_entries</td>
<td>1</td>
</tr>
<tr>
<td>stack_map_frame</td>
<td>stack_map_frame_entries</td>
<td>number_of_entries</td>
</tr>
</tbody></table>
<blockquote>
<p>在Java SE 7版之后的《Java虚拟机规范》中，明确规定对于版本号大于或等于50.0的Class文件，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性，这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</p>
</blockquote>
<h5 id="10-Signature属性"><a href="#10-Signature属性" class="headerlink" title="10)Signature属性"></a>10)Signature属性</h5><p>Signature属性在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（Parameterized Type），则Signature属性会为它记录泛型签名信息。</p>
<blockquote>
<p>因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。</p>
</blockquote>
<p>Signature属性结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>signature_index</td>
<td>1</td>
</tr>
</tbody></table>
<p>其中signature_index项的值必须是一个对常量池的有效索引。</p>
<p>常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名或方法类型签名或字段类型签名。如果当前的Signature属性是类文件的属性，则这个结构表示类签名，如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。</p>
<h5 id="11-BootstrapMethods属性"><a href="#11-BootstrapMethods属性" class="headerlink" title="11)BootstrapMethods属性"></a>11)BootstrapMethods属性</h5><p>BootstrapMethods属性在JDK 7时增加到Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。</p>
<blockquote>
<p>根据《Java虚拟机规范》（从Java SE 7版起）的规定，如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件的属性表中必须存在一个明确的BootstrapMethods属性，另外，即使CONSTANT_InvokeDynamic_info类型的常量在常量池中出现过多次，类文件的属性表中最多也只能有一个BootstrapMethods属性。BootstrapMethods属性和JSR-292中的InvokeDynamic指令和java.lang.Invoke包关系非常密切</p>
</blockquote>
<p>JDK 8中Lambda表达式和接口默认方法的出现，InvokeDynamic指令有了使用发挥的环境。</p>
<p>BootstrapMethods属性结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_bootstrap_methods</td>
<td></td>
</tr>
<tr>
<td>bootstrap_method</td>
<td>bootstrap_methods</td>
<td>num_bootstrap_methods</td>
</tr>
</tbody></table>
<p>引用到的bootstrap_method结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>bootstrap_method_ref</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_bootstrap_arguments</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>bootstrap_arguments</td>
<td>num_bootstrap_arguments</td>
</tr>
</tbody></table>
<p>BootstrapMethods属性里，num_bootstrap_methods项的值给出了bootstrap_methods[]数组中的引导方法限定符的数量。而bootstrap_methods[]数组的每个成员包含了一个指向常量池CONSTANT_MethodHandle结构的索引值，它代表了一个引导方法。还包含了这个引导方法静态参数的序列（可能为空）。</p>
<p>bootstrap_methods[]数组的每个成员必须包含以下三项内容：</p>
<p>（a）bootstrap_method_ref：bootstrap_method_ref项的值必须是一个对常量池的有效索引。常量池在该索引处的值必须是一个CONSTANT_MethodHandle_info结构。</p>
<p>（b）num_bootstrap_arguments：num_bootstrap_arguments项的值给出了bootstrap_argu-ments[]数组成员的数量。</p>
<p>（c）bootstrap_arguments[]：bootstrap_arguments[]数组的每个成员必须是一个对常量池的有效索引。常量池在该索引出必须是下列结构之一：CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info或CONSTANT_MethodType_info。</p>
<h5 id="12-MethodParameters属性"><a href="#12-MethodParameters属性" class="headerlink" title="12)MethodParameters属性"></a>12)MethodParameters属性</h5><p>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。MethodParameters的作用是记录方法的各个形参名称和信息。</p>
<p>JDK 8中新增的这个属性，使得编译器可以（编译时加上-parameters参数）将方法名称也写进Class文件中，而且MethodParameters是方法表的属性，与Code属性平级的，可以运行时通过反射API获取。</p>
<p>MethodParameters属性结构:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>parameters_count</td>
<td>1</td>
</tr>
<tr>
<td>parameter</td>
<td>parameters</td>
<td>parameters_count</td>
</tr>
</tbody></table>
<p>引用到的parameter属性结构:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
</tbody></table>
<p>name_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该参数的名称。</p>
<p>access_flags是参数的状态指示器，它可以包含以下三种状态中的一种或多种：</p>
<p>（a）0x0010（ACC_FINAL）：表示该参数被final修饰。</p>
<p>（b）0x1000（ACC_SYNTHETIC）：表示该参数并未出现在源文件中，是编译器自动生成的。</p>
<p>（c）0x8000（ACC_MANDATED）：表示该参数是在源文件中隐式定义的。Java语言中的典型场景是this关键字。</p>
<h5 id="13-模块化相关属性"><a href="#13-模块化相关属性" class="headerlink" title="13)模块化相关属性"></a>13)模块化相关属性</h5><p>JDK 9的一个重量级功能是Java的模块化功能，因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了Module、ModulePackages和ModuleMainClass三个属性用于支持Java模块化相关功能。</p>
<p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容。</p>
<p>Module属性结构:</p>
<p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-Module.jpg" alt="Module属性结构"></p>
<p>module_name_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该模块的名称。</p>
<p>module_flags是模块的状态指示器，它可以包含以下三种状态中的一种或多种：</p>
<p>（a）0x0020（ACC_OPEN）：表示该模块是开放的。</p>
<p>（b）0x1000（ACC_SYNTHETIC）：表示该模块并未出现在源文件中，是编译器自动生成的。</p>
<p>（c）0x8000（ACC_MANDATED）：表示该模块是在源文件中隐式定义的。</p>
<p>module_version_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该模块的版本号。</p>
<p>后面的几个属性分别记录了模块的requires、exports、opens、uses和provides定义，结构基本相似，如</p>
<p>exports属性结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>exports_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>exports_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>exports_to_count</td>
<td>1</td>
</tr>
<tr>
<td>export</td>
<td>exports_to_index</td>
<td>exports_to_count</td>
</tr>
</tbody></table>
<p>exports属性的每一元素都代表一个被模块所导出的包。</p>
<p>exports_index是一个指向常量池CONSTANT_Package_info常量的索引值，代表了被该模块导出的包。</p>
<p>exports_flags是该导出包的状态指示器，它可以包含以下两种状态中的一种或多种：</p>
<p>（a）0x1000（ACC_SYNTHETIC）：表示该导出包并未出现在源文件中，是编译器自动生成的。</p>
<p>（b）0x8000（ACC_MANDATED）：表示该导出包是在源文件中隐式定义的。</p>
<p>exports_to_count是该导出包的限定计数器，如果这个计数器为零，这说明该导出包是无限定的（Unqualified），即完全开放的，任何其他模块都可以访问该包中所有内容。如果该计数器不为零，则后面的exports_to_index是以计数器值为长度的数组，每个数组元素都是一个指向常量池中CONSTANT_Module_info常量的索引值，代表着只有在这个数组范围内的模块才被允许访问该导出包的内容。</p>
<p>ModulePackages是另一个用于支持Java模块化的变长属性，它用于描述该模块中所有的包，不论是不是被export或者open的。</p>
<p>ModulePackages属性结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>package_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>package_index</td>
<td>package_count</td>
</tr>
</tbody></table>
<p>package_count是package_index数组的计数器，package_index中每个元素都是指向常量池CONSTANT_Package_info常量的索引值，代表了当前模块中的一个包。</p>
<p>ModuleMainClass属性是一个定长属性，用于确定该模块的主类（Main Class）。</p>
<p>ModuleMainClass属性结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>main_class_index</td>
<td>1</td>
</tr>
</tbody></table>
<p>main_class_index是一个指向常量池CONSTANT_Class_info常量的索引值，代表了该模块的主类。</p>
<h5 id="14-运行时注解相关属性"><a href="#14-运行时注解相关属性" class="headerlink" title="14)运行时注解相关属性"></a>14)运行时注解相关属性</h5><p>JDK 5时提供了对注解（Annotation）的支持。</p>
<p>为了存储源码中注解信息，Class文件同步增加了<code>RuntimeVisibleAnnotations</code>、<code>RuntimeInvisibleAnnotations</code>、<code>RuntimeVisibleParameterAnnotations</code>和<code>RuntimeInvisibleParameter-Annotations</code>四个属性。到了JDK 8时期，进一步加强了Java语言的注解使用范围，又新增类型注解（JSR 308），所以Class文件中也同步增加了<code>RuntimeVisibleTypeAnnotations</code>和<code>RuntimeInvisibleTypeAnnotations</code>两个属性。</p>
<p>这6个属性结构功能都比较相似：</p>
<p>RuntimeVisibleAnnotations是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解，当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</p>
<p>RuntimeVisibleAnnotations属性结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_annotations</td>
<td>1</td>
</tr>
<tr>
<td>annotation</td>
<td>annotations</td>
<td>num_annotations</td>
</tr>
</tbody></table>
<p>num_annotations是annotations数组的计数器，annotations中每个元素都代表了一个运行时可见的注解，注解在Class文件中以annotation结构来存储</p>
<p>annotation属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>type_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_element_value_pairs</td>
<td>1</td>
</tr>
<tr>
<td>element_value_pair</td>
<td>element_value_pairs</td>
<td>num_element_value_pairs</td>
</tr>
</tbody></table>
<p>type_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，该常量应以字段描述符的形式表示一个注解。num_element_value_pairs是element_value_pairs数组的计数器，element_value_pairs中每个元素都是一个键值对，代表该注解的参数和值。</p>
<h3 id="二、Class文件结构的发展"><a href="#二、Class文件结构的发展" class="headerlink" title="二、Class文件结构的发展"></a>二、Class文件结构的发展</h3><p>JDK的版本号已经从1.0提升到了13。相对于语言、API以及Java技术体系中其他方面的变化，Class文件结构一直处于一个相对比较稳定的状态，Class文件的主体结构、字节码指令的语义和数量几乎没有出现过变动[插图]，所有对Class文件格式的改进，都集中在访问标志、属性表这些设计上原本就是可扩展的数据结构中添加新内容。</p>
<blockquote>
<p>以《Java虚拟机规范（第2版）》（对应于JDK 1.4，是Java 2的奠基版本）为基准进行比较的话，在后续Class文件格式的发展过程中，访问标志新加入了ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_BRIDGE、ACC_VARARGS共五个标志。属性表集合中，在JDK 5到JDK 12发展过程中一共增加了20项新属性，这些属性大部分是用于支持Java中许多新出现的语言特性，如枚举、变长参数、泛型、动态注解等。还有一些是为了支持性能改进和调试信息，譬如JDK 6的新类型校验器的StackMapTable属性和对非Java代码调试中用到的SourceDebugExtension属性。</p>
</blockquote>
<p>Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>class结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建静态博客（七）——客服与推送</title>
    <url>/posts/1c633c7e.html</url>
    <content><![CDATA[<h2 id="一、客服聊天窗口"><a href="#一、客服聊天窗口" class="headerlink" title="一、客服聊天窗口"></a>一、客服聊天窗口</h2><blockquote>
<p>这个是我在Sky03的博客发现的，最初感觉问问题方面，我实际使用之后，主要感觉还是可以监控是否有人访问网站。</p>
</blockquote>
<p>1、在官网注册账号</p>
<p>官网地址：<a href="https://app.crisp.chat/initiate/signup/" target="_blank" rel="noopener">点我去crisp官网注册</a></p>
<p>2、注册完成后设置</p>
<p>登录刚才注册的账户——设置——网站设置——添加网站。</p>
<p>添加完成之后就多了一行网站信息。点网站整合，就有不同的站的整合方式。</p>
<p>比如：html方式</p>
<p>就是复制JS代码片段到你的到<code>head</code>标签里。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>window<span class="token punctuation">.</span>$crisp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span>CRISP_WEBSITE_ID<span class="token operator">=</span><span class="token string">"xxxxxxx-097e-402f-bb6b-xxxxxxx"</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>d<span class="token operator">=</span>document<span class="token punctuation">;</span>s<span class="token operator">=</span>d<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span>src<span class="token operator">=</span><span class="token string">"https://client.crisp.chat/l.js"</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token keyword">async</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"head"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre>
<p>3、其他的设置也<br>登录刚才注册的账户——设置——网站设置。<br>网站信息行——设置，自己根据需要设置即可，比如显示位置，颜色，自己的头像等。</p>
<p>整个使用非常简单的。</p>
<h2 id="二、网页推送插件"><a href="#二、网页推送插件" class="headerlink" title="二、网页推送插件"></a>二、网页推送插件</h2><blockquote>
<p>这个是我在过客励む的博客发现的，感觉还是很不错的。 Web Push Notification ,浏览器通知推送</p>
</blockquote>
<p>1、安装插件</p>
<p>插件的GitHub仓库: <a href="https://github.com/glazec/hexo-web-push-notification" target="_blank" rel="noopener">hexo-web-push-notification</a></p>
<p>执行命令安装：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i hexo-web-push-notification --save</code></pre>
<p>特别说明：如果你不喜欢安装插件，也可以跳过。直接调到注册步骤。只是没有安装和配置，就需要采用复制JS代码片段的方式到你的html的head里面，一样可以实现效果。</p>
<p>2、修改根目录的<code>_config.yml</code>配置文件</p>
<pre class=" language-yml"><code class="language-yml">webPushNotification:
  webpushrKey: "your webpushr rest api key"
  webpushrAuthToken: "your webpushr authorize token"
  trackingCode: "AEGlpbdgvBCWXqXI6PtsUzobY7TLV9gwJU8bzMktrwfrSERg_xnLVbjpCw8x2GmFmi1ZcLTz0ni6OnX5MAwoM88"
</code></pre>
<p>其中<code>webpushrKey</code>,<code>webpushrAuthToken</code>和<code>trackingCode</code>的值在官网注册得到。</p>
<p>3、注册webpushr</p>
<p>注册官网：<a href="https://app.webpushr.com/signup" target="_blank" rel="noopener">点我去webpushr注册也</a></p>
<p><strong>特别说明：</strong><br>注册账号和登录需要进行人机身份验证，这个需要使用过客励む的插件，永久破解版的。</p>
<p>插件地址： [大佬的插件]（<a href="https://72k.us/file/19365016-441665146）" target="_blank" rel="noopener">https://72k.us/file/19365016-441665146）</a></p>
<p>如果上面链接失效就来<a href="https://pan.baidu.com/s/1D7n6xvPZUxRuZsGP9doarw" target="_blank" rel="noopener">百度云链接</a></p>
<p>提取码：bp7s</p>
<p>然后放在浏览器的扩展中，在强制刷新网站(Ctrl + F5),应该就可以看到了。如果看不懂就先点注册或登录，就可以自己出来了。</p>
<p>4、安装</p>
<p>就是按顺序，填写信息，上传图片，三步走。</p>
<p>安装成功后，进入主界面。</p>
<p>点击<code>Integration</code>下的 <code>REST API密钥</code>就可以看到<code>webpushrKey</code>和<code>webpushrAuthToken</code>的值了。</p>
<p>点击<code>Setting</code>下的 <code>Tracking code</code></p>
<p>有个 <code>Step 2: Add Tracking Code</code>地下也是JS代码片段</p>
<pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- start webpushr tracking code --></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>d<span class="token punctuation">,</span> s<span class="token punctuation">,</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>webpushr<span class="token punctuation">)</span><span class="token operator">!==</span><span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>w<span class="token punctuation">.</span>webpushr<span class="token operator">=</span>w<span class="token punctuation">.</span>webpushr<span class="token operator">||</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>webpushr<span class="token punctuation">.</span>q<span class="token operator">=</span>w<span class="token punctuation">.</span>webpushr<span class="token punctuation">.</span>q<span class="token operator">||</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> js<span class="token punctuation">,</span> fjs <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>js <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> js<span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>js<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">"https://cdn.webpushr.com/app.min.js"</span><span class="token punctuation">;</span>
fjs<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>js<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span>document<span class="token punctuation">,</span> <span class="token string">'script'</span><span class="token punctuation">,</span> <span class="token string">'webpushr-jssdk'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">webpushr</span><span class="token punctuation">(</span><span class="token string">'setup'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">'key'</span><span class="token punctuation">:</span><span class="token string">'xxxx_BJKMKcoDBNWov5xxxhl3p0eFxxxxgogE5bQRheUA7eytp5rcZXYHdodyiVfbOxxxxPfv4'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre>
<p>最后key的值就是 <code>trackingCode</code>。</p>
<p>5、设置推送相关</p>
<p>主要设置在<code>Setting</code>下的前面三个，分别是：<br>（A）Opt-In Prompts —-选择加入提示<br>（B）Subscription Bell   —-订阅铃<br>（C）Welcome Push   ——欢迎推送</p>
<p>因为我已经操作完成就不截图了，只做了一个记录。使用谷歌有谷歌翻译，应该没有看不懂的。<br>如果不想自己摸索，可以参考过客励む写的细节操作的截图文<a href="https://yafine-blog.cn/posts/ebb2.html" target="_blank" rel="noopener">《Hexo博客订阅文章通知功能》</a>。</p>
<p>最后感谢大佬让我见识了新技术。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
