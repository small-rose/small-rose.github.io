<!-- build time:Sat Jul 18 2020 01:03:39 GMT+0800 (中国标准时间) --><!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="keywords" content="java,jvm, class结构, 字节码"><meta name="description" content="个人技术笔记，记录学习/开发问题"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>jvm之类文件结构 | 张小菜苔</title><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/css/matery.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/css/my.css"><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/jquery/jquery.min.js"></script><script type="text/javascript">window.$crisp=[],window.CRISP_WEBSITE_ID="0c0bcdb7-097e-402f-bb6b-9cf042148a9e",function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)}()</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="张小菜苔" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><div><img src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/medias/logo-1.png" class="logo-img" alt="LOGO"> <span class="logo-span">张小菜苔</span></div></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home"></i><span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags"></i><span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark"></i><span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive"></i><span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle"></i><span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="https://zhangxiaocai.cn/contact" target="_blank" rel="noopener" class="waves-effect waves-light"><i class="fas fa-comments"></i><span>留言薄</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book"></i><span>友情链接</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/navigate" class="waves-effect waves-light"><i class="fas fa-location-arrow"></i><span>导航</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索"></i></a></li><li><a href="javascript:fullscreen()" class="modal-trigger waves-effect waves-light"><i id="fullscreen" class="fa fa-expand-arrows-alt" title="全屏"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/medias/logo-1.png" class="logo-img circle responsive-img"><div class="logo-name">张小菜苔</div><div class="logo-desc">个人技术笔记，记录学习/开发问题</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="https://zhangxiaocai.cn/contact" target="_blank" rel="noopener" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言薄</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li class="m-nav-item"><a href="/navigate" class="waves-effect waves-light"><i class="fa-fw fas fa-location-arrow"></i> 导航</a></li></ul></div></div></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/images/jvm-logo.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">jvm之类文件结构</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:32px;bottom:155px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/JVM/"><span class="chip bg-color">JVM</span> </a><a href="/tags/class%E7%BB%93%E6%9E%84/"><span class="chip bg-color">class结构</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/JVM/" class="post-category">JVM</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-06-09</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 14.7k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp; 55 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="jvm类文件结构"><a href="#jvm类文件结构" class="headerlink" title="jvm类文件结构"></a>jvm类文件结构</h2><p>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（ByteCode）。</p><blockquote><p>Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与”Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。</p><p>Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。</p></blockquote><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class.jpg" alt="java虚拟机的语言无关性"></p><h2 id="一、Class类文件的结构"><a href="#一、Class类文件的结构" class="headerlink" title="一、Class类文件的结构"></a>一、Class类文件的结构</h2><h4 id="1、class文件的主要结构"><a href="#1、class文件的主要结构" class="headerlink" title="1、class文件的主要结构"></a>1、class文件的主要结构</h4><p>通常来说，任何一个Class文件都对应着唯一的一个类或接口的定义信息。类或接口并不一定都得定义在文件里（比如类或接口也可以动态生成，直接送入类加载器中）。</p><blockquote><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[插图]的方式分割成若干个8个字节进行存储。</p></blockquote><p>《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：”无符号数”和”表”。</p><p>（1）无符号数：</p><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p><p>（2）表</p><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表的命名都习惯性地以<code>&quot;_info&quot;</code>结尾。</p><p>表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，表的数据项按严格顺序排列构成的。</p><p>class文件格式数据项如图：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-2.jpg" alt="class文件格式"></p><p>无符号数或表中，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的”集合”。</p><p><strong>特别说明</strong></p><blockquote><p>Class的结构没有任何分隔符号，所以上图的数据项中，无论是顺序还是数量，甚至于数据存储的字节序（ByteOrdering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变。</p></blockquote><h4 id="2、魔数与Class文件的版本"><a href="#2、魔数与Class文件的版本" class="headerlink" title="2、魔数与Class文件的版本"></a>2、魔数与Class文件的版本</h4><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p><p>java的Class文件的魔数值固定为<code>0xCAFEBABE</code>。</p><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。</p><blockquote><p>Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p></blockquote><p>当我学到这里我算是明白以前在项目过程中，遇到用高版本编译，低版本运行报错的真正原因了。</p><p>如：JDK 1.1能支持版本号为45.0～45.65535的Class文件，无法执行版本号为46.0以上的Class文件，而JDK 1.2则能支持45.0～46.65535的Class文件。目前最新的JDK版本为13，可生成的Class文件主版本号最大值为57.0。</p><p>比如来个经典的HelloWorld文件，加个变量和方法：</p><pre class="language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">.</span>com<span class="token punctuation">.</span>xiaocai<span class="token punctuation">.</span>klass<span class="token punctuation">.</span>test<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>用WinHex打开HelloWorld.class文件：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo1.png" alt="HelloWorld.class文件版本示例"></p><p>可以清楚地看见开头4个字节的十六进制表示是0xCAFEBABE，代表次版本号的第5个和第6个字节值为0x0000，而主版本号的值为0x0033，也即是十进制的51，对应的jdk7，可以被jdk7及以上版本虚拟机执行。</p><p>主流JDK版本编译器输出的默认的和可支持的Class文件版本号。</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-verson.jpg" alt="jdk与class文件版本对照"></p><p>注：从JDK 9开始，Javac编译器不再支持使用-source参数编译版本号小于1.5的源码。</p><p>次版本号，从JDK 1.2以后，直到JDK 12之前次版本号均未使用，全部固定为零。JDK 12开始，重新启用次版本号，将它用于标识”技术预览版”功能特性的支持。如果Class文件中使用了该版本JDK尚未列入正式特性清单中的预览功能，则必须把次版本号标识为65535，以便Java虚拟机在加载类文件时能够区分出来。</p><h4 id="3、常量池"><a href="#3、常量池" class="headerlink" title="3、常量池"></a>3、常量池</h4><p>紧接着主、次版本号之后的是常量池入口。常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</p><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。这个容量计数是从1而不是0开始的，如图HelloWorld类文件截图：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo2.png" alt="HelloWorld.class里的常量池"></p><p>常量池容量（偏移地址：0x00000008）为十六进制数0x0028，即十进制的40，这就代表常量池中有40项常量，索引值范围为1～40。</p><blockquote><p>索引值第0项常量空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始。</p></blockquote><p>常量池中主要存放两大类常量：字面量（Literal） 和 符号引用（Symbolic References） 。</p><p>（1）字面量（Literal）</p><p>如文本字符串、被声明为final的常量值等</p><p>（2）符号引用（Symbolic References） :</p><p>主要有以下几类：</p><p>​ （a）被模块导出或者开放的包（Package）</p><p>​ （b）类和接口的全限定名（Fully Qualified Name）</p><p>​ （c）字段的名称和描述符（Descriptor）</p><p>​ （d）方法的名称和描述符</p><p>​ （e）方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</p><p>​ （f）动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-ComputedConstant）</p><blockquote><p>虚拟机加载Class文件的时候进行动态连接，所以在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p></blockquote><p>常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量[插图]，为了支持Java模块化系统（Jigsaw），又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量，所以截至JDK 13，常量表中分别有17种不同类型的常量。</p><p>17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位（tag），代表着当前常量属于哪种常量类型。如图：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-clc.jpg" alt="17种常量类型"></p><p>这17种常量类型各自有着完全独立的数据结构。</p><p>依旧以Helloworld.class为例：</p><p>标志位（偏移地址：0x0000000A）是0x07，查上表标志是7对应的常量类型是CONSTANT_Class_info，代表一个类或者接口的符号引用。</p><p>CONSTANT_Class_info的结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>ul</td><td>tag</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr></tbody></table><p>tag是标志位，它用于区分常量类型；</p><p>name_index是常量池的索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名。</p><p>依旧以Helloworld.class为例</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo3.png" alt="HelloWorld类常量池结构"></p><p>name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量，图中第二项常量标志位（地址：0x0000000D）是0x01。查常量池表，可以确定是一个CONSTANT_Utf8_info类型的常量。</p><p>CONSTANT_Utf8_info型常量的结构:</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>ul</td><td>tag</td><td>1</td></tr><tr><td>u2</td><td>length</td><td>1</td></tr><tr><td>u1</td><td>bytes</td><td>length</td></tr></tbody></table><blockquote><p>length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。UTF-8缩略编码与普通UTF-8编码的区别是：从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’开始到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</p></blockquote><p>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。Java程序中如果定义了超过64KB英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</p><p>在helloworld的例中</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo4.png" alt="常量池UTF-8字符串结构"></p><p>这个字符串的length值（偏移地址：0x0000000E）为0x0026，也就是长38个字节，往后38个字节正好都在1～127的ASCII码范围以内，内容为”test.com.xiaocai.klass.test.HelloWorld”，转换部分后续再补上。</p><p>//十六进制转换待补充</p><p>在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。</p><p>直接使用javap工具的-verbose参数输出的TestClass.class文件字节码内容。</p><p>命令如下：</p><pre><code>javap -verbose HelloWorld.class </code></pre><p>由于文件长我写到txt里，全部内容如下，暂且称之为字节码清单：</p><pre class="language-txt"><code class="language-txt">Classfile /E:/ide-tools/apache-tomcat-7.0.90-eclispe-pmis/webapps/pmis/WEB-INF/classes/test/com/xiaocai/klass/test/HelloWorld.class
  Last modified 2020-6-9; size 691 bytes
  MD5 checksum 549d707e6692d2c884983e3ad0873405
  Compiled from "HelloWorld.java"
public class test.com.xiaocai.klass.test.HelloWorld
  SourceFile: "HelloWorld.java"
  minor version: 0
  major version: 51
  flags: ACC_PUBLIC, ACC_SUPER

Constant pool:
   #1 = Class              #2             //  test/com/xiaocai/klass/test/HelloWorld
   #2 = Utf8               test/com/xiaocai/klass/test/HelloWorld
   #3 = Class              #4             //  java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Utf8               m
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Methodref          #3.#11         //  java/lang/Object."<init>":()V
  #11 = NameAndType        #7:#8          //  "<init>":()V
  #12 = Utf8               LineNumberTable
  #13 = Utf8               LocalVariableTable
  #14 = Utf8               this
  #15 = Utf8               Ltest/com/xiaocai/klass/test/HelloWorld;
  #16 = Utf8               add
  #17 = Utf8               ()I
  #18 = Fieldref           #1.#19         //  test/com/xiaocai/klass/test/HelloWorld.m:I
  #19 = NameAndType        #5:#6          //  m:I
  #20 = Utf8               main
  #21 = Utf8               ([Ljava/lang/String;)V
  #22 = Fieldref           #23.#25        //  java/lang/System.out:Ljava/io/PrintStream;
  #23 = Class              #24            //  java/lang/System
  #24 = Utf8               java/lang/System
  #25 = NameAndType        #26:#27        //  out:Ljava/io/PrintStream;
  #26 = Utf8               out
  #27 = Utf8               Ljava/io/PrintStream;
  #28 = String             #29            //  Hello World!
  #29 = Utf8               Hello World!
  #30 = Methodref          #31.#33        //  java/io/PrintStream.println:(Ljava/lang/String;)V
  #31 = Class              #32            //  java/io/PrintStream
  #32 = Utf8               java/io/PrintStream
  #33 = NameAndType        #34:#35        //  println:(Ljava/lang/String;)V
  #34 = Utf8               println
  #35 = Utf8               (Ljava/lang/String;)V
  #36 = Utf8               args
  #37 = Utf8               [Ljava/lang/String;
  #38 = Utf8               SourceFile
  #39 = Utf8               HelloWorld.java
{
  public test.com.xiaocai.klass.test.HelloWorld();
    flags: ACC_PUBLIC

    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokespecial #10                 // Method java/lang/Object."<init>":()V
         4: return        
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   Ltest/com/xiaocai/klass/test/HelloWorld;

  public int add();
    flags: ACC_PUBLIC

    Code:
      stack=2, locals=1, args_size=1
         0: aload_0       
         1: getfield      #18                 // Field m:I
         4: iconst_1      
         5: iadd          
         6: ireturn       
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       7     0  this   Ltest/com/xiaocai/klass/test/HelloWorld;

  public static void main(java.lang.String[]);
    flags: ACC_PUBLIC, ACC_STATIC

    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #22                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #28                 // String Hello World!
         5: invokevirtual #30                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return        
      LineNumberTable:
        line 13: 0
        line 15: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       9     0  args   [Ljava/lang/String;
}</init></init></init></init></code></pre><p>根据清单可以看出常量池中有39项常量，索引值范围为1～39，对应着十六进制的0x0028，也就是十进制的40。</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo0.jpg" alt="常量池中的17种数据类型的结构总表1"></p><p>字节码清单中第1、2项常量的计算结果与我们手工计算的结果完全一致。</p><blockquote><p>还有一些常量如”I”、”V”、”<init>“、”LineNumberTable”、”LocalVariableTable”等都是 编译器自己生成的，会被字段表（field_info）、方法表（method_info）、属性表（attribute_info）所引用。它们将会被用来描述一些不方便使用”固定字节”进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么。</init></p></blockquote><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-changlangchi-1.jpg" alt="常量池中的17种数据类型的结构总表1"></p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-changlangchi-2.jpg" alt="常量池中的17种数据类型的结构总表2"></p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-changlangchi-3.jpg" alt="常量池中的17种数据类型的结构总表3"></p><h4 id="4、访问标志"><a href="#4、访问标志" class="headerlink" title="4、访问标志"></a>4、访问标志</h4><p>常量池结束之后，紧接着的2个字节代表访问标志（access_flags）。</p><p>访问标志用于识别一些类或者接口层次的访问信息。包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。</p><p>访问标志相关说明如下表：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-accessflag.jpg" alt="访问标志说明表"></p><p>access_flags中一共有16个标志位可以使用，当前只定义了其中9个，没有使用到的标志位要求一律为零。</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo5.png" alt="HelloWorld.class访问标志"></p><p>HelloWorld类是个普通类，不是接口、枚举、注解或者模块，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的<code>ACC_PUBLIC</code>、<code>ACC_SUPER</code>标志应当为真，而<code>ACC_FINAL</code>、<code>ACC_INTERFACE</code>、<code>ACC_ABSTRACT</code>、<code>ACC_SYNTHETIC</code>、<code>ACC_ANNOTATION</code>、<code>ACC_ENUM</code>、<code>ACC_MODULE</code>这七个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。</p><h4 id="5、类索引、父类索引与接口索引集合"><a href="#5、类索引、父类索引与接口索引集合" class="headerlink" title="5、类索引、父类索引与接口索引集合"></a>5、类索引、父类索引与接口索引集合</h4><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。</p><p>类索引用于确定这个类的全限定名。</p><p>父类索引用于确定这个类的父类的全限定名。</p><blockquote><p>由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。</p></blockquote><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-ref-find.jpg" alt="类索引查找过程"></p><p>对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo6.png" alt="HelloWorld.class类索引、父类索引、接口索引集合"></p><p>从偏移地址0x000000D6开始的3个u2类型的值分别为0x0001、0x0003、0x0000，也就是类索引为1，父类索引为3，接口索引集合大小为0。</p><p>对于前面的字节码清单中：</p><pre class="language-txt"><code class="language-txt">   #1 = Class              #2             //  test/com/xiaocai/klass/test/HelloWorld
   #2 = Utf8               test/com/xiaocai/klass/test/HelloWorld
   #3 = Class              #4             //  java/lang/Object
   #4 = Utf8               java/lang/Object</code></pre><h4 id="6、字段表集合"><a href="#6、字段表集合" class="headerlink" title="6、字段表集合"></a>6、字段表集合</h4><p>字段表（field_info）用于描述接口或者类中声明的变量。</p><p>Java语言中的”字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><blockquote><p>字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。</p><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p></blockquote><p>字段表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attribute_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attribute_count</td></tr></tbody></table><p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型。</p><p>字段访问标志如下图：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-field-accflag.jpg" alt="字段访问标志表"></p><p>语法规则的约束，</p><p>ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一；</p><p>ACC_FINAL、ACC_VOLATILE不能同时选择。</p><p>接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志。</p><p>字段表中跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><p>相关概念：</p><blockquote><p><strong>全限定名</strong>：</p><p>如：test/com/xiaocai/klass/test/HelloWorld 就是HelloWorld的全限定名。把包路径的<code>&quot;.&quot;</code>换成<code>&quot;/&quot;</code>，使用时最后一般会加入一个”；”号表示全限定名结束。</p><p><strong>简单名称</strong>（name_index）：</p><p>就是指没有类型和参数修饰的方法或者字段名称，这个类中的add()方法和m字段的简单名称分别就是”add”和”m”。</p><p><strong>方法和字段的描述符</strong>（descriptor_index）：</p><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。</p></blockquote><p>关于描述符标识字符含义如下图：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-field-desc-index.jpg" alt="描述符标识字符含义"></p><p>对于数组类型，每一维度将使用一个前置的<code>&quot;[&quot;</code>字符来描述，如一个定义为<code>&quot;java.lang.String[][]&quot;</code>类型的二维数组将被记录成<code>&quot;[[Ljava/lang/String；&quot;</code>，一个整型数组<code>&quot;int[]&quot;</code>将被记录成<code>&quot;[I&quot;</code>。</p><blockquote><p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>&quot;()&quot;</code>之内。如方法<code>void inc()</code>的描述符为<code>&quot;()V&quot;</code>，方法<code>java.lang.StringtoString()</code>的描述符为<code>&quot;()Ljava/lang/String；&quot;</code>，方法<code>int indexOf(char[]source，intsourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，intfromIndex)</code>的描述符为<code>&quot;([CII[CIII)I&quot;</code>。</p></blockquote><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo7.png" alt="HelloWorld.calss字段表"></p><p>字段表集合从地址0x000001DC开始，第一个u2类型的数据为容量计数器fields_count，如上图所示，其值为0x0001，说明这个类只有一个字段表数据。</p><p>接下来紧跟着容量计数器的是access_flags标志，值为0x0002，代表private修饰符的ACC_PRIVATE标志位为真（ACC_PRIVATE标志的值为0x0002），其他修饰符为假。代表字段名称的name_index的值为0x0005，从列出的字节码清单常量表中可查得第五项常量是一个CONSTANT_Utf8_info类型的字符串，其值为”m”，代表字段描述符的descriptor_index的值为0x0006，指向常量池的字符串”I”。根据这些信息，我们可以推断出原代码定义的字段为”private int m；”。</p><blockquote><p>字段表所包含的固定数据项目到descriptor_index为止就全部结束，在descrip-tor_index之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。对于本例中的字段m，它的属性表计数器为0（也就是地址0x000001E4开始，值为0x0000），也就是没有需要额外描述的信息，但是，如果将字段m的声明改为”final static int m=123；”，那就可能会存在一项名称为ConstantValue的属性，其值指向常量123。</p></blockquote><h4 id="7、方法表集合"><a href="#7、方法表集合" class="headerlink" title="7、方法表集合"></a>7、方法表集合</h4><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</p><p>方法表与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p><p>方法表结构：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-method-1.jpg" alt="方法表结构"></p><p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。</p><p>方法访问标志及取值：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-method-accflag.jpg" alt="方法访问标志及取值表"></p><p>在字节码清单中，add方法对应的字节码内容，存放在方法属性表集合中一个名为”Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目。</p><p>Helloworld为例：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo8.png" alt="HelloWorld.class方法表结构"></p><pre class="language-txt"><code class="language-txt">0x0003 ----> methods_count
0x0001 ----> access_flags
0x0007 ----> name_index
0x0008 ----> descriptor_index
0x0001 ----> attributs_count
0x0009 ----> attribute_name_index</code></pre><p>方法表集合的入口地址为0x000001E6，第一个u2类型的数据（即计数器容量）的值为0x0003，代表集合中有3个方法，这3个方法为编译器添加的实例构造器<code>&lt;init&gt;</code>和源码中定义的方法add()、主方法main()。</p><p>第一个方法的访问标志值为0x0001，也就是只有ACC_PUBLIC标志为真，名称索引值为0x0007，查字节码清单的常量池得方法名为<code>&quot;&lt;init&gt;&quot;</code>，对应字节码清单片段如下<code>#7</code>（也可以看上面列出的字节码清单）：</p><pre><code>#7 = Utf8               &lt;init&gt;
#8 = Utf8               ()V
#9 = Utf8               Code</code></pre><p>描述符索引值为0x0008，对应常量为”()V”，属性表计数器attributes_count的值为0x0001，表示此方法的属性表集合有1项属性，属性名称的索引值为0x0009，对应常量为”Code”，说明此属性是方法的字节码描述。</p><blockquote><p>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器<code>&quot;&lt;clinit&gt;()&quot;</code>方法和实例构造器<code>&quot;&lt;init&gt;()&quot;</code>方法</p></blockquote><p>Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。</p><blockquote><p>Java代码的方法特征签名只包括方法名称、参数顺序及参数类型。</p><p>字节码的特征签名除了包括方法名称、参数顺序及参数类型，还包括方法返回值以及受查异常表。</p></blockquote><p>特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</p><h4 id="8、属性表集合"><a href="#8、属性表集合" class="headerlink" title="8、属性表集合"></a>8、属性表集合</h4><p>属性表（attribute_info）</p><p>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p><p>特点：不要求严格的顺序，不能与已有属性名称重复</p><p>虚拟机规范预定义的属性：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-attr1.jpg" alt="虚拟机规范预定义的属性"></p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-attr2.jpg" alt="虚拟机规范预定义的属性"></p><p>每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足结j基本的属性表结构：</p><table><thead><tr><th align="center">类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td align="center">u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td align="center">u4</td><td>attribute_length</td><td>1</td></tr><tr><td align="center">u1</td><td>info</td><td>attribute_length</td></tr></tbody></table><h5 id="1）-Code属性"><a href="#1）-Code属性" class="headerlink" title="1） Code属性"></a>1） Code属性</h5><p>Java程序方法体中的代码经过Javac编译器处理之后，变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，应该满足Code属性表基本结构：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-attr-code.jpg" alt="Code属性表基本结构"></p><p>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为”Code”，它代表了该属性的属性名称。</p><p>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。</p><p>max_stack代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。</p><p>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。</p><blockquote><p>对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。方法参数（包括实例方法中的隐藏参数”this”）、显式异常处理程序的参数（Exception Handler Parameter，就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。注意，并不是在方法中用了多少个局部变量，就把这些局部变量所占变量槽数量之和作为max_locals的值，操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</p></blockquote><p>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。</p><blockquote><p>字节码指令中，每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令。</p><p>目前，《Java虚拟机规范》已经定义了其中约200条编码值对应的指令含义，编码与指令之间的对应关系可查<a href="ee62cca5.html">《虚拟机字节码指令表》</a></p></blockquote><p>注意：</p><p>code_length，虽然它是一个u4类型的长度值，理论上最大值可以达到2的32次幂，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译。</p><p>Code属性是Class文件中最重要的一个属性。如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。</p><p>以HelloWorld.class为例：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-demo9.png" alt="Code属性表基本结构"></p><pre class="language-txt"><code class="language-txt">0x0001 ----->操作数栈  max_stack
0x0001 ----->本地变量表 max_lcoals
0x0005 ----> 字节码区域长度 code_lenth
2A B7 000A B1 </code></pre><p>操作数栈的最大深度和本地变量表的容量都为0x0001，字节码区域所占空间的长度为0x0005。</p><blockquote><p>虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的5个字节，并根据字节码指令表翻译出所对应的字节码指令。翻译”2A B7000A B1”的过程为：</p><p>（1）读入2A，查字节码指令表得0x2A对应的指令为aload_0，这个指令的含义是将第0个变量槽中为reference类型的本地变量推送到操作数栈顶。</p><p>（2）读入B7，查字节码指令表得0xB7对应的指令为invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的符号引用。</p><p>（3）读入000A，这是invokespecial指令的参数，代表一个符号引用，查常量池得0x000A对应的常量为实例构造器<code>&quot;&lt;init&gt;()&quot;</code>方法的符号引用。</p><p>（4）读入B1，查字节码指令表得0xB1对应的指令为return，含义是从方法的返回，并且返回值为void。这条指令执行后，当前方法正常结束。</p></blockquote><p>在边看边印证过程中，我一开始没理解”查常量池得0x000A对应的常量”应该怎么查，突然发现0x000A对应的十进制是10，也就是常量池的第10个即：</p><p>#10 = Methodref #3.#11 // java/lang/Object.<code>&quot;&lt;init&gt;&quot;</code>:()V</p><p>仔细看这一行，其实就是实例构造器<code>&quot;&lt;init&gt;()&quot;</code>方法的符号引用。</p><p>字节码的执行过程中的数据交换、方法调用等操作都是基于栈（操作数栈）。</p><p>字节码清单中：</p><pre><code>//常量池省略....
{
  public test.com.xiaocai.klass.test.HelloWorld();
    flags: ACC_PUBLIC

    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return        
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   Ltest/com/xiaocai/klass/test/HelloWorld;

  public int add();
    flags: ACC_PUBLIC

    Code:
      stack=2, locals=1, args_size=1
         0: aload_0       
         1: getfield      #18                 // Field m:I
         4: iconst_1      
         5: iadd          
         6: ireturn       
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       7     0  this   Ltest/com/xiaocai/klass/test/HelloWorld;

  public static void main(java.lang.String[]);
    flags: ACC_PUBLIC, ACC_STATIC

    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #22                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #28                 // String Hello World!
         5: invokevirtual #30                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return        
      LineNumberTable:
        line 13: 0
        line 15: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       9     0  args   [Ljava/lang/String;
}</code></pre><p>“Args_size”的值为1的原因是因为this 关键字的访问机制。</p><blockquote><p>在任何实例方法里面，都可以通过”this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从1开始计算。</p><p>这个处理只对实例方法有效，如果代码中的add()方法被声明为static，那Args_size就不会等于1而是等于0。</p></blockquote><p>在字节码指令之后的是这个方法的显式异常处理表（简称异常表）集合，异常表对于Code属性来说并不是必须存在的。</p><p>如果存在异常表，那它的格式应如表6-16所示，包含四个字段：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>start_pc</td><td>1</td></tr><tr><td>u2</td><td>end_pc</td><td>1</td></tr><tr><td>u2</td><td>handler_pc</td><td>1</td></tr><tr><td>u2</td><td>catch_typr</td><td>1</td></tr></tbody></table><p>这些字段的含义为：</p><p>如果当字节码从第start_pc行到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。</p><blockquote><p>异常表实际上是Java代码的一部分，尽管字节码中有最初为处理异常而设计的跳转指令，但《Java虚拟机规范》中明确要求Java语言的编译器应当选择使用异常表而不是通过跳转指令来实现Java异常及finally处理机制</p></blockquote><p>定义try-catch-finally的源文件长这样：</p><pre><code>package test.com.xiaocai.klass.test;

public class TestCp {

    public int getNumber() {
        int x;
        try {
            x = 1;
            return x;
        } catch (Exception e) {
            x = 2;
            return x;
        } finally {
            x = 3;
        }
    }
}</code></pre><p>异常字节码清单：</p><pre class="language-txt"><code class="language-txt">// 头部信息省略
{
  public test.com.xiaocai.klass.test.TestCp();
    flags: ACC_PUBLIC

    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokespecial #8                  // Method java/lang/Object."<init>":()V
         4: return        
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0       5     0  this   Ltest/com/xiaocai/klass/test/TestCp;

  public int getNumber();
    flags: ACC_PUBLIC

    Code:
      stack=1, locals=5, args_size=1
         0: iconst_1      //try 里的x=1
         1: istore_1      
         2: iload_1       //保存x到returnValue x=1
         3: istore        4
         5: iconst_3      
         6: istore_1      
         7: iload         4 //将returnValue中的值放到栈顶，准备给 ireturn 返回
         9: ireturn       
        10: astore_2       //给catch中的定义的Exception e赋值，存储在变量槽2中
        11: iconst_2       //catch 里的x=2
        12: istore_1      
        13: iload_1       //保存x到returnValue中，此时x=2
        14: istore        4
        16: iconst_3       //finally 里的x=3
        17: istore_1      
        18: iload         4  //将returnValue中的值放到栈顶，准备给 ireturn 返回
        20: ireturn       
        21: astore_3      //如果出现了不属于java.lang.Exception及其子类的异常会走到这里
        22: iconst_3      //finaly快中的x=3
        23: istore_1      
        24: aload_3       //将异常放到栈顶
        25: athrow        //抛出异常
      Exception table:
         from    to  target type
             0     5    10   Class java/lang/Exception
             0     5    21   any
            10    16    21   any
     // 其他字节码省略
}</init></code></pre><p>完整字节码清单文件：<a href="/images/jvm-class/TestCp.TXT">TestCp.TXT</a></p><p>字节码清单中异常表<code>Exception table</code>对应三条可能出现的代码执行路径。</p><p>（a）如果try语句块中出现属于Exception或其子类的异常，转到catch语句块处理；</p><p>（b）如果try语句块中出现不属于Exception或其子类的异常，转到finally语句块处理；</p><p>（c）如果catch语句块中出现任何异常，转到finally语句块处理。</p><blockquote><p>字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且将此时x的值复制一份副本到最后一个本地变量表的变量槽中。</p><p>这个变量槽里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为方法返回值使用。假如给变量起个名字：returnValue。</p><p>如果这时候没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后将之前保存在returnValue中的整数1读入到操作栈顶，最后ireturn指令会以int形式返回操作栈顶中的值，方法结束。</p><p>如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是将2赋值给变量x，然后将变量x此时的值赋给returnValue，最后再将变量x的值改为3。方法返回前同样将returnValue中保留的整数2读到了操作栈顶。从第21行开始的代码，作用是将变量x的值赋为3，并将栈顶的异常抛出，方法结束。</p></blockquote><h5 id="2）-Exceptions属性"><a href="#2）-Exceptions属性" class="headerlink" title="2） Exceptions属性"></a>2） Exceptions属性</h5><p>Exceptions属性是在方法表中与Code属性平级的一项属性。</p><p>Exceptions属性的作用是列举出方法中可能抛出的受查异常（CheckedExcepitons），也就是方法描述时在throws关键字后面列举的异常。</p><p>Exceptions属性结构：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-Exceptions.jpg" alt="Exceptions属性结构"></p><p>number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示；exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p><h5 id="3）LineNumberTable属性"><a href="#3）LineNumberTable属性" class="headerlink" title="3）LineNumberTable属性"></a>3）LineNumberTable属性</h5><p>LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：lines选项来取消或要求生成这项信息。</p><p>如果选择不生成LineNumberTable属性，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</p><p>LineNumberTable属性结构：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-lineNumTable.jpg" alt="LineNumberTable属性结构"></p><p>line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包含start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。</p><h5 id="4）LocalVariableTable"><a href="#4）LocalVariableTable" class="headerlink" title="4）LocalVariableTable"></a>4）LocalVariableTable</h5><p>LocalVariableTable及LocalVariableTypeTable属性。</p><p>LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。</p><p>如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p><p>LocalVariableTable属性的结构：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-LocalVarTable.jpg" alt="LocalVariableTable属性结构"></p><p>其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，local_variable_info结构如下：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-LocalVarInfo.jpg" alt="LocalVariableTable属性结构"></p><p>start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</p><p>name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</p><p>index是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时（double和long），它占用的变量槽为index和index+1两个。</p><blockquote><p>在JDK 5引入泛型之后，LocalVariableTable属性增加了一个”姐妹属性”——LocalVariableTypeTable。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）。对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉[插图]，描述符就不能准确描述泛型类型了。因此出现了LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。</p></blockquote><h5 id="5）SourceFile"><a href="#5）SourceFile" class="headerlink" title="5）SourceFile"></a>5）SourceFile</h5><p>SourceFile及SourceDebugExtension属性。</p><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性是一个定长的属性。</p><p>这个属性也是可选的，可以使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</p><p>SourceFile属性结构：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-sourceFile.jpg" alt="SourceFile属性结构"></p><p>sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。</p><blockquote><p>在JDK 5时，新增了SourceDebugExtension属性用于存储额外的代码调试信息。典型的场景是在进行JSP文件调试时，无法通过Java堆栈来定位到JSP文件的行号。JSR 45提案为这些非Java语言编写，却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制，使用SourceDebugExtension属性就可以用于存储这个标准所新加入的调试信息，譬如让程序员能够快速从异常堆栈中定位出原始JSP中出现问题的行号。</p></blockquote><p>SourceDebugExtension属性结构：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-SourceDebugExtension.jpg" alt="SourceFile属性结构"></p><p>其中debug_extension存储的就是额外的调试信息，是一组通过变长UTF-8格式来表示的字符串。一个类中最多只允许存在一个SourceDebugExtension属性。</p><p>6）ConstantValue属性</p><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。</p><p>对非static类型的变量（也就是实例变量）的赋值是在实例构造器<code>&lt;init&gt;()</code>方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器<code>&lt;clinit&gt;()</code>方法中或者使用ConstantValue属性。</p><blockquote><p>目前Oracle公司实现的Javac编译器的选择是，如果同时使用final和static来修饰一个变量（本质是”常量”），并且这个变量的数据类型是基本类型或者java.lang.String的话，就将会生成ConstantValue属性来进行初始化；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<code>&lt;clinit&gt;()</code>方法中进行初始化。</p></blockquote><p>《Java虚拟机规范》中并没有强制要求final修饰字段必须设置ACC_FINAL标志，要求有ConstantValue属性的字段必须设置ACC_STATIC标志而已，对final关键字的要求是Javac编译器自己加入的限制。</p><p>ConstantValue属性结构：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-ConstantValue.jpg" alt="ConstantValue属性结构"></p><p>ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2。constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。</p><h5 id="7）InnerClasses属性"><a href="#7）InnerClasses属性" class="headerlink" title="7）InnerClasses属性"></a>7）InnerClasses属性</h5><p>InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-InnerClasses.jpg" alt="InnerClasses属性结构"></p><p>数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一个inner_classes_info表进行描述。</p><p>inner_classes_info表的结构：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-inner_classes_info.jpg" alt="inner_classes_info表结构"></p><p>inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。</p><p>inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，这项值为0。</p><p>inner_class_access_flags是内部类的访问标志，类似于类的access_flags，它的取值范围如表：</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-inner_class_access_flags.jpg" alt="inner_class_access_flags表结构"></p><h5 id="8）Deprecated及Synthetic属性"><a href="#8）Deprecated及Synthetic属性" class="headerlink" title="8）Deprecated及Synthetic属性"></a>8）Deprecated及Synthetic属性</h5><p><code>Deprecated</code>和<code>Synthetic</code>两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。<code>Deprecated</code>属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用<code>&quot;@deprecated&quot;</code>注解进行设置。</p><p>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的<code>ACC_SYNTHETIC</code>标志位。编译器通过生成一些在源代码中不存在的<code>Synthetic</code>方法、字段甚至是整个类的方式，实现了越权访问（越过<code>private</code>修饰器）或其他绕开了语言限制的功能，这可以算是一种早期优化的技巧，其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法（Bridge Method）。</p><p>所有由不属于用户代码产生的类、方法及字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位中的一项，唯一的例外是实例构造器<code>&quot;&lt;init&gt;()&quot;</code>方法和类构造器<code>&quot;&lt;clinit&gt;()&quot;</code>方法。</p><p>Deprecated和Synthetic属性的结构:</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr></tbody></table><p>其中attribute_length数据项的值必须为0x00000000，因为没有任何属性值需要设置。</p><h5 id="9-StackMapTable属性"><a href="#9-StackMapTable属性" class="headerlink" title="9)StackMapTable属性"></a>9)StackMapTable属性</h5><p>StackMapTable属性在JDK 6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code属性的属性表中。</p><p>StackMapTable属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p><p>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。</p><p>StackMapTable属性结构:</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>number_of_entries</td><td>1</td></tr><tr><td>stack_map_frame</td><td>stack_map_frame_entries</td><td>number_of_entries</td></tr></tbody></table><blockquote><p>在Java SE 7版之后的《Java虚拟机规范》中，明确规定对于版本号大于或等于50.0的Class文件，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性，这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</p></blockquote><h5 id="10-Signature属性"><a href="#10-Signature属性" class="headerlink" title="10)Signature属性"></a>10)Signature属性</h5><p>Signature属性在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（Parameterized Type），则Signature属性会为它记录泛型签名信息。</p><blockquote><p>因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。</p></blockquote><p>Signature属性结构：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>signature_index</td><td>1</td></tr></tbody></table><p>其中signature_index项的值必须是一个对常量池的有效索引。</p><p>常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名或方法类型签名或字段类型签名。如果当前的Signature属性是类文件的属性，则这个结构表示类签名，如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。</p><h5 id="11-BootstrapMethods属性"><a href="#11-BootstrapMethods属性" class="headerlink" title="11)BootstrapMethods属性"></a>11)BootstrapMethods属性</h5><p>BootstrapMethods属性在JDK 7时增加到Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。</p><blockquote><p>根据《Java虚拟机规范》（从Java SE 7版起）的规定，如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件的属性表中必须存在一个明确的BootstrapMethods属性，另外，即使CONSTANT_InvokeDynamic_info类型的常量在常量池中出现过多次，类文件的属性表中最多也只能有一个BootstrapMethods属性。BootstrapMethods属性和JSR-292中的InvokeDynamic指令和java.lang.Invoke包关系非常密切</p></blockquote><p>JDK 8中Lambda表达式和接口默认方法的出现，InvokeDynamic指令有了使用发挥的环境。</p><p>BootstrapMethods属性结构：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>num_bootstrap_methods</td><td></td></tr><tr><td>bootstrap_method</td><td>bootstrap_methods</td><td>num_bootstrap_methods</td></tr></tbody></table><p>引用到的bootstrap_method结构：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>bootstrap_method_ref</td><td>1</td></tr><tr><td>u2</td><td>num_bootstrap_arguments</td><td>1</td></tr><tr><td>u2</td><td>bootstrap_arguments</td><td>num_bootstrap_arguments</td></tr></tbody></table><p>BootstrapMethods属性里，num_bootstrap_methods项的值给出了bootstrap_methods[]数组中的引导方法限定符的数量。而bootstrap_methods[]数组的每个成员包含了一个指向常量池CONSTANT_MethodHandle结构的索引值，它代表了一个引导方法。还包含了这个引导方法静态参数的序列（可能为空）。</p><p>bootstrap_methods[]数组的每个成员必须包含以下三项内容：</p><p>（a）bootstrap_method_ref：bootstrap_method_ref项的值必须是一个对常量池的有效索引。常量池在该索引处的值必须是一个CONSTANT_MethodHandle_info结构。</p><p>（b）num_bootstrap_arguments：num_bootstrap_arguments项的值给出了bootstrap_argu-ments[]数组成员的数量。</p><p>（c）bootstrap_arguments[]：bootstrap_arguments[]数组的每个成员必须是一个对常量池的有效索引。常量池在该索引出必须是下列结构之一：CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info或CONSTANT_MethodType_info。</p><h5 id="12-MethodParameters属性"><a href="#12-MethodParameters属性" class="headerlink" title="12)MethodParameters属性"></a>12)MethodParameters属性</h5><p>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。MethodParameters的作用是记录方法的各个形参名称和信息。</p><p>JDK 8中新增的这个属性，使得编译器可以（编译时加上-parameters参数）将方法名称也写进Class文件中，而且MethodParameters是方法表的属性，与Code属性平级的，可以运行时通过反射API获取。</p><p>MethodParameters属性结构:</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u1</td><td>parameters_count</td><td>1</td></tr><tr><td>parameter</td><td>parameters</td><td>parameters_count</td></tr></tbody></table><p>引用到的parameter属性结构:</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr></tbody></table><p>name_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该参数的名称。</p><p>access_flags是参数的状态指示器，它可以包含以下三种状态中的一种或多种：</p><p>（a）0x0010（ACC_FINAL）：表示该参数被final修饰。</p><p>（b）0x1000（ACC_SYNTHETIC）：表示该参数并未出现在源文件中，是编译器自动生成的。</p><p>（c）0x8000（ACC_MANDATED）：表示该参数是在源文件中隐式定义的。Java语言中的典型场景是this关键字。</p><h5 id="13-模块化相关属性"><a href="#13-模块化相关属性" class="headerlink" title="13)模块化相关属性"></a>13)模块化相关属性</h5><p>JDK 9的一个重量级功能是Java的模块化功能，因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了Module、ModulePackages和ModuleMainClass三个属性用于支持Java模块化相关功能。</p><p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容。</p><p>Module属性结构:</p><p><img src="/medias/loading-animated.gif" data-original="/images/jvm-class/jvm-6-class-Module.jpg" alt="Module属性结构"></p><p>module_name_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该模块的名称。</p><p>module_flags是模块的状态指示器，它可以包含以下三种状态中的一种或多种：</p><p>（a）0x0020（ACC_OPEN）：表示该模块是开放的。</p><p>（b）0x1000（ACC_SYNTHETIC）：表示该模块并未出现在源文件中，是编译器自动生成的。</p><p>（c）0x8000（ACC_MANDATED）：表示该模块是在源文件中隐式定义的。</p><p>module_version_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该模块的版本号。</p><p>后面的几个属性分别记录了模块的requires、exports、opens、uses和provides定义，结构基本相似，如</p><p>exports属性结构：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>exports_index</td><td>1</td></tr><tr><td>u2</td><td>exports_flags</td><td>1</td></tr><tr><td>u2</td><td>exports_to_count</td><td>1</td></tr><tr><td>export</td><td>exports_to_index</td><td>exports_to_count</td></tr></tbody></table><p>exports属性的每一元素都代表一个被模块所导出的包。</p><p>exports_index是一个指向常量池CONSTANT_Package_info常量的索引值，代表了被该模块导出的包。</p><p>exports_flags是该导出包的状态指示器，它可以包含以下两种状态中的一种或多种：</p><p>（a）0x1000（ACC_SYNTHETIC）：表示该导出包并未出现在源文件中，是编译器自动生成的。</p><p>（b）0x8000（ACC_MANDATED）：表示该导出包是在源文件中隐式定义的。</p><p>exports_to_count是该导出包的限定计数器，如果这个计数器为零，这说明该导出包是无限定的（Unqualified），即完全开放的，任何其他模块都可以访问该包中所有内容。如果该计数器不为零，则后面的exports_to_index是以计数器值为长度的数组，每个数组元素都是一个指向常量池中CONSTANT_Module_info常量的索引值，代表着只有在这个数组范围内的模块才被允许访问该导出包的内容。</p><p>ModulePackages是另一个用于支持Java模块化的变长属性，它用于描述该模块中所有的包，不论是不是被export或者open的。</p><p>ModulePackages属性结构：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>package_count</td><td>1</td></tr><tr><td>u2</td><td>package_index</td><td>package_count</td></tr></tbody></table><p>package_count是package_index数组的计数器，package_index中每个元素都是指向常量池CONSTANT_Package_info常量的索引值，代表了当前模块中的一个包。</p><p>ModuleMainClass属性是一个定长属性，用于确定该模块的主类（Main Class）。</p><p>ModuleMainClass属性结构：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>main_class_index</td><td>1</td></tr></tbody></table><p>main_class_index是一个指向常量池CONSTANT_Class_info常量的索引值，代表了该模块的主类。</p><h5 id="14-运行时注解相关属性"><a href="#14-运行时注解相关属性" class="headerlink" title="14)运行时注解相关属性"></a>14)运行时注解相关属性</h5><p>JDK 5时提供了对注解（Annotation）的支持。</p><p>为了存储源码中注解信息，Class文件同步增加了<code>RuntimeVisibleAnnotations</code>、<code>RuntimeInvisibleAnnotations</code>、<code>RuntimeVisibleParameterAnnotations</code>和<code>RuntimeInvisibleParameter-Annotations</code>四个属性。到了JDK 8时期，进一步加强了Java语言的注解使用范围，又新增类型注解（JSR 308），所以Class文件中也同步增加了<code>RuntimeVisibleTypeAnnotations</code>和<code>RuntimeInvisibleTypeAnnotations</code>两个属性。</p><p>这6个属性结构功能都比较相似：</p><p>RuntimeVisibleAnnotations是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解，当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</p><p>RuntimeVisibleAnnotations属性结构：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>num_annotations</td><td>1</td></tr><tr><td>annotation</td><td>annotations</td><td>num_annotations</td></tr></tbody></table><p>num_annotations是annotations数组的计数器，annotations中每个元素都代表了一个运行时可见的注解，注解在Class文件中以annotation结构来存储</p><p>annotation属性结构</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>type_index</td><td>1</td></tr><tr><td>u2</td><td>num_element_value_pairs</td><td>1</td></tr><tr><td>element_value_pair</td><td>element_value_pairs</td><td>num_element_value_pairs</td></tr></tbody></table><p>type_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，该常量应以字段描述符的形式表示一个注解。num_element_value_pairs是element_value_pairs数组的计数器，element_value_pairs中每个元素都是一个键值对，代表该注解的参数和值。</p><h3 id="二、Class文件结构的发展"><a href="#二、Class文件结构的发展" class="headerlink" title="二、Class文件结构的发展"></a>二、Class文件结构的发展</h3><p>JDK的版本号已经从1.0提升到了13。相对于语言、API以及Java技术体系中其他方面的变化，Class文件结构一直处于一个相对比较稳定的状态，Class文件的主体结构、字节码指令的语义和数量几乎没有出现过变动[插图]，所有对Class文件格式的改进，都集中在访问标志、属性表这些设计上原本就是可扩展的数据结构中添加新内容。</p><blockquote><p>以《Java虚拟机规范（第2版）》（对应于JDK 1.4，是Java 2的奠基版本）为基准进行比较的话，在后续Class文件格式的发展过程中，访问标志新加入了ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_BRIDGE、ACC_VARARGS共五个标志。属性表集合中，在JDK 5到JDK 12发展过程中一共增加了20项新属性，这些属性大部分是用于支持Java中许多新出现的语言特性，如枚举、变长参数、泛型、动态注解等。还有一些是为了支持性能改进和调试信息，譬如JDK 6的新类型校验器的StackMapTable属性和对非Java代码调试中用到的SourceDebugExtension属性。</p></blockquote><p>Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">Small-Rose /张小菜</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://small-rose.github.io/posts/6698cab3.html">https://small-rose.github.io/posts/6698cab3.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">Small-Rose /张小菜</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/JVM/"><span class="chip bg-color">JVM</span> </a><a href="/tags/class%E7%BB%93%E6%9E%84/"><span class="chip bg-color">class结构</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/share/js/social-share.min.js"></script></div></div></div><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.4rem;line-height:38px}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22AB38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019FE8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/gitalk/gitalk.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/css/my-gitalk.css"><div class="card gitalk-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="gitalk-container" class="card-content"></div></div><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/gitalk/gitalk.min.js"></script><script>let gitalk = new Gitalk({
        clientID: '25d0a50a89b8a9328515',
        clientSecret: '87ad6a6e64a7b5727d9c9f5f049f5a28bf714dcc',
        repo: 'small-rose.github.io',
        owner: 'small-rose',
        admin: "small-rose",
        id: '2020-06-09T00-00-00',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/a2ceb3e5.html"><div class="card-image"><img src="/images/jvm-logo.jpg" class="responsive-img" alt="jvm之字节码指令"> <span class="card-title">jvm之字节码指令</span></div></a><div class="card-content article-content"><div class="summary block-with-text">本文记录jvm之字节码指令学习。</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2020-06-09 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/JVM/" class="post-category">JVM</a></span></div></div><div class="card-action article-tags"><a href="/tags/JVM/"><span class="chip bg-color">JVM</span> </a><a href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/"><span class="chip bg-color">字节码指令</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/ee62cca5.html"><div class="card-image"><img src="/images/jvm-logo.jpg" class="responsive-img" alt="jvm字节码指令表"> <span class="card-title">jvm字节码指令表</span></div></a><div class="card-content article-content"><div class="summary block-with-text">本文记录 JVM字节码指令表。</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2020-06-09 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/JVM/" class="post-category">JVM</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E8%A1%A8/"><span class="chip bg-color">字节码指令表</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if("undefined"!=typeof window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("120"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: 张小菜苔<br />文章作者: Small Rose / 张小菜<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/aplayer/APlayer.min.css"><style>.aplayer .aplayer-lrc p{display:none;font-size:12px;font-weight:700;line-height:16px!important}.aplayer .aplayer-lrc p.aplayer-lrc-current{display:none;font-size:15px;color:#42b983}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><div><div class="row"><meting-js class="col l8 offset-l2 m10 offset-m1 s12" server="netease" type="playlist" id="503838841" fixed="true" autoplay theme="#42b983" loop order="random" preload="auto" volume="0.7" list-folded="true"></meting-js></div></div><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/aplayer/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2020</span> <a href="/about" target="_blank">Small Rose / 张小菜</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">95.2k</span>&nbsp;字 <span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><span id="sitetime">载入运行时间...</span><script>function siteTime(){var e=1e3,t=60*e,n=60*t,o=24*n,r=365*o,a=new Date,i="2020",l="5",m="1",M="0",g="0",d="0",s=a.getFullYear(),u=a.getMonth()+1,T=a.getDate(),c=a.getHours(),f=a.getMinutes(),h=a.getSeconds(),y=Date.UTC(i,l,m,M,g,d),H=Date.UTC(s,u,T,c,f,h),I=H-y,B=Math.floor(I/r),D=Math.floor(I/o-365*B),E=Math.floor((I-(365*B+D)*o)/n),L=Math.floor((I-(365*B+D)*o-E*n)/t),v=Math.floor((I-(365*B+D)*o-E*n-L*t)/e);i==s?(document.getElementById("year").innerHTML=s,document.getElementById("sitetime").innerHTML="本站已安全运行 "+D+" 天 "+E+" 小时 "+L+" 分钟 "+v+" 秒"):(document.getElementById("year").innerHTML=i+" - "+s,document.getElementById("sitetime").innerHTML="本站已安全运行 "+B+" 年 "+D+" 天 "+E+" 小时 "+L+" 分钟 "+v+" 秒")}setInterval(siteTime,1e3)</script><br><span id="icp"><img src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/medias/icp.png" style="vertical-align:text-bottom"> <a href="http://beian.miit.gov.cn/" target="_blank">鄂ICP备19015637号</a></span></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/small-rose" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:small-rose@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=970175021" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 970175021" data-position="top" data-delay="50"><i class="fab fa-qq"></i> </a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/materialize/materialize.min.js"></script><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/masonry/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/aos/aos.js"></script><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/js/matery.js"></script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/others/clicklove.js" async></script><script async src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript" size="150" alpha="0.6" zindex="-1" src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/background/ribbon-refresh.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/libs/instantpage/instantpage.js" type="module"></script><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/js/funnyTitle.js" type="module"></script><script src="/js/sakura.js" type="module"></script><script src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/js/fullscreen.js" type="module"></script><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)})})</script><script>!function(t){function e(){n&&(i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var e,o,a=0;a<i.length;a++)e=i[a],0<=(o=e.getBoundingClientRect()).bottom&&0<=o.left&&o.top<=(t.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,o,r=i[a];t=r,e=function(){i=i.filter(function(t){return r!==t})},n=new Image,o=t.getAttribute("data-original"),n.onload=function(){t.src=o,e&&e()},n.src=o}()}t.imageLazyLoadSetting.processImages=e;var n=t.imageLazyLoadSetting.isSPA,i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));e(),t.addEventListener("scroll",function(){var n,i;n=e,i=t,clearTimeout(n.tId),n.tId=setTimeout(function(){n.call(i)},500)})}(this)</script></body></html><!-- rebuild by neat -->